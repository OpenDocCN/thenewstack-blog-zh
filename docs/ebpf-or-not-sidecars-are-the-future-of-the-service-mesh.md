# 不管是不是 eBPF，边车是服务网的未来

> 原文：<https://thenewstack.io/ebpf-or-not-sidecars-are-the-future-of-the-service-mesh/>

[](https://www.linkedin.com/in/wmorgan/)

 [威廉·摩根

威廉是 bound 的联合创始人兼首席执行官，开源服务网格项目 Linkerd 的创始人。在 Ruby 之前，他是 Twitter 的基础设施工程师，在那里他帮助 Twitter 从一个失败的单片 Ruby on Rails 应用程序转移到一个高度分布式的容错微服务架构。他是 Powerset、微软和 Adap.tv 的软件工程师，MITRE 的研究科学家，拥有斯坦福大学计算机科学硕士学位。](https://www.linkedin.com/in/wmorgan/) [](https://www.linkedin.com/in/wmorgan/)

eBPF 是 Kubernetes 世界的一个热门话题，用它来构建一个“无边车服务网”的想法最近引起了热议。这个想法的支持者声称 eBPF 让他们[通过移除边站来降低服务网格的复杂性](https://thenewstack.io/how-ebpf-streamlines-the-service-mesh/)。没有说的是，这种模式只是用每主机多租户代理取代了边柜代理，这在安全性和可操作性方面都是一个巨大的退步，增加了而不是降低了复杂性。

边车模型代表了行业的巨大进步。Sidecars 允许在运行时将功能动态注入到应用程序中，同时——重要的是——保留了容器实现的所有隔离保证。从 sidecars 回到多租户，共享代理失去了这种关键的隔离，导致安全性和可操作性的显著倒退。

事实上，服务网格市场已经亲眼目睹了这一点:第一个服务网格，Linkerd 1.0 大约在 2017 年使用相同的每主机代理模型提供了一个“无侧柜”服务网格，由此带来的运营、管理和安全挑战直接导致了基于侧柜的 [Linkerd 2.0](https://linkerd.io/2018/09/18/announcing-linkerd-2-0/) 。

eBPF 和 sidecars 不是一个非此即彼的选择，断言 eBPF 需要取代 sidecars 是一个营销构想，而不是一个实际的要求。eBPF 在服务网络中有未来，但它将作为 eBPF *和*的边车，而不是 eBPF *或*的边车。

## 简单地说 eBPF

要理解为什么我们首先需要理解 eBPF。 [eBPF](https://ebpf.io/) 是一个强大的 Linux 内核特性，允许应用程序直接在内核中动态加载和执行代码。这可以提供实质性的性能提升:我们可以在内核内部进行处理，而不是在内核和应用程序空间之间不断移动数据进行处理。这种性能上的提升意味着 eBPF 打开了一整类以前不可行的应用程序，尤其是在网络可观测性这样的领域。

但是 eBPF 不是灵丹妙药。eBPF 程序非常有限，而且理由很充分:在内核中运行代码是危险的。为了防止不良行为者，内核必须对 eBPF 代码施加重要的约束，尤其是“验证器”。在 eBPF 程序被允许执行之前，验证者对程序执行一系列严格的静态分析检查。

自动验证任意代码是困难的，错误的后果是不对称的:拒绝一个完全安全的程序可能会让开发人员感到烦恼，但允许一个不安全的程序运行将是一个主要的内核安全漏洞。正因为如此，eBPF 项目受到了很大的限制。它们不能阻塞，不能有无限循环，甚至不能超过预先定义的大小。验证者必须评估所有可能的执行路径，这意味着 eBPF 程序的整体复杂性是有限的。

因此，eBPF 只适合某些类型的工作。例如，需要有限状态的功能，例如“计算与 IP 地址和端口匹配的网络数据包的数量”，在 eBPF 中实现起来相对简单。需要以非平凡的方式积累状态的程序，例如，“解析这个 HTTP/2 流并根据用户提供的配置进行正则表达式匹配”，或者甚至“协商这个 TLS 握手”，要么完全不可能实现，要么需要 Rube Goldberg 级别的扭曲来利用 eBPF。

## eBPF 和服务网格

现在让我们转向服务网格。我们能用 eBPF 替换我们的边车吗？

正如我们所料，鉴于 eBPF 的局限性，答案是否定的——服务网格所做的远远超出了纯 eBPF 的能力。服务网格处理现代云本地网络的所有复杂性。比如 linkerd[发起和终止相互 TLS](https://buoyant.io/mtls-guide/)；出现暂时失败时重试请求；透明地将连接从 HTTP/1.x 升级到 HTTP/2；基于加密工作负载身份实施授权策略；还有更多。

> eBPF 和 sidecars 不是一个非此即彼的选择，断言 eBPF 需要取代 sidecars 是一个营销构想，而不是一个实际的要求。

像大多数服务网格一样，Linkerd 通过在每个应用程序容器中插入一个代理来实现这一点——众所周知的 sidecar。在 Linkerd 的情况下，这是用 Rust 编写的超轻 Linkerd2-proxy“微代理”，旨在消耗尽可能少的系统资源。该代理拦截并增强所有进出 pod 的 TCP 通信，并最终负责实现服务网格的全部功能集。

这个代理中的一些功能可以通过 eBPF 来实现。例如，有时 sidecar 的工作只是代理一个到目的地的 TCP 连接，而没有 L7 分析或逻辑。这可以使用 eBPF 卸载到内核。但是 sidecar 所做的大部分工作需要有效的状态，在 eBPF 中实现是不可能的，甚至是不可行的。

因此，即使使用 eBPF，服务网格仍然需要用户空间代理。

## 边车的箱子

如果我们正在设计一个服务网格，在哪里放置代理取决于我们自己。从体系结构的角度来看，我们可以将它们放在边车级别、主机级别，甚至是集群级别，甚至是其他地方。但是从操作和安全的角度来看，真的只有一个答案:与任何替代方案相比，边车为安全性、可维护性和可操作性提供了实质性和具体的好处。

sidecar 代理处理单个应用程序实例的所有流量。实际上，它是应用程序的一部分。这带来了一些显著的优势:

*   Sidecar 代理资源消耗与应用程序的流量负载成比例，因此 Kubernetes 资源限制和请求是直接适用的。
*   边车故障的“爆炸半径”仅限于 pod，因此 Kubernetes 的 pod 生命周期控制可以直接应用。
*   升级 sidecar 代理的方式与升级应用程序代码的方式相同，例如通过滚动部署。
*   sidecar 代理的安全边界被清晰地划分并严格地限定了范围:sidecar 代理仅包含属于该 pod 的机密材料，并充当 pod 的执行点。这是粒度执行是网络安全零信任方法的核心。

相比之下，每台主机的代理(和其他形式的多租户，例如集群范围的代理)处理主机上调度的任意一组 pods Kubernetes 的流量。这意味着边车的所有操作和安全优势都丧失了:

*   每台主机的代理资源消耗是不可预测的。这是 Kubernetes 动态调度决策的一个功能，意味着资源限制和请求不再有用——您无法提前知道代理需要多少系统。
*   每台主机的代理必须确保公平性和 QoS，否则应用程序会面临饥饿的风险。这是一个重要的需求，没有流行的代理被设计来处理这种形式的“竞争多承租”。
*   每台主机代理的爆炸半径很大，并且不断变化。每主机代理中的故障将影响主机上调度的来自任意应用程序的任意 pod 集。类似地，升级每台主机的代理将对任意应用程序产生任意程度的影响，这取决于机器上调度了哪些 pods。
*   安全故事是…混乱的。每台主机的代理必须包含该主机上调度的所有 pod 的密钥材料，并且必须代表该主机上调度的所有应用程序执行强制实施。这将代理变成了一个新的攻击媒介，容易受到[困惑的代理问题](https://en.wikipedia.org/wiki/Confused_deputy_problem)的攻击，并且代理中的任何 CVE 或缺陷现在都具有显著更大的安全影响。

简而言之，sidecar 代理建立在通过容器获得的隔离保证之上，允许 Kubernetes 和内核加强安全性和公平性。每台主机的代理完全超出了这些保证，给操作、安全性和维护带来了极大的复杂性。

## 那么，我们该何去何从呢？

eBPF 对网络来说是一个巨大的进步，它可以通过将服务网格中的一些工作转移到内核来优化 T2。但是 eBPF 总是需要用户空间代理。鉴于此，正确的方法是结合 eBPF 和边车，而不是避免边车。

用 eBPF 提出一个无边车的服务网是把营销车放在工程马之前。当然，“用 eBPF 逐步改进边车”并不像“再见边车”那样轰动，但是从用户的角度来看，这是一个正确的决定。

边车模式是该行业的一大进步。这并非没有挑战，但这是迄今为止我们处理云原生网络的全部范围，同时保持最初通过采用容器实现的隔离保证的最佳方法。eBPF 可以增强这个模型，但不能取代它。

<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 68 31" version="1.1"><title>Group</title> <desc>Created with Sketch.</desc></svg>