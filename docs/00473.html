<html>
<head>
<title>How Microsoft Forged a Scalable Git to Better Manage Windows Development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微软如何打造可扩展的Git来更好地管理Windows开发</h1>
<blockquote>原文：<a href="https://thenewstack.io/microsoft-forged-scalable-git/#0001-01-01">https://thenewstack.io/microsoft-forged-scalable-git/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">


<p class="translated">由于对BitKeeper的局限性感到失望，<a href="https://github.com/torvalds" class="ext-link" rel="external "> Linus Torvalds </a>在十年前的一个周末从零开始创建了<a href="https://git-scm.com/" class="ext-link" rel="external "> Git </a>分布式源代码控制软件<a href="https://www.linuxfoundation.org/blog/10-years-of-git-an-interview-with-git-creator-linus-torvalds/" class="ext-link" rel="external ">，作为管理Linux内核正在进行的开发的更好的方式，多年来已经有数千名开发人员</a><a href="https://thenewstack.io/contributes-linux-kernel/" class="local-link">添加到它的代码库</a>。</p>
<p class="translated">感受到自己版本控制工作的局限性，微软采用git来管理自己可观的软件产品组合。但是，尽管Git承诺简化Windows上的多开发人员工作，这个雷德蒙巨人也发现该软件难以扩展。超过300GB的源代码分布在500万个文件中，Windows对于Git来说太大了。获得一个简单的git状态需要18分钟；Git提交可能需要半个小时。</p>
<p class="translated">因此，该公司开发了<a href="https://github.com/Microsoft/GVFS" class="ext-link" rel="external "> Git虚拟文件系统</a>作为虚拟化层来加速操作。在今年的Microsoft Connect()大会上，该公司宣布与最大的基于git的托管服务GitHub合作开发GVFS。</p>
<p class="translated">在会议上，我们与微软公司副总裁Brian Harry进行了交谈，Brian Harry负责监管公司的发布管理服务，Azure上提供的<a href="https://www.visualstudio.com/team-services/" class="ext-link" rel="external ">Visual Studio Team Services</a>(VSTS)(也称为<a href="https://www.visualstudio.com/tfs/" class="ext-link" rel="external ">Team Foundation Server</a>(TFS)，对于那些希望在内部部署此类功能的人来说)，以了解更多关于GVFS、VSTS和TFS的最新发布以及正在采用的应用程序部署和管理的<a href="/category/devops/" target="_blank">devo PS</a>方法。</p>

<p/>
<p class="translated"><strong>就采用DevOps而言，您在微软商店看到了什么？</strong></p>
<p class="translated">我认为我们在微软社区看到的和我们在所有开发人员社区看到的一样，都非常关注更加敏捷和更加快速的响应。早在21世纪初，关注的焦点是敏捷运动的开始，持续的集成和单元测试以及诸如此类的实践。然后它发展到SCRUM，然后是看板和项目管理方面。现在的重点是实现部署流程的自动化。我如何消除将所有代码投入生产的摩擦，以便我可以更频繁地更新，更频繁地打补丁，更频繁地响应反馈？我接触的每一位顾客，都想谈论这个话题。</p>
<p class="translated"><strong>这是由竞争需求驱动的，还是it的自然发展</strong>？</p>
<p class="translated">我认为两者都有。其中一些是由客户期望驱动的。顾客只希望东西是新鲜的、新的、不断更新的。其中一些是由竞争驱动的。如果我处于六个月的部署周期，而另一个人处于两周的部署周期，我将会失败，因为他将会更快地做出响应。</p>
<p class="translated">听着，你总是会犯错。你总是会错过一些东西，得到一些不对的东西。迭代次数越多，就越有机会做对。</p>
<p class="translated">在过去，it和开发之间的关系非常疏远，开发人员开发一些东西，然后交给IT部门。配置部署所需的硬件需要三个月的时间，然后他们必须对部署进行一系列测试和验证。在某个时候，它会被部署。与此同时，开发人员花了几个月做其他事情，甚至不记得他们在那个版本中放了什么。</p>
<p class="translated">这种不连续性产生了巨大的摩擦。因此，最大的转变之一是消除移交。这可能是一件可怕的事情。这确实意味着你的责任改变了。我的意思是，如果我看看我的组织:几年前，它就像我描述的那样工作。现在，运营与配置基础架构没有任何关系，因为一切都在云中，而云就是这样做的。行动中心和部署已经没有任何关系了。都是自动化的。它只是来自执行部署的工程团队的脚本。这是不是意味着ops没有工作了？不。行动组还有很多事要做。对我们来说，他们进行容量规划，他们仍然深入参与事件管理和安全。在当今的威胁世界中，保护这些系统至关重要，并且比过去更加复杂。</p>
<p class="translated">所以你只需要重新分配职责，这样就不会有交接。</p>
<p class="translated"><strong>所以系统管理员的角色发生了很大的变化。好的，请问Visual Studio Team Services和Team Foundation server给开发环境带来了什么</strong>？</p>
<p class="translated">当然可以。首先，Team Foundation Server和Visual Studio Team Services有两个不同的名称，这很奇怪，但它们基本上是一回事。Team Foundation Server位于内部，Visual Studio Team Services位于云中。它们都提供了一套丰富的DevOps服务，从允许你做信号量和冲刺的规划，到你托管git repos的源代码控制等等。我们拥有一个名为<a href="https://www.visualstudio.com/team-services/tfvc/" class="ext-link" rel="external "> Team Foundation版本控制</a>的集中式版本控制系统。我们拥有持续集成和构建管道的能力。我们拥有跨环境管理各种分阶段发布和管理部署的发布能力。我们有测试能力。我们有软件包管理来管理您的所有二进制资产。</p>
<p class="translated">这些工具几乎涉及到您的DevOps生命周期的方方面面。同时，它们是可组合的。所以在几年前，对TFS的一个批评是，它是一个整体，你必须使用它。在过去的几年里，情况发生了很大的变化。你不需要。如果你想在GitHub中拥有你的代码，并且你想使用我们的CI/CD系统，很好。它与GitHub配合得非常好。如果你想用GitHub做源代码，用Jenkins做你的构建，然后你想用我们的持续部署系统来管理部署，很好。我们的CD系统和Jenkins配合得很好。</p>
<p class="translated">我们还支持所有这些东西的可追溯性，所以我们与它们深度集成，实际上我们更关注于使系统成为一组可组合的部分，允许您将它与您最喜欢的工具一起使用。</p>
<p class="translated"><strong>微软在今天的大会上宣布了这项服务的一些更新。一个是释放门。能解释一下它们是什么</strong>吗？</p>
<p class="translated">没错。所以先说问题。因此，在任何DevOps过程中，当您向大量客户发布时，您必须非常小心。首先，你要认识到你会运送bug。我不管你用什么测试流程，你都会出货bug。所以问题就变成了，“你打算怎么处理你运送的虫子？”你会将这种新代码部署到所有100万用户中，然后有30万人遇到这种错误，然后你会得到30万个不满意的客户吗？还是将它部署到1，000个客户，让1，000个客户遇到错误，然后修复它，然后部署到下一个1，000个客户，然后逐步推广，这样您就有一种可控的方式来管理和控制您面临的风险？</p>
<p class="translated">因此，我们将这种逐步累积过程的概念正式化为我们内部使用的环。我们有环0、环1、环2、环3和环4。环0只是微软。因此，当我们部署环0时，除了我们自己，我们不会影响任何人。一旦我们在那里感到满意，我们就转到环1，从那里继续下去。</p>
<p class="translated">每响一次，我们要等24小时。我们展开一个环，我们等待24小时，我们观察健康监视器，我们寻找任何可能出问题的迹象。如果有问题，我们停下来解决，然后继续推出。它以这种方式穿过所有五个环。</p>
<p class="translated">释放门是这一过程的正式形式。在我们的发布管理系统中，我们已经有能力找到这些东西流动的环境。发布门允许你做的是自动化准备检查。因此，我可以为一个环境定义发布门，它测量一些KPI，看着一些东西并说，“这个发布，这个环境不被认为是健康的，除非以下是真的。”</p>
<p class="translated">因此，您可以在这个环境中配置流程等待六个小时。在这六个小时中，您可以设置五个指标进行监控。如果在这六个小时结束时，如果所有五个指标都是绿色的，那么它将进入下一个版本。</p>
<p class="translated">我们引入了两种释放门。一个是Azure monitoring release gate，你可以连接它来观看任何Azure警报。你设置了一个门槛，上面写着，“超过这个量就被认为是不健康的。”</p>
<p class="translated">然后你可以做的第二件事是让它监视或处理你的查询。我们利用这一点。假设客户在我们的24小时窗口内报告了一个问题。我们接到一个电话，或者收到一封电子邮件，或者从我们的开发者社区网站上得到一个bug文件。如果这是一个严重的错误，它将被归类为发布阻塞错误。因此，我们的发布网关将监视该查询，如果在我们的24小时结束时，如果有任何发布阻塞错误仍然活跃，它将保留该发布。</p>
<p class="translated">这就是你对它的看法。现在我们还有另外三个发布入口，它们是可扩展性点。你可以调用一个Azure函数。你可以在任何地方调用任何REST API，或者你可以在服务总线上发布一条消息，然后这些允许你创建你想要的任何释放门。我用过的一个例子是，我让我的团队编写一个样本，我们将开放源代码，让每个人都知道如何监控Twitter情绪，因为这是我们关注的事情之一。今天我们手动观看。我们正在关注Twitter，如果我们看到Twitter因人们有问题而亮起红灯，我们将阻止发布。但最好在发布上有一个指标，上面写着，“哦，既然你发布了这个，既然你部署了这个，就像你的Twitter人气显著下降了一样，让我们去看看，看看这是否真的代表了一个问题。”</p>
<p class="translated">这就是释放门的基本意义。它在这个逐步展开的过程中自动检查准备情况。</p>
<p class="translated"><strong>什么是Git虚拟文件系统？这是什么？为什么会这样？怎么会被GitHub </strong>使用？</p>
<p class="translated">大约三年前，我们在研究我们的工程系统。作为其中的一部分，我们正在研究版本控制。我们内部有一堆不同的版本控制系统。经过一番讨论后，我们决定将整个公司迁移到git。那是我们想去的地方。但与此同时，看看Git的现实，这将是不可能的。我们有一些非常大的代码库。典型的是Windows代码库，它现在在Git中，是一个300GB的repo，这在Git中是不可想象的。它太大了。你要记住，Git克隆了你的机器上的整个回购，谁想要300GB下载到你的机器上。</p>
<p class="translated">所以我们知道，要执行迁移到Git的战略决策，我们真的必须加入Git社区，并开始帮助Git朝着可伸缩的方向发展。所以我们开始了这个项目，GVFS就是从这个项目中诞生的。基本上是一个东西的组合。其中一部分是性能调优，让Git对每个人都更好。</p>
<p class="translated">具体来说，GVFS是我们添加到Git中的虚拟化层，例如，它使您能够克隆sit repo，这样您就不会得到所有东西。你只能得到一些做基本操作所必需的元数据。当你触摸文件时，它会返回并下载你需要的文件。Windows是550万个文件。如果我只处理其中的10，000个文件，我只能得到这10，000个文件。</p>
<p class="translated">另一个维度是深度。如果我只使用这10，000个文件的当前版本，我只能得到这10，000个文件的当前版本。如果我需要返回并访问六个月前的版本，那么当我需要这样做时，我会返回到git服务器，下载我需要的历史记录，现在它会在本地缓存，因此后续访问非常快，但它们只会在我需要时获得我需要的部分。从表演的角度来看，这很有戏剧性。区别是白天和黑夜。</p>
<p class="translated">我的意思是，当我们第一次开始时，如果我试图克隆Windows repo，实际上从未成功过。它只是会超时。这没用。Git status告诉您更改了哪些文件，它通常是一个即时操作。当我们第一次开始使用Windows repo时，对Git状态的操作大约需要18分钟。Git提交大约需要30分钟。</p>
<p class="translated">有了GVFS和我们所做的所有性能调优工作，git clone大约需要Windows repo的一分半钟。Git状态大约是两秒半。Git提交大约需要五六秒。互动行为的合理数字。</p>
<p class="translated">所以我们发布了这个。GVFS是一个开源项目。任何人都可以接触到它。我们公布了协议。以便任何Git服务都可以实现它。我们本周宣布将与GitHub合作，继续推进这项工作。GitHub非常明确地投资于Git和Git的未来。它希望将GVFS支持添加到GitHub中，并与我们合作继续推进Git，帮助我们加快获得Mac和Linux客户端的工作。我们做了一个Windows客户端。我们正在开发Mac客户端。我们还没有启动我们的Linux客户端，尽管它已经在路线图中了。我们正计划这么做。GitHub将与我们合作，帮助我们更快地完成这项工作。因此，我们将作为开源项目中的同行一起工作，推动它向前发展。</p>
<p class="translated">在今年的Connect中，我们还应该记住什么？</p>
<p class="translated">我们还宣布了<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ee416588(v=vs.85).aspx" class="ext-link" rel="external ">符号服务器</a>对Visual Studio团队服务的支持。开发人员面临的一个问题是，他们开发了一个应用程序，然后把它交给某个人，这个应用程序就会崩溃或者无法在你的机器上运行。它在我的机器上工作。所以我需要去你机器调试，但是你没有源码。</p>
<p class="translated">因此，Symbol Server为您提供了一种能力，让我可以进入您的计算机，将调试器附加到您正在运行的进程，检查进程，查看dll的版本，进入VSTS，找到与之相关的符号，下载它们，找到与这些符号相关的代码，下载您要调试的文件。我在您的机器上获得了丰富的源代码调试体验，即使您的机器上没有任何代码。所以这很酷。我们现在有符号服务器内置在VSTS的一部分。我们还将把它包括在TFS。它不在2018年TFS奥运会上，因为它刚刚上了云，它将进入TFS的未来更新。</p>
<p class="attribution translated"><a href="https://azure.microsoft.com/en-us/?v=17.14" class="ext-link" rel="external ">微软</a>是新堆栈的赞助商。</p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
<title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>

</div>
</div>    
</body>
</html>