# 为什么你的代码需要抽象层

> 原文：<https://thenewstack.io/why-your-code-needs-abstraction-layers/>

抽象是编写设计良好的软件的最重要的方面之一。

理解底层的概念将会给你一个可遵循的系统和一个关于如何创建好的抽象的清晰的心智模型。

好的抽象降低了复杂性，并允许开发人员更容易、更少错误地修改代码。但是创建抽象并不容易。那么，您具体是如何做到这一点的，需要采取哪些步骤呢？

## **什么是抽象？**

 [耶尔·科恩

Yair 是 Coralogix 的全栈开发人员，coral ogix 是日志、指标和安全数据的实时洞察和趋势分析领域的领导者。他有几年从头到尾设计和构建应用程序的经验，擅长创建复杂的用户界面。](https://www.linkedin.com/in/yair-cohen-dev/?originalSubdomain=il) 

在谈论代码中的抽象层之前，让我们先简单地谈论一下 [抽象](https://en.wikipedia.org/wiki/Abstraction) 以及它们是什么。

抽象可以定义为通过以下方式简化实体的过程:

1.  省略不重要的细节。
2.  公开接口。

在这方面，所有的抽象都是相似的。

自动汽车是一个很好的抽象现实世界的例子。在这种情况下，离合器被抽象出来，驾驶员可以更容易地换档。

抽象也有权衡。例如，尽管驾驶员可以更容易地换档，但驾驶员现在对汽车的控制也更少了，所以对赛车手来说，抽象离合器可能是一个坏主意。

在《 [软件设计哲学](https://www.amazon.com/Philosophy-Software-Design-John-Ousterhout/dp/1732102201) 》一书中，作者 John Ousterhout 谈到了抽象可能出错的两种方式:

1.  **包含不重要的细节**:通过包含不重要的细节，抽象变得比必要的更复杂，并且增加了开发人员的认知负荷。
2.  **省略重要细节**:outer hout 称这些类型的抽象为“错误的抽象”，因为开发人员在查看抽象时不会得到他们需要的所有信息。

所以，你可以看到一个好的抽象需要走一条好的路线。

## **代码中的抽象**

现在我们知道了什么是抽象，但是它如何应用于代码呢？

所有代码都可以分为策略类或细节类。

*   策略:这些是实体和业务逻辑。
*   细节:这是政策的执行。细节执行政策。

假设你有一个`User`实体。用户有一定的界面，也有一些业务逻辑。这个`User`实体也有组，您被分配编写代码来获取所有的用户组。

在这里，策略是用户本身，因为它是一个实体，但它也是`getuser groups函数，因为它是与该实体相关的业务逻辑。`

 `它是如何实现的，使用了哪个数据库(DB)，使用了哪个 ORM(对象关系映射),使用了哪些库，代码是如何编写的，所有不同的实现都是代码的细节部分。

> 创建抽象层有助于通过提供三个主要好处来极大地改进您的代码:集中化、简单性和更好的测试。

在您的代码中，您希望公开策略，同时隐藏细节。策略和细节之间的这种解耦允许您切换和轻松重构实现。

如果您的策略和细节是耦合的，那么您将很难进行重构，因为它们将被混合，并且更改将从一个传播到另一个。

在一个设计良好的系统中，政策和细节的分离是关键。

那么这如何应用于抽象层呢？

## **抽象层**

抽象层公开了一个接口，并隐藏了接口背后的实现细节。

抽象层的目的是创建抽象。层中的方法和属性应该是公开的接口，而这些方法中的实现是细节层中的一切。

创建抽象层有三大好处:

1.**集中化**:通过在一个层中创建您的抽象，与之相关的一切都被集中化，因此任何更改都可以在一个地方进行。集权与“不重复自己”( [干](https://en.wikipedia.org/wiki/Don't_repeat_yourself) )原则有关，很容易被误解。

DRY 不仅是关于代码的复制，也是关于知识的复制。有时，两个不同的实体有相同的代码副本是没问题的，因为这实现了隔离，并允许这些实体单独的未来发展。

2.**简单性**:通过创建抽象层，您暴露了特定的功能，隐藏了实现细节。现在代码可以直接与你的接口交互，避免处理无关的实现细节。这提高了代码的可读性，减少了开发人员阅读代码的认知负担。为什么？

因为政策没有它的细节复杂，所以与它的互动更简单。

3.**测试**:抽象层非常适合测试，因为您可以用另一组细节替换细节，这有助于隔离正在测试的区域，并正确地创建 [测试替身](https://en.wikipedia.org/wiki/Test_double) 。

测试代码时，开发人员需要测试特定的功能，同时为某些功能创建测试替身，以避免调用真正的数据库之类的事情。当政策和细节纠缠在一起时，过度使用测试替身是很常见的，这会降低覆盖率，降低测试的有用性。

在为 DB 实现之类的东西创建抽象层时，开发人员可以替换该层，确保只替换 DB 响应，而测试其余的功能。

## **创建抽象层的例子**

假设您正在为组创建 API 编写代码:

```
function createUserGroup(group,  userId)  {
            logger.info('Creating group for user ${userId}')
            db.startTransaction();
            const isValidGroup  =  validateGroup(group);
            if  (!isValidGroup)  throw new Error('Invalid group');
            db.addDoc('groups',  group)
            dc.addDoc('quotas/groups',  1)
            .
            .
            .
      }

```

正如您在简短的示例中所看到的，这个功能逻辑混合了策略和细节。它做许多不同的事情，并且不使用任何抽象层。

下面是使用抽象层的代码:

```
class  GroupsService  {
      GROUPS_COLLECTION  =  'groups';

      createGroup()  {
            db.startTransaction();

            const isValid  =  this.validateGroup();
            if  (!isValid)  throw new Error('Invalid group')

            db.addDoc(GROUPS_COLLECTION,  group)
            quotasService.setQuota('/groups',  1);

            db.finishTransaction();
      }

      validateGroup()

      deleteGroup();
}

class  QuotasService  {
      setQuota(collection:  string,  value:  any)  {
            dc.addDoc(`quotas/${collection}`,  value)
      }
}

function createUserGroup(group,  userId)  {
      logger.info(`Creating  group  for  user  ${userId}`)
      groupsService.createGroup();

      return  {
            status:  200,
            message:  'Group created successfully'
      }
}

```

第二种实现有多种好处:

1.  这更容易理解，因为实现细节是抽象的，并且您正在阅读与策略交互的代码。
2.  一切都集中在一个服务中。想象一下应用程序中与群组相关的代码。每一个改变都需要在任何地方发生；至少可以说，这是有问题的。
3.  代码封装性更强。请注意，控制器`createUserGroup`现在不知道配额，只知道组创建，因为配额是不相关的。
4.  我们可以专注于测试实现，同时用测试替身替换细节层，使测试更容易。对于集成测试，我们可以替换`QuotaService`和 `GroupService` ，并测试特定控制器实现的实现。

## **可能的应用**

抽象层可以用许多不同的方式实现，其中最常见的用例有:

1.**通过分离策略和细节创建更精简的组件**:如果修改和重构很容易，你的代码将通过时间的考验。分离策略和细节，同时保持组件之间的交互只通过接口进行，这为未来的代码发展提供了基础设施。

2.**包装第三方库**:在你的代码中有一个过时的第三方库，阻止你升级其他依赖项，这是一场噩梦。或者更糟的是，如果依赖关系有安全风险。

通过将第三方库与自己的接口包装在一个中央抽象层中，更改将会很容易，因为只需要在暴露接口的地方进行更改。

3.**创建实用服务**:实用服务是提高开发速度和重用通用代码的重要方式。

例如，如果您正在开发一个处理大量不同时间和日期功能的特性，为什么不创建几个实用函数来帮助您，并将它们放在一个地方供进一步重用呢？

## **总结**

创建抽象层有助于通过提供三个主要好处来极大地改进您的代码:集中化、简单性和更好的测试。

请记住，抽象层和抽象通常不是目的，而是达到目的的手段。抽象也有缺点。一个常见的例子是某些抽象如何损害性能。所以首先要理解权衡。

<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 68 31" version="1.1"><title>Group</title> <desc>Created with Sketch.</desc></svg>`