<html>
<head>
<title>IBM OpenStack Engineer Urges Augmenting Jenkins with Zuul for Hyperscale Projects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">IBM OpenStack工程师呼吁为Jenkins增加Zuul以支持超大规模项目</h1>
<blockquote>原文：<a href="https://thenewstack.io/ibm-openstack-engineer-urges-cncf-consider-augmenting-jenkins-zuul/#0001-01-01">https://thenewstack.io/ibm-openstack-engineer-urges-cncf-consider-augmenting-jenkins-zuul/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">


<p class="translated">当您管理一个超大规模的项目，该项目有几十个国家的成千上万的贡献者，并且有许多活跃的、独立开发的组件，您如何期望可靠地完成将项目的发展作为单个流来管理的壮举？当然，你可能会问自己，除了OpenStack本身，有多少现实世界的项目符合这种描述？然而，你可能还记得不太久以前，Kubernetes被描述为超大规模架构的产品。或许今天早上的超大规模上涨注定会成为今晚的主流商品。</p>
<p class="translated">在云原生计算基金会(Cloud Native Computing Foundation)周三上午的定期技术监督委员会会议上，IBM的云架构师(2015年9月之前在HPE工作)和OpenStack的贡献者Clint Byrum应邀介绍了他的案例，说明CNCF如何使用自动<em>看门人</em>系统来改善其持续集成流程。</p>
<p class="translated">这样的系统将阻止CI管道被打开，以及合并过程的发生，直到特定的条件被满足。但是，当闸门关闭时，它实际上可以使一些测试操作提前进行，同时在闸门打开之前阻止这些测试产生的任何合并。</p>
<h2 class="translated">我们在市区是怎么做事的</h2>
<p class="translated">Byrum声称这个系统改善了OpenStack提交对其许多上游组件的更改的方式，并且自2012年以来一直在悄悄地这样做(鉴于其名称，这是一个惊喜)。它被称为<a href="https://github.com/Netflix/zuul" class="ext-link" rel="external "> Zuul </a>，一个以“看门人”食尸鬼命名的项目，该食尸鬼占用了原版《捉鬼敢死队》中西格妮·韦弗的身体(在这一行，乐趣就是你创造它的地方。)</p>
<p class="translated">“我们希望测试集成在一起的组件，”Byrum告诉与会者。“因此，如果它本身不是一个完全的孤岛——大多数东西都不是，我们希望确保它们实际上能够协同工作，而不仅仅是它们的API按照它们预期的方式工作——我们会在OpenStack的每个主要项目的每个提交中进行全面的集成测试，在那里它们被集成在一起<em>预合并</em>。除非代码通过这些测试，否则我们不会让代码落地。”</p>
<p class="translated">Zuul在OpenStack中的作用是提供一个名为<em>trunk gate</em>的服务(不要和tailing混淆)。该系统每次都让新代码提交通过相同的步骤，首先在虚拟环境中进行本地测试，然后提交给OpenStack的Gerrit库进行审查，并通过一系列自动化补丁进行更新。一旦代码到达验收阶段，它就要接受另一组预合并检查。并且一旦合并，它仍然服从合并后的分析。</p>
<p class="translated">这是一种由詹金斯管道组成的上层建筑。正如Byrum向CNCF承认的那样，这不是一件容易的事。</p>
<h2 class="translated">超大规模对冲</h2>
<p class="translated">“詹金斯建筑有一个致命的缺陷，那就是我们想要大门。但是为了进入Jenkins，除了提交大量的合并提交或<a href="https://medium.com/@bebraw/the-case-for-monorepos-907c1361708a#.rir3h6xvz" class="ext-link" rel="external "> monorepo </a>之外，它没有任何优化的方法，”Byrum说，他指的是在单个存储库中容纳多个版本的相关代码组件的替代方法。他指出，他的团队确实研究了这种替代方案，但最终拒绝承担它的负担。</p>
<p class="translated">他认为，维护独立的存储库使他的团队更容易设计主干门控系统。在他们的特殊情况下，他们创造了一个独特的确定系统，使科幻小说显得过时:<em>投机未来合并测试</em>。</p>
<p class="translated">Byrum将Zuul测试引擎背后的算法的创建归功于OpenStack核心贡献者James E. Blair，反过来，Blair在2013年将Zuul测试引擎的灵感归功于CPU使用的推测性多线程技术。这个概念大约在1998年取得了成果，被发明出来作为处理器加速并行处理的一种手段，特别是在多个线程共享相同数据的情况下。</p>
<p class="translated">这是字面上的跳跃前进的原则。当一个内核有机会时，它会执行一个线程尾部的指令。对于Blair引用的版本，如果那些推测性指令打算对主存储器进行改变，那么该存储器的内容首先被镜像到高速缓存中，所以推测性改变可以在那里进行。如果线程过早地结束执行(如果推测是错误的)，则高速缓存内容被擦除，并且先前的线程状态被恢复。这导致了几个周期的损失，但是累积起来，总损失应该小于CPU在试图以完美的顺序执行每个线程时遇到的瓶颈。</p>
<p class="translated">Blair借用了这个想法，作为一种允许Gerrit为每个组件触发合并测试的方式，甚至在我们知道它实际上是必要的时候，在管道中的点之前。在持续集成中，必须按顺序测试多个组件，这些测试的层次结构是由这些组件之间的依赖关系决定的。通过所有测试的组件可以与生产流合并。</p>
<p class="translated">但是当一个预期变更的测试失败时，Zuul的调度器通过从测试序列中移除该变更来做出响应——同时保持该变更在合并队列中的位置。它不会改变队列；它仅仅依靠看门人来确保未测试的变更不会被合并。随后，依赖于失败变更的序列中较早的测试被重新启动。</p>
<p class="translated">自始至终，看门人维护一个内部指针，称为最近的非故障项目<em>(NNFI)。这成为测试序列的焦点。但它也为投机结果创造了一个起点，正如Byrum所描述的那样——这是Zuul向前跳跃并为新的拉动请求制定预期着陆订单的一种方式。</em></p>
<p class="translated">“本质上，[<em>Zuul</em>所做的是查看它被告知的所有事件，包括[<em>拉取请求</em>的批准，它说，‘我将建立一个未来，让它们按照这个顺序<em>着陆。如果它们没有相互依赖，如果它们不在同一个回购协议中，并且相互堆叠，那么它会确保它们可以合并在一起，并建立一个大而长的变更1管道，然后变更1 + 2，然后变更1 + 2 + 3，以此类推。然后，它使用弹性云并行测试每个组合。"</em></p>
<p class="translated">他告诉CNCF，结果是，对于大量同时聚合的拉请求——比如说25个——Zuul为合并顺序创造了一个窄至1的可能性窗口。使用NNFI，Zuul可以重新组织这个序列，并在序列中的任何合并提交导致问题时执行<em>门重置</em>。</p>
<p class="translated">Byrum说:“在最好的情况下，不管你备份和批准了多少工作，你只需要一个测试窗口。“在最坏的情况下，您可以让所有的补丁都知道它们都失败了，但是您没有得到坏代码。”</p>
<h2 class="translated">没有丹娜</h2>
<p class="translated">这些年来，OpenStack有几个优点，其中一个不是它发展的稳定和不懈的步伐。Byrum承认，其他开源社区项目已经试验了Zuul的2.x版本，效果不佳。本着同样谦逊的精神，他承认，Zuul到当前版本的发展已经偏离了它的主要路线，以满足OpenStack的特定和排他性需求——因此暴露了该平台的一些实现细节，也许是不必要的。</p>
<p class="translated">但他告诉《CNCF 》,对Zuul的“长期、大规模的重构”已经进行了多年，他希望最迟在6月份推出Zuul的3.x版本。这个新版本将包括一个更不可知论的定义语言，他建议CNCF推迟采用Zuul，直到基于该语言的API的可靠性得到保证。</p>
<p class="translated">然而，与此同时，他建议对网守试用感兴趣的开发人员试用bonny ci T1，他称之为“Zuul-as-a-Service”作为一个基于云的环境，BonnyCI可能还没有为CNCF托管的项目的规模做好准备——例如，他说，它在自己的云之外的依赖可能仅限于GitHub。然而，可以想象，它可以证明守门和投机的未来原则在起作用。</p>
<p class="translated">Zuul的可移植性的话题谈到了一个更广泛的问题，即算法是否可以在宏观上加速自动化，就像它们在微观上加速代码执行一样。我们可以把使用寄存器、提取、预取和缓存的基于云的软件开发过程想象成我们在一个巨大的CPU中生活和工作吗？文化方面似乎令人生畏，但富有成效的回报前景是不可否认的。(在那里，你认为我会用另一个《捉鬼敢死队》的参考来结束这篇文章，就像关于穿越溪流或其他东西的警告。)</p>
<p class="attribution translated">云计算原生计算基金会是新堆栈的赞助商。</p>
<p class="attribution translated">牛津大学马格达林学院外<a href="https://commons.wikimedia.org/wiki/File:Gargoyle_11.JPG" class="ext-image" rel="external ">守门人石像鬼的标题图片</a>，由Chris Creagh创作，经知识共享许可。</p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
<title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>

</div>
</div>    
</body>
</html>