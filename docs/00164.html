<html>
<head>
<title>Docker Swarm Wins Scaling Benchmark but Don't Take That as Gospel</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker Swarm赢得了扩展基准测试，但不要认为这是真理</h1>
<blockquote>原文：<a href="https://thenewstack.io/docker-swarm-wins-scaling-benchmark-dont-take-gospel/#0001-01-01">https://thenewstack.io/docker-swarm-wins-scaling-benchmark-dont-take-gospel/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">


<p class="translated">随着基于容器的orchestraton平台的出现，如何比较Docker Swarm和Kubernetes越来越成为一个问题。</p>
<p class="translated">有争议的是，这些框架有足够的不同，因此在某些情况下每个框架都会表现得更好。</p>
<p class="translated">因此，性能基准现在已经进入竞争日益激烈的容器编排市场也就不足为奇了，Docker赞助的一项研究发现，与Google Kubernetes相比，Docker Swarm似乎更擅长扩展到非常大的工作负载。</p>
<p class="translated">在Docker赞助的一项研究中，软件工程师<a href="http://allingeek.com" target="_blank" class="ext-link" rel="external "> Jeff Nickoloff </a>发现，与Kubernetes相比，Swarm的容器启动时间平均快五倍。</p>
<p class="translated">这项研究质疑了这样一种假设，即虽然Docker Swarm是小型编排工作负载的良好选择，但真正大规模的工作负载最好由Kubernetes或其他一些编排框架(如Mesos)来处理。认识到人们可能会发现Docker赞助的研究有偏见，Nickoloff公布了该研究的所有原始数据，鼓励进一步的检查。</p>
<p class="translated">Nickoloff开始从经验上回答Swarm和Kubernetes在真正的大型集群中表现如何的问题？这个问题与那些想要提供大规模的、响应迅速的、基于容器的服务的企业有关。</p>
<p class="translated">Nickoloff写道，迄今为止，还没有一项比较编排工具性能的大规模研究，至少没有任何测试进行了逐个功能的比较，并提供了足够的信息，可以轻松复制。</p>
<h2 class="translated">方法和结果</h2>
<p class="translated">Nickoloff在亚马逊网络服务的1000个节点的集群中测试了Kubernetes(v 1 . 2 . 0-α7)和Swarm (v1.1.3-rc2)。两个集群都依赖etcd (v2.2.1)作为键值数据库。每个节点将运行30个容器，总工作负载为30，000个容器。</p>
<p class="translated">该研究考察了当两个编排引擎各自的集群达到10%、50%、90%、99%和100%满时，它们启动一个新容器所需的时间。</p>
<p class="translated">虽然Swarm和Kubernetes在各自的集群利用率低于一半时表现良好，但在50%至90%之间，“Kubernetes超过了某个阈值，此时性能下降的速度比“10%至50%之间”要快，”Nickoloff指出。</p>
<p class="translated">Kubernetes在第50百分位的完成时间是6.45秒，而在第75百分位是28.93秒。相比之下，Swarm直到集群满90%时才开始受到影响。</p>
<p class="translated"><a href="https://medium.com/on-docker/evaluating-container-platforms-at-scale-5e7b44d93f2c#.pbxx2w5ai" class="ext-link" rel="external "><img decoding="async" loading="lazy" class="aligncenter wp-image-1110533 size-large" src="../Images/e96cf9249d8e4b8b6b021fd6e8773ec9.png" alt="Kubernetes-Swarm-50Percent" data-id="1110533" data-original-src="https://thenewstack.io/wp-content/uploads/2016/03/Kubernetes-Swarm-50Percent-1024x469.png"/>T2】</a></p>
<p class="translated">Nickoloff总结说，总体而言，在所有测试级别上，第99百分位的群体性能比Kubernetes的第10百分位性能快4到6倍。</p>
<p class="translated">“这些基准测试表明，在Swarm上测试的操作比Kubernetes更快，”Nickoloff总结道。“我们可以推断，差异的原因是根植于架构或算法选择。”</p>
<p class="translated">Nickoloff总结说，在这两个系统中，Kubernetes在架构上更复杂，因此需要更多的努力来支持。</p>
<h2 class="translated">讨论</h2>
<p class="translated">Kubernetes在架构上的不同是要记住的重要一点，Kubernetes的贡献者和谷歌福音传播者凯尔西·海塔尔在一系列推文中反驳道。他指出，Kubernetes更像是分布式系统的框架T4。</p>

<p class="translated">“Docker Swarm是否在几个孤立的基准测试中胜出？没错。你真的能比较这两个项目吗？现在答案是否定的，”海托华<a href="https://twitter.com/kelseyhightower/status/707657346714091520" target="_blank" class="ext-link" rel="external ">写道</a>。</p>
<p class="translated">Docker Inc .自然对这项研究的结果感到满意。</p>
<p class="translated">“将一个集群扩展到30，000个容器是一回事，能够有效地管理这种环境是完全不同的事情，”Docker高级技术营销工程师Mike Coleman在一篇博客文章中写道。“负载下的系统响应能力对于有效管理至关重要。在一个容器可能只能存在几分钟的世界里，在收集对环境状态的实时洞察方面有很大的延迟意味着您永远不会真正知道在任何特定时刻您的基础架构中正在发生什么。”</p>
<p class="translated"><a href="https://blog.docker.com/2016/03/swarmweek-docker-swarm-exceeds-kubernetes-scale/" rel="attachment wp-att-1110544 external " class="ext-link"> <img decoding="async" loading="lazy" class="aligncenter size-full wp-image-1110544" src="../Images/c557220efd781b7d86f081d9e33f94ae.png" alt="swarmfaster" data-id="1110544" data-original-src="https://thenewstack.io/wp-content/uploads/2016/03/swarmfaster.jpg"/> </a></p>
<p class="translated">“我们对论文中的一些结论并不感到惊讶，”DevOps工具供应商Codenvy的首席执行官泰勒·朱厄尔在一封电子邮件中写道。在评估了包括Kubernetes在内的许多不同的容器编排提供商后，Codenvy将Swarm嵌入到其Che <a href="https://thenewstack.io/eclipse-che-provides-portable-shared-development-workspaces-built-runtimes/" target="_blank" class="local-link">按需开发人员工作区软件</a>中。</p>
<p class="translated">朱厄尔解释说，在评估过程中，Codenvy考虑了三个基本标准:容器激活的延迟和速度，物理节点上的线性容器可扩展性，以及低配置占用空间。</p>
<p class="translated">他指出，Swarm在这三个方面都很出色。“我们可以在不到10分钟的时间内将自定义Codenvy安装到一个新帐户中，该帐户可以扩展到支持数千个节点或数十万个工作区容器。”</p>
<p class="translated">“很难想象Swarm和Kubernetes会直接竞争，”朱厄尔说。“Kubernetes的目的是在高度治理的环境中提供容器编排。这种治理控制必然会带来更多的复杂性，从而影响速度、设置和规模。Swarm没有相同的目标。”</p>
<p class="translated">“有许多因素需要考虑，但我们认为企业应该专注于性能、简单性和便携性，”Docker营销高级副总裁David Messina在后续的电子邮件中表示同意。“问他们自己这样的问题:我能多快让容器大规模运行起来？系统在负载下的响应速度如何？需要建立什么样的学习曲线，需要维持什么样的负担？我的应用程序会无缝地从开发到测试再到生产吗？我会被锁定在特定的数据中心或云环境中吗？”</p>
<p class="translated">New Stack分析师劳伦斯·赫克特(Lawrence Hecht)在一个内部Slack频道中写道:“我想了解更多关于更大的计划节省了多少时间。”“此外，我敢打赌，但我不知道，编排的技术决策主要不是由技术标准驱动的。”</p>
<p class="translated">Hecht正在领导一项针对新堆栈的研究，以了解正在使用哪些编排引擎以及它们是如何使用的(请随意<a href="https://thenewstack.io/container-orchestration-survey/" target="_blank" class="local-link">参与此处</a>)。</p>
<p class="translated">这项研究的发布无疑是及时的，因为周四非营利云原生计算基金会(<a href="https://cncf.io/" target="_blank" class="ext-link" rel="external "> CNCF </a>)已经<a href="http://lists.cncf.io/pipermail/cncf-toc/2016-March/000080.html" target="_blank" class="ext-link" rel="external ">正式接管了Kubernetes项目的</a>控制权，谷歌将软件的技术监督委员会(TOC)移交给了该基金会。</p>
<p class="translated">《书库》新任主编亚历克斯·威廉姆斯对此文有贡献。</p>
<p class="attribution translated">Docker是新堆栈的赞助商。</p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
<title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>

</div>
</div>    
</body>
</html>