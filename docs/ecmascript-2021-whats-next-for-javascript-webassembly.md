# ECMAScript 2021:JavaScript 的下一步是什么？

> 原文：<https://thenewstack.io/ecmascript-2021-whats-next-for-javascript-webassembly/>

ECMAScript 的下一次年度更新 JavaScript 语言的正式规范——将于今年 7 月发布，[增加了所有已经达到第 4 阶段](https://github.com/tc39/proposals/blob/master/finished-proposals.md)的建议特性。这意味着这些特性已经被所有的 ECMAScript 编辑器签署，至少在两个兼容的实现中发布，并且通过了验收测试。

今年对 JavaScript 的添加主要是为了让开发人员更愉快地使用该语言，提供了新的功能或更简单的方式来表达可以用其他方式完成的事情。但是有一个强大的新选项，这也是对语言的一个相当根本性的改变，它是专门为了支持 [WebAssembly](https://thenewstack.io/what-is-webassembly/) 而包含进来的。

新的堆栈邀请了 ECMAScript 标准化委员会的两位联合主席， [Rob Palmer](https://www.linkedin.com/in/robpalmer2) (彭博 JavaScript 基础设施和工具团队的负责人)和[Brian Terlson](https://www.linkedin.com/in/brian-terlson-6822aa61/)(Azure SDK TypeScript 和 JavaScript 的主要架构师，规范的前编辑)向我们介绍新功能的影响。

## 承诺。任何

向 JavaScript 等单线程环境添加异步编程支持(ECMAScript 2017 中的 [async/await 特性](https://thenewstack.io/async-officially-coming-javascript-year/)意味着开发人员可以从回调转移到承诺(代表已经发生的过程但其值在异步操作完成之前不会知道的对象)。ECMAScript 的后续版本已经逐渐增加了更多处理承诺的特性

有了 [Promise.any](https://github.com/tc39/proposal-promise-any) ，JavaScript 现在有四种方法来处理异步操作集，以处理承诺是如何实现的(通过履行或拒绝):

*   race 让你跟踪多个承诺，并在第一个承诺成功或失败时立即采取行动。
*   只有所有的承诺都成功了，一切才会成功。
*   allSettled 返回一个数组，列出每个承诺是成功还是失败。
*   任何一个承诺一旦成功就会成功，任何一个承诺一旦失败就会失败，从而填补空白。

帕尔默说:“这四者之间的微妙之处在于，你是需要所有的承诺，还是其中一个可以，拒绝是致命的，还是我们应该继续下去。”

他建议说:“任何承诺在你面临裁员的情况下都是最有用的。”。“想象一下，您可以从多个不同的网站获取文档或资源。也许你想提高网站的性能，让它从多个不同的服务器并行请求，而你不在乎哪个请求成功。你感兴趣的只是第一次成功完成后的结果。”

Promise.any 不会自动终止任何其他请求；在 Promise.any 返回其结果后，您仍然需要负责手动取消它们。

如果所有的承诺都被拒绝，Promise.any 将返回一个聚合错误:每个承诺的单个错误的数组，因为您可能需要准确地知道每个操作失败的原因。

Promise.allSettled 给 JavaScript 引入了聚合错误。Terlson 指出，Promise.any 还标准化了聚合错误，以确保任何未来的功能都将使用相同的语法——因为这是一种非常有用的错误类型，已经在库中广泛使用(以及他所工作的 Azure SDK)。

“Promise.allSettled 是第一个我们有内置 API 的情况，它可能会返回多个错误，我们必须找出如何表示它们，但这一直是图书馆的一个问题，”他说。“如果您有一个多阶段的过程，比如尝试并行上传文件，但有些文件失败了，您会如何处理这些错误？好吧，你发明了自己的聚合器错误。”

ECMAScript 的未来版本可能包括将原因添加到错误构造函数中(目前是一个[第三阶段提案](https://github.com/tc39/proposal-error-cause) ) —链接一系列错误，以便您可以跟踪它们来处理底层问题，这将与聚合错误一起工作。

## 字符串.原型. replaceAll

[对字符串](https://github.com/tc39/proposal-string-replaceall)操作的新替换函数修复了 JavaScript 中另一个长期存在的漏洞。目前，replace 仅更改字符串的第一个实例，除非您使用/G 标志并编写一个全局 regexp 来替换所有实例。成千上万的开发者在 StackOverflow [上寻找如何处理这个](https://stackoverflow.com/q/1144783/96656)的信息，这是一个常见的绊脚石。

“很多人可能甚至没有意识到这一点，并使用 replace 来发布他们的代码，假设它将替换所有实例——但事实并非如此，”Terlson 说。对于某些字符串，使用正则表达式可能并不简单。对拉丁字符来说很简单。但是，如果你有 parens 或其他正则表达式语法，你不能只是用斜线代替引号。现在，不是正则表达式向导的人终于可以像他们一直想要的那样替换了。”

## 逻辑赋值运算符

JavaScript 已经允许您通过组合数学运算符来编写更简洁的代码；x += y，而不是 x = x + y。使用[逻辑赋值](https://github.com/tc39/proposal-logical-assignment)，开发人员将能够对逻辑运算符做同样的事情，如逻辑 and & &、逻辑 or ||和无效合并运算符？？(在 [ECMAScript 2020](https://thenewstack.io/report-whats-new-in-ecmascript-and-javascript-for-2020/) 中引入)，把 x ||= y 写成 x ||(x = y)。

“这不仅是一个超级常见的语法糖，而且它避免了某人传递给你一个有效的值(如 false、0 或空字符串)的错误，但你最终会用默认值覆盖它，”Terlson 说。“如果你使用某种可观察的框架，你可能最终会做一大堆你不需要做的工作，因为你没有改变价值。”

帕尔默指出，这是因为 JavaScript 中的逻辑运算符具有“短路”的特性。

“如果左手边是真实的，我们甚至永远不会评价右手边，”他说。“所以当你使用复合赋值时，我们将完全跳过这一步。使用 nullish 合并操作符，我们可以开始为缺失值赋值。”对象属性可能有值，也可能没有值；现在开发人员可以用对象属性编写了吗？？=并赋予它某种默认值。只有当对象属性已经为空时，才会进行赋值。

这不同于复合数学运算符，但这是大多数人在这种情况下想要做的。将它作为默认语法意味着开发人员不太可能犯错误。

## 数字分隔符

当一个长数字被分割成逻辑块时，确保你正确地阅读它要容易得多。由于 ECMAScript 2020 中 BigInt 的引入，开发者现在可以处理非常大的整数。[数字分隔符](https://github.com/tc39/proposal-numeric-separator)是语法糖，通过用下划线将长数字分开，使它们更容易阅读，因此您可以键入 1_000_000_000，而不是 10000000000 来表示 10 亿。下划线已经在 Java、Python、Perl、Ruby、Rust、Julia、Ada 和 C#中以这种方式使用。

这些下划线没有语义含义；他们纯粹是为了让我们的数字变得漂亮，”帕尔默说。

## 国际机场。显示名称

每个站点都需要自己的翻译货币、语言或地区名称列表，以便在语言、地区和脚本选择器的下拉列表中使用吗？[国际机场。DisplayNames](https://github.com/tc39/proposal-intl-displaynames) 提供了一些常用(和已翻译)字符串的标准翻译，比如语言名称和星期几。

“在某些时候，你需要一个下拉菜单让用户选择语言，如果能够做到这一点而不必手动为每一种语言创建翻译，那就太好了，因为我们在计算机上有一个数据库，其中有本地语言的本地名称，”特尔森说。

如果开发人员不需要包含人类可读形式的语言、区域和脚本显示名称，他们可以编写更短、可读性更强的 HTML 和 JavaScript。如果开发人员不编写或复制粘贴代码(或编写代码来解析 Intl 的输出),浏览器每次下载的内容就会减少。DateTimeFormat)，他们不能在里面出错。这使得本地化变得更容易、更便宜。

## WeakRef 和终结注册表

JavaScript 的一大优势是开发人员通常不需要进行手动内存管理，因此各个浏览器和其他 JavaScript 引擎之间的垃圾收集可能不同并不重要。通常，对对象的引用在 JavaScript 中是很重要的:只要你有一个对对象的引用，它就不会被垃圾收集。

如果您想通过删除不再需要存储的数据来节省内存，则必须显式删除强引用，如事件侦听器。甚至现有的 WeakMap 和 WeakSet 构造也不是真正的弱引用:新的 WeakRef 是一个真正的弱引用，您可以用它来包装事件侦听器之类的东西，因此它们可以被垃圾收集。

这是 JavaScript 中一个基本的新功能，从哲学上讲，它与通常的方法非常不同。

“我们喜欢 JavaScript，因为我们不需要手动跟踪内存；帕尔默说:“我们有垃圾收集员来帮我们做这件事。”。“当我们想保持物体在身边时，我们保持一个参照物；我们有一个链接到另一个对象的对象属性。当我们不再需要那个对象时，我们将属性设置为 undefined 或者清除它。通过释放对该对象的引用，它就从我们的世界中消失了，我们相信 JavaScript 引擎会在某个时候为我们恢复底层内存。”

当您确实需要使用事件侦听器或者通过在线性缓冲区中分配内存来进行手动内存跟踪时，JavaScript 还没有好的构造来处理它。"我们如何让你把这两个世界结合起来？"“我们如何让应用程序程序员只处理对象并表现出正常的生命周期，而在幕后，底层资源可能需要手动管理？”

WeakRef 解决了这个问题，尽管付出了额外工作的代价:“无论何时你想使用这个对象，也许是去引用它，你必须问它，‘你还在吗？’如果其他人都发布了对它的强引用，你可能会发现它已经不在那里了。"

这也有助于处理订阅等相关资源；让订阅回调使用弱引用来轮询对象意味着订阅不会在不再需要主对象时意外地保持它的活动状态。

尽管它很有用，但如果有任何其他方法来解决您的问题，使用弱引用也有一些强烈的警告，因为这可能意味着开发人员正在编写不再可移植的代码。

帕尔默称它是一个强大的工具，也是最后的手段:“这是一个非常高级的语言功能，需要学习和理解，因为否则，你可能会给自己带来问题。”

“在某些方面，这打破了 JavaScript 的一个核心原则，即直到现在，从来没有可观察到的垃圾收集，”他警告说。“你释放了你的引用，然后你相信它会在以后的某个时候发生，但是你的代码本身不能自省和看到它。能够观察它，并根据这种行为编写不同的代码，这有点可怕。”

那么，为什么要引入一个为 ECMAScript 6 考虑并拒绝的、可能绝大多数 JavaScript 开发人员永远不会使用的潜在危险特性呢？因为它改进了与 WebAssembly 的集成，web assembly 是在 JavaScript 引擎中实现的日益流行的内存安全、沙箱化的执行环境。

## 人体工程学终结器

这就是终结器的用武之地:开发人员可以注册一个回调来在对象被垃圾收集时接收一个事件，而不是轮询对象，这样他们就可以删除支持它的资源。

帕尔默说:“这就是我们如何实现有效的资源利用——我们不会留下垃圾——以及从用户的角度来看，他们获得了良好的 JavaScript 体验。”

为了避免问题，他建议不要将重要的行为放在终结器后面；根据 JavaScript 引擎的不同，垃圾收集运行时可能不会立即调用终结器，也可能不会按顺序调用它们，而且在某些情况下，如在高性能情况下运行的紧密循环，可能根本不会调用它们。

“这意味着你不应该在你的终结器中做任何可以用其他方式完成的事情，”帕尔默警告说。如果您仅在响应终结器运行时保存用户数据，您可能会发现您从未保存过该用户数据。这整个建议是试图帮助你做细粒度的，有效的内存恢复和清理，以确保你的程序更有效率。这是一个你可以利用的优化:这不是一个为你的应用做基本功能的地方。”

Terlson 指出，每次他认为他需要弱引用时，他实际上并不需要，但他仍然支持 WeakRef，因为 WebAssembly 的重要性越来越大。

“我们需要的所有理由，”他说，“是能够在 WebAssembly 和 JavaScript 之间更有效地共享内存。”

<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 68 31" version="1.1"><title>Group</title> <desc>Created with Sketch.</desc></svg>