<html>
<head>
<title>Managing State in Serverless</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在无服务器中管理状态</h1>
<blockquote>原文：<a href="https://thenewstack.io/managing-state-in-serverless/#0001-01-01">https://thenewstack.io/managing-state-in-serverless/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">


<p class="p1 translated"><span class="s1"><a href="https://twitter.com/gwenshap" target="_blank" class="ext-link" rel="external "><a href="https://www.confluent.io/" target="_blank" class="ext-link" rel="external "><span class="s1"/></a>的产品经理格温·沙皮拉</a> </span>，已经在移动数据超过20年了。Shapira是“<a href="http://shop.oreilly.com/product/0636920044123.do" class="ext-link" rel="external "> Kafka:权威指南</a>”的合著者，他定期介绍流处理、Apache Kafka、数据集成和事件驱动架构。最近，在纽约<a href="https://www.serverlessnyc.com/" target="_blank" class="ext-link" rel="external "> <span class="s1">无服务器日</span> </a>上，她分享了她对无服务器的想法，认为开发人员不必担心可扩展性，因为无服务器云提供商将管理架构的扩展，使开发人员能够专注于他们的应用程序。</p>
<p class="p1 translated">但是对于在无服务器环境下工作的开发人员来说，Shapira目前认为这项技术类似于自行车。“潮人喜欢这些自行车，因为它们很简单，但当你到达一座小山时，你就会明白为什么你需要齿轮，”沙皮拉说。</p>
<p class="translated"><img decoding="async" loading="lazy" class="aligncenter size-full wp-image-5991881" src="../Images/f7b937a8516060a275fa7017f4782871.png" alt="slide from gwen shapira talk showing fixie bike and saying its simple until its not" data-original-src="https://cdn.thenewstack.io/media/2018/11/26e84d6f-screen-shot-2018-11-06-at-12.29.06-pm.png"/></p>
<p class="p1 translated">对沙皮拉来说，管理国家是第一座山。状态是指固定在某个时间点的数据。通常，无服务器工作流被认为是在一种状态下拉入数据，做一些事情，然后可能在流程结束时以新的状态返回数据。</p>
<p class="p1 translated">例如，当媒体图像进入无服务器工作流并进行转换，从而将原始图像处理为缩略图、媒体使用的标准输出大小以及其他格式，然后将这些图像存储回S3存储桶中时，该工作流不必管理状态，因为图像以一种形式开始，以另一种形式结束。但是，随着无服务器开始用于多种业务工作流，需要接收数据、转换数据，然后在后续流程中使用转换后的数据。这意味着需要这些更复杂的无服务器进程来管理状态。她解释说:“在无服务器的流处理中，数据可能是有状态的，这让你问:我有处理这种复杂性的工具和背景吗？”</p>
<p class="p1 translated">“在无服务器中，你需要数据库非常快，”Shapira说。“您需要数据库以及功能可扩展，并保持相同的按使用付费模式。但是当你看的时候，你会发现完全没有付费使用模式的数据库。他们大多采用双重付费模式:你为存储付费，你为使用付费。因此，很少有像您的无服务器功能那样可扩展的，低延迟是一个相当大的瓶颈。必须进入具有多个表的大型数据库，获取数据，然后推送另一个更新…这将成为一项相当大的开销。”</p>
<p class="translated"><img decoding="async" loading="lazy" class="aligncenter size-full wp-image-5991882" src="../Images/fa1efdde4c8be296e76e06303b3e2e9c.png" alt="gwen shapira slide showing three databases and their benefits and disadvantages" data-original-src="https://cdn.thenewstack.io/media/2018/11/e7e46f06-screen-shot-2018-11-06-at-12.31.14-pm.png"/></p>
<p class="p1 translated">Shapira给出了一个订单请求的例子。订单需要检查仓库以查看是否有足够的库存，然后将该库存锁定到订单，这样其他人就不会拿走它，更新库存以显示减少的项目，然后将该订单转移到shipping。如果没有足够的商品，订单必须更新。在这种情况下，它不像仅仅依赖触发函数的事件那么简单:在一个工作流中有一定程度的数据状态维护和更新。在无服务器中，仅仅选择一个允许状态的数据库可能不是一个足够好的解决方案。</p>
<p class="p1 translated">Shapira指出了解决这个问题的三种方法:</p>
<ol class="ol1">
<li class="li2 translated">“你可以创建一个高度规范化的数据模型，这样你就可以在一次调用中得到你想要的一切，”她说。</li>
<li class="li1 translated">“你可以读取比你严格需要的更多的数据，”她建议道。“例如，如果你可以预测一个函数将如何被重用(通过使用Kafka)，那么你就会明白，如果你想要一个订单，你通常会需要许多其他订单，所以你也可以提取它并缓存。这非常有用，因为它在无服务器模式下节省了您的时间和金钱。”</li>
<li class="li3 translated">“最后一种模式目前是不可能的，”沙皮拉警告说。“理想情况下，无服务器云提供商将允许功能获得更新。事件不仅仅是动作，它们代表一组新的数据。但是，如果我的数据库在我的事件仍在运行时不断得到更新，我就没有办法得到那些更新。这是所有函数提供者的一个限制，但是Kafka updates从一开始就非常擅长这个。所以这还不可能，但如果这是可能的，生活将会很棒。”</li>
</ol>
<p class="p1 translated">Shapira鼓励开发人员从他们的代码中退一步，考虑他们工作的现实应用。“功能是要采取的行动。但这个事件也是信息。例如，当接受一个订单时，发生这种情况意味着除了对其做出反应之外，我可能还需要更新数据存储。例如，库存刚刚更新，因此我可能需要提醒客户该商品现已上市，这可能意味着我也需要更新库存仓库。”</p>
<p class="translated">与支持API的体系结构一样，无服务器要求组织的业务和技术方面有更紧密的联系。</p>
<p class="p1 translated">Shapira详细阐述了这种更紧密的联系:“当你写代码时，你关注的是作为你工作的第一个类对象的函数。功能是世界的中心。但真实的事情是真实世界中正在发生的事件。有时候你需要一个函数来处理它们，有时候你需要专注于数据库。”</p>
<blockquote><p class="translated">"在无服务器模式下，你需要数据库非常快."</p></blockquote>
<p class="p1 translated">Shapira对无服务器带来管理这些问题的可能性感到兴奋，认为这是一种剥离非本质问题，专注于处理实际业务问题的新方法。但她也表示，从已经思考过的东西中可以汲取很多智慧，特别是围绕微服务架构中的事件驱动设计模型，并将它们应用到无服务器。“事件驱动的微服务非常相似，所以学习那些模式，它们通常完全适用于这个稍微新的领域，”她建议道。</p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
<title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
 <path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>

</div>
</div>    
</body>
</html>