# 调试 WebAssembly 的痛苦

> 原文：<https://thenewstack.io/the-pain-of-debugging-webassembly/>

[](https://www.linkedin.com/in/arminronacher/)

 [阿明

罗纳彻

阿明是哨兵工程总监。](https://www.linkedin.com/in/arminronacher/) [](https://www.linkedin.com/in/arminronacher/)

如果你对[web assembly](https://thenewstack.io/what-is-webassembly/)([WASM](https://webassembly.org/))有所了解，那很可能是 WASM 让你在浏览器中以近乎原生的速度执行从 C、C++、Rust 等语言编译的代码。您可能不太熟悉这样一个事实，即 WASM 不仅在浏览器中是一项有趣的技术，在其他需要快速沙箱的环境中也是如此。因此，WASM 在边缘计算方面获得了一些人气，并成为某些情况下的轻量级 docker 替代品。

后者是由一个名为 [WASI](https://wasi.dev/) 的标准支持的，它提供了一个独立于平台的抽象来与操作系统进行接口，用于基本的输入/输出、文件系统访问、获取当前时间以及其他类似的事情。WASI 由运行时实现，如 [wasmtime](https://wasmtime.dev/) 或 [wasmer](https://wasmer.io/) 。

WASM 可以做一些很棒的事情。但是什么不牛逼呢？与 WASM 一起调试。

我们中的许多人都在复杂的系统上工作，在那里重现真正的错误变得越来越困难。作为开发人员，我们理解这一挑战。这就是为什么我们确保您可以使用 Sentry 的源地图来查找可靠地显示您的真实堆栈跟踪的堆栈跟踪——即使是在最小化的 JavaScript 构建中。当涉及到 WASM 时，我们希望有一个可靠的堆栈跟踪，在生产中有可靠的函数名、行号和文件名，所以我们可以将它发送给像 Sentry 这样的系统。但这就是我们目前遇到的限制。

## **当前调试故障**

WASM 的核心与本地语言通常处理的许多系统非常不同。是堆垛机！函数在与我们正在使用的内存相同的内存空间中是不可“寻址”的。这种“新颖”的概念有其优点，但是 WASM 现有的许多工具并不是为我们当前的现实而建造的。

## **堆栈展开**

让我们从基础开始:要获得堆栈跟踪，我们需要展开堆栈。在本地代码的世界里，这通常是通过像 [libunwind](https://www.nongnu.org/libunwind/) 这样的库来完成的——它实现了平台的展开方案。根据我们的需要，我们只关心函数的返回地址，仅此而已。

通常有两种放松方式。第一种是将整个堆栈内存连同寄存器一起转储到内存转储中(类似于小型转储)，然后在事后展开。第二个是捕获寄存器并在运行的程序中展开。当抛出 C++异常或 Rust panics 时，后者也是必要的。这些异常或恐慌已经告诉我们，栈展开不仅仅是构建一个奇特的栈跟踪所需要的，也是在出现异常时执行析构函数所需要的。

目前，WASM 不支持堆栈展开。虽然这看起来是一个非常严重的限制，但这并不是一个大问题(至少对于浏览器 JavaScript 来说)。事实证明，由于 WASM 基于堆栈的特性，WASM 函数调用在 JavaScript 堆栈跟踪中是可见的。这意味着，如果一个 JavaScript 函数调用 WASM，WASM 调用 JavaScript，我们可以从 JavaScript 观察 WASM 框架。因此，作为一种巧妙的解决方法，我们可以创建一个 JavaScript 异常对象，然后解析它的堆栈跟踪。

## **矮人**

DWARF 是我们最喜欢的调试标准，主要是因为它是唯一经过深思熟虑并有文档记录的标准。(另一个是源地图和 PDB，这是如此奇怪，我们可能会有一些未来内容的材料)。

虽然 DWARF 很棒，但它还不能真正与 WASM 一起工作——至少 Chrome 支持它调试 WASM，但还有一些问题。

DWARF 的工作方式是在可执行文件或目标文件中嵌入包含 DWARF 调试数据的部分。因为 WASM 是一种可扩展的对象格式，所以完全有可能在其中嵌入 DWARF。然而，我们前面已经提到，WASM 是基于堆栈的，函数不在内存中。它之所以有效，是因为 WASM 规范有一个[侏儒，它说代码地址是 WASM 文件代码段中的字节偏移量。](https://yurydelendik.github.io/webassembly-dwarf/)

酷毙了。除了很多 WASM 工具没有考虑字节偏移量之类的东西。有充分的理由，因为 WASM 实际上有两种格式:二进制格式和 WAST，这是一种文本表示。在 DWARF 中，这两种格式在出现调试信息时不再可以互换，否则偏移量需要重写。真扫兴。

## **矮人分裂**

好吧，侏儒是有用的。但是让我们想想*** DWARF 是如何工作的。DWARF 调试数据就嵌入在 WASM 文件中。这是一个问题，原因有两个:一个是大多数人不希望任何人轻易地反编译他们的代码，并从他们的构建机器或其他元数据中看到文件名。*

 *但是，即使你是一个开源爱好者，不介意调试信息放在互联网上，你也不会想把调试信息嵌入到 WASM 文件中。目前，WASM 的 DWARF 数据是海量的，即使在最乐观的未来，WASM 调试数据仍将比 WASM 主文件大一个数量级。

这就是将 DWARF 数据从主可执行文件中分离出来的想法发挥作用的地方。在 macOS 上，这些被称为`.dSYM`文件——但实际上这在任何地方都有效，包括 WASM。事实上，您已经可以将 WASM 文件拆分成代码和调试数据了。调试数据可以保存在不可执行且不起作用的 WASM 文件中，该文件仅包含调试信息。

问题是，把这两样东西分开后，就很难再联系起来了。当前的 DWARF 规范建议在主 WASM 文件中嵌入一个对可下载调试文件的引用，作为一个自定义部分。这基本上是源映射的工作方式，但不是本机调试的正常工作方式。苹果和微软都流行的一个绝妙想法是给调试和可执行文件全球唯一的调试 id。有了这些知识，您就可以将调试文件和代码文件链接在一起。

据我所知，还没有人支持矮人分裂。唯一流行的规范使用 URL 引用，这是比调试 id 更糟糕的用户体验。

## **调试 id**

从上一节可以看出，不说调试 id，就不能说“矮人分裂”。它们还有其他名称:构建 ID、调试 ID、代码 ID——所有这些名称或多或少都传达了我们调试数据的唯一 ID。

调试 id 很有用，因为它们允许您将调试文件连接到正确的 WASM 文件。如果我把错误的调试数据和你的文件连接起来，那么这就是两个不相关的好数据输入，垃圾输出的典型例子。

我在工具约定问题跟踪器上为 WASM 提出了这样一个[扩展，但是到目前为止还没有任何进展。](https://github.com/WebAssembly/tool-conventions/issues/133)

调试 id 之所以如此美妙，是因为它们非常易于使用。您的工具链将发出这些文件，您可以将它们放在一个[符号服务器](https://getsentry.github.io/symbolicator/advanced/symbol-server-compatibility/)上，调试器可以在那里下载二进制文件并调试数据。(顺便说一下，Sentry 也喜欢调试 id——即使您不使用符号服务器，您也可以在 Sentry 上将这些文件方便地上传到您的组织，并且它会工作。

## **来源图**

WASM 源映射格式是完全不合适的(你不能得到函数名，不能在调试器中访问变量，不能得到范围信息，等等。)甚至用于 JavaScript 调试，但是它也找到了进入 WASM 世界的方法。我认为我们最好集体忘记它们存在于 WASM 世界，但目前它们是唯一得到广泛支持的东西。它们不是很好，不能映射函数名，在 WASM 的文本汇编版本中只能显示指令指向哪里。

## **堆栈跟踪信息**

让我们想象一下以上所有的作品。我们仍未脱离险境。WASM 很少一个人来。至少，它附带了它的朋友 JavaScript，但并不罕见的是，它还带来了其他 WASM 模块。虽然 WASM 模块是独立的，但是它们可以导出和导入函数。当您有一个涉及 WASM 的堆栈跟踪时，一个文件名编码了 WASM 的位置信息，看起来像这样:`${url}:wasm-function[${funcIndex}]:${pcOffset}`。它告诉我们函数索引和其中的偏移量。不幸的是，您不知道在哪里查找函数索引或区分加载的 WASM 模块，因为来自两个不同模块的两个不同函数可能具有相同的`funcIndex`。

## **调试还是小众**

这就是元牢骚。似乎每个人都对 Web 组装感到非常兴奋，但是几乎没有人对确保它的可调试性感到兴奋。当然，有很多人在从事这项工作，但这是一个相对紧密的社区。如果您想参与或跟进，请查看以下任何项目:

<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 68 31" version="1.1"><title>Group</title> <desc>Created with Sketch.</desc></svg>*