<html>
<head>
<title>Get on the Grid at Last with the CSS Grid Layout Module</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用CSS网格布局模块最后上网格</h1>
<blockquote>原文：<a href="https://thenewstack.io/get-grid-last-css-grid-template-markup/#0001-01-01">https://thenewstack.io/get-grid-last-css-grid-template-markup/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">


<p class="translated">web的通用样式语言<a href="https://developer.mozilla.org/en-US/docs/Web/CSS" class="ext-link" rel="external ">层叠样式表</a> (CSS)在布局方面总是被从根本上打破，这有多奇怪？</p>
<p class="translated">自从样式从标记中脱离出来的早期，web开发人员就一直在努力把东西放在我们希望它们去的地方，甚至更好的是，让它们留在那里。对此从来没有一个可靠的工具或有效的系统。在早期，我们强迫表格标记完成布局任务——尽管它从来就不是为了这个目的。最终，浮动属性出现了；这是另一个不适合布局的工具，绝望的开发者可以和clear一起使用，创建一些布局的外观。然后是官方的CSS定位，一个实际上是为布局设计的实体，但不幸的是从来没有构建得足够好来有效地完成它。</p>
<p class="translated">CSS作为一种语言逐渐变得足够强大，可以在页面上实现各种效果，甚至是复杂而生动的动画——但布局却受到冷落，开发人员只是简单地拼凑一些有用的东西。最近<a href="https://www.w3.org/TR/css-flexbox-1/" class="ext-link" rel="external "> Flexbox </a>让我们的生活变得更加简单，作为一名网站开发人员，我对Flexbox非常满意。我已经能够让它做我需要它做的事情，或多或少，在大多数时候，这比我能说的所有以前的竞争者都多。然而，总有改进的空间，所以我——和web开发界的其他人——一直在不耐烦地等待<a href="https://www.w3.org/TR/css-grid-1/" class="ext-link" rel="external "> CSS网格布局模块最终上线</a>。</p>
<p class="translated">这是一个漫长的过程。该规范由微软于2011年4月首次提出，名为“CSS网格布局”。早期版本包含在Internet Explorer(版本10和11)中，该规范于2012年被万维网联盟(W3C)采纳为工作草案<a href="https://www.w3.org/TR/2012/WD-css3-grid-layout-20121106/" class="ext-link" rel="external ">。在接下来的五年里，来自Mozilla和Google的志愿者编辑与微软一起完善和发展该规范。最后，在2017年3月，CSS网格布局模块全面上线，现在出现在你附近的浏览器中。现在，所有主流桌面浏览器的最新版本都支持网格，iOS Safari和Chrome也支持Android移动浏览器。</a></p>
<p class="translated">就我个人而言，我迫不及待地想用我那黏糊糊的小手指来玩这个新玩具。从现在开始我们称之为“网格”</p>
<p class="translated">当玩新项目时，我经常使用<a href="https://glitch.com/" class="ext-link" rel="external ">glitch.com</a>以方便使用和即时满足实时网络显示，但不幸的是，glitch似乎没有<em> sprechen sie CSS Grid </em>，即使在<a href="https://www.google.com/chrome/browser/canary.html" class="ext-link" rel="external "> Chrome的金丝雀</a>浏览器中打开了“实验性网络平台功能”，所以我转向Atom和good ol' localhost:8000，在本地使用它。Grid在Chrome v.57中为我工作，不需要任何标志，尽管在<a href="http://caniuse.com/#feat=css-grid" class="ext-link" rel="external ">caniuse.com的Grid </a>当前状态摘要中有警告。令人鼓舞的是，<a href="https://atom.io/" class="ext-link" rel="external "> Atom </a>文本编辑器提供了网格属性作为编辑器中的自动补全功能，所以很高兴知道我并不是完全处于未知领域。</p>
<h2 class="translated">有点像乐高积木</h2>
<p class="translated">是的，乐高。有了Grid，我们将各种形状和大小的盒子堆叠并连接在一起,(希望)构建一个平滑、均匀的整体。首先，我们在HTML中制作一些基本的盒子:<br/></p>
<div id="crayon-641f0bc86622d533877930" class="crayon-syntax crayon-theme-github-gist crayon-font-liberation-mono crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-always">
<p class="crayon-plain-wrap"/>
<div class="crayon-main">
<pre><span class="crayon-h"> </span><span class="crayon-sy">&amp;lt;</span><span class="crayon-e">div </span><span class="crayon-i">class</span>=<span class="crayon-s">"wrapper"</span><span class="crayon-sy">&amp;gt;</span>
<span class="crayon-h"> </span> <span class="crayon-h"> </span><span class="crayon-sy">&amp;lt;</span><span class="crayon-e">div </span><span class="crayon-i">class</span>=<span class="crayon-s">"A"</span><span class="crayon-sy">&amp;gt;</span><span class="crayon-st">A</span><span class="crayon-sy">&amp;lt;</span>/<span class="crayon-i">div</span><span class="crayon-sy">&amp;gt;</span>
<span class="crayon-h"> </span> <span class="crayon-h"> </span><span class="crayon-sy">&amp;lt;</span><span class="crayon-e">div </span><span class="crayon-i">class</span>=<span class="crayon-s">"B"</span><span class="crayon-sy">&amp;gt;</span><span class="crayon-i">B</span><span class="crayon-sy">&amp;lt;</span>/<span class="crayon-i">div</span><span class="crayon-sy">&amp;gt;</span>
<span class="crayon-h"> </span> <span class="crayon-h"> </span><span class="crayon-sy">&amp;lt;</span><span class="crayon-e">div </span><span class="crayon-i">class</span>=<span class="crayon-s">"C"</span><span class="crayon-sy">&amp;gt;</span><span class="crayon-i">C</span><span class="crayon-sy">&amp;lt;</span>/<span class="crayon-i">div</span><span class="crayon-sy">&amp;gt;</span>
<span class="crayon-h"> </span> <span class="crayon-h"> </span><span class="crayon-sy">&amp;lt;</span><span class="crayon-e">div </span><span class="crayon-i">class</span>=<span class="crayon-s">"D"</span><span class="crayon-sy">&amp;gt;</span><span class="crayon-r">D</span><span class="crayon-sy">&amp;lt;</span>/<span class="crayon-i">div</span><span class="crayon-sy">&amp;gt;</span>
<span class="crayon-h"> </span> <span class="crayon-h"> </span><span class="crayon-sy">&amp;lt;</span><span class="crayon-e">div </span><span class="crayon-i">class</span>=<span class="crayon-s">"E"</span><span class="crayon-sy">&amp;gt;</span><span class="crayon-st">E</span><span class="crayon-sy">&amp;lt;</span>/<span class="crayon-i">div</span><span class="crayon-sy">&amp;gt;</span>
<span class="crayon-h"> </span> <span class="crayon-h"> </span><span class="crayon-sy">&amp;lt;</span><span class="crayon-e">div </span><span class="crayon-i">class</span>=<span class="crayon-s">"F"</span><span class="crayon-sy">&amp;gt;</span><span class="crayon-m">F</span><span class="crayon-sy">&amp;lt;</span>/<span class="crayon-i">div</span><span class="crayon-sy">&amp;gt;</span>
<span class="crayon-h"> </span><span class="crayon-sy">&amp;lt;</span>/<span class="crayon-i">div</span><span class="crayon-sy">&amp;gt;</span>
 
<span class="crayon-h"> </span><span class="crayon-h">&lt;</span><span class="crayon-e">img </span><span class="crayon-i">src</span>=<span class="crayon-s">"https://cdn.thenewstack.io/media/2017/04/8d69d41b-basicgridhtml.png"</span><span class="crayon-h"> </span><span class="crayon-i">alt</span>=<span class="crayon-s">""</span><span class="crayon-h"> </span><span class="crayon-i">width</span>=<span class="crayon-s">"195"</span><span class="crayon-h"> </span><span class="crayon-i">height</span>=<span class="crayon-s">"137"</span><span class="crayon-h"> </span>/<span class="crayon-h">&gt;</span>
</pre>
</div>
</div>

<p class="translated"><br/>然后CSS网格乐趣从显示开始:网格；(只是flexbox布局从display开始的方式:flex).一旦在父容器上建立了这一点，就该享受行和列的乐趣了。CSS网格布局模块提供了两个访问它们的属性:grid-template-rows和Grid-template-columns(Atom在弹出窗口中也提供了这两个属性)</p>
<div id="crayon-641f0bc866232001506821" class="crayon-syntax crayon-theme-github-gist crayon-font-liberation-mono crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-always">
<p class="crayon-plain-wrap"/>
<div class="crayon-main">
<pre><span class="crayon-h"> </span>.<span class="crayon-i">wrapper</span><span class="crayon-h"> </span>{
<span class="crayon-h"> </span> <span class="crayon-h"> </span><span class="crayon-i">display</span>:<span class="crayon-h"> </span><span class="crayon-i">grid</span>;
<span class="crayon-h">  </span> <span class="crayon-i">grid</span>-<span class="crayon-i">template</span>-<span class="crayon-i">columns</span>:<span class="crayon-h"> </span><span class="crayon-cn">100px</span><span class="crayon-h"> </span><span class="crayon-cn">10px</span><span class="crayon-h"> </span><span class="crayon-cn">100px</span><span class="crayon-h"> </span><span class="crayon-cn">10px</span><span class="crayon-h"> </span><span class="crayon-cn">100px</span>;
<span class="crayon-h"> </span> <span class="crayon-h"> </span><span class="crayon-i">grid</span>-<span class="crayon-i">template</span>-<span class="crayon-i">rows</span>:<span class="crayon-h"> </span><span class="crayon-i">auto</span><span class="crayon-h"> </span><span class="crayon-cn">10px</span><span class="crayon-h"> </span><span class="crayon-i">auto</span>;
<span class="crayon-h"> </span>}
</pre>
</div>
</div>

<p class="translated"><br/>这建立了三个100px的列，由两个10px的间距隔开。网格-模板-行行建立了三行；中间的也是一个10px的檐槽。另外两个是“auto”，这是一个漂亮的东西，意味着它们可以扩展以容纳里面填充的任何内容。这是它的样子:</p>
<p class="translated"><img decoding="async" loading="lazy" src="../Images/40c7d702d7b45de56fb434d219565be1.png" alt="" data-original-src="https://cdn.thenewstack.io/media/2017/04/c0c168b7-basicgridcss.png"/></p>
<p class="translated">等等，什么？Ohhhhh:问题是网格子节点已经顺从地试图在提供的列中按照标记的顺序放置它们自己，这意味着一些子节点已经挤进了10px的gutter列。即使还有空的和可用的内容列。</p>
<h2 class="translated">快乐的小盒子</h2>
<p class="translated">对这种自动放置现象的修复恰好也是网格的最佳实践:网格中每个项目的指定定位，它依赖于基于行的布局放置。我们的第一个快乐的小盒子A的属性如下所示:<br/></p>
<div id="crayon-641f0bc866234958963290" class="crayon-syntax crayon-theme-github-gist crayon-font-liberation-mono crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-always">
<p class="crayon-plain-wrap"/>
<div class="crayon-main">
<pre><span class="crayon-h"> </span>.<span class="crayon-st">A</span><span class="crayon-h"> </span>{
<span class="crayon-h"> </span>   <span class="crayon-i">grid</span>-<span class="crayon-i">column</span>-<span class="crayon-i">start</span>:<span class="crayon-h"> </span><span class="crayon-cn">1</span>;
<span class="crayon-h"> </span>   <span class="crayon-i">grid</span>-<span class="crayon-i">column</span>-<span class="crayon-i">end</span>:<span class="crayon-h"> </span><span class="crayon-cn">2</span>;
<span class="crayon-h"> </span>   <span class="crayon-i">grid</span>-<span class="crayon-i">row</span>-<span class="crayon-i">start</span>:<span class="crayon-h"> </span><span class="crayon-cn">1</span>;
<span class="crayon-h"> </span>   <span class="crayon-i">grid</span>-<span class="crayon-i">row</span>-<span class="crayon-i">end</span>:<span class="crayon-h"> </span><span class="crayon-cn">2</span>;
<span class="crayon-h"> </span> }
</pre>
</div>
</div>

<p class="translated"><br/>这需要大量的输入，所以幸运的是，Grid提供了一些速记:<br/></p>
<div id="crayon-641f0bc866235903422385" class="crayon-syntax crayon-theme-github-gist crayon-font-liberation-mono crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-always">
<p class="crayon-plain-wrap"/>
<div class="crayon-main">
<pre><span class="crayon-h"> </span> .<span class="crayon-st">A</span><span class="crayon-h"> </span>{
<span class="crayon-h"> </span>   <span class="crayon-i">grid</span>-<span class="crayon-i">column</span>:<span class="crayon-h"> </span><span class="crayon-cn">1</span><span class="crayon-h"> </span>/<span class="crayon-h"> </span><span class="crayon-cn">2</span>;
<span class="crayon-h"> </span>   <span class="crayon-i">grid</span>-<span class="crayon-i">row</span>:<span class="crayon-h"> </span><span class="crayon-cn">1</span><span class="crayon-h"> </span>/<span class="crayon-h"> </span><span class="crayon-cn">2</span>;
<span class="crayon-h"> </span> }
</pre>
</div>
</div>

<p class="translated"><br/>其中网格-列和网格-行值表示列/行开始和列/行结束。</p>
<p class="translated">由于我们可能还想对我们的快乐小盒子做一些其他的事情，CSS网格布局模块有一个更短的快捷方式:网格区域属性。<br/></p>
<div id="crayon-641f0bc866236759924395" class="crayon-syntax crayon-theme-github-gist crayon-font-liberation-mono crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-always">
<p class="crayon-plain-wrap"/>
<div class="crayon-main">
<pre><span class="crayon-h"> </span>.<span class="crayon-st">A</span><span class="crayon-h"> </span>{
<span class="crayon-h">  </span>    <span class="crayon-i">grid</span>-<span class="crayon-i">area</span>:<span class="crayon-h"> </span><span class="crayon-cn">1</span><span class="crayon-h"> </span>/<span class="crayon-h"> </span><span class="crayon-cn">1</span><span class="crayon-h"> </span>/<span class="crayon-h"> </span><span class="crayon-cn">2</span><span class="crayon-h"> </span>/<span class="crayon-h"> </span><span class="crayon-cn">2</span>;
<span class="crayon-h"> </span>}
</pre>
</div>
</div>

<p class="translated">这将行和列的开始和结束值合并成一行，但是——至少对我来说——可读性的损失抵消了这种便利。这是早期的游戏，真的，但现在，我会走中间道路，网格列和网格行。</p>
<p class="translated">所以，我们的CSS——现在有了自定义的框位置！—看起来像:<br/></p>
<div id="crayon-641f0bc866237121697616" class="crayon-syntax crayon-theme-github-gist crayon-font-liberation-mono crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-always">
<p class="crayon-plain-wrap"/>
<div class="crayon-main">
<pre><span class="crayon-h"> </span> .<span class="crayon-st">A</span><span class="crayon-h"> </span>{
<span class="crayon-h"> </span>   <span class="crayon-i">grid</span>-<span class="crayon-i">column</span>:<span class="crayon-h"> </span><span class="crayon-cn">1</span><span class="crayon-h"> </span>/<span class="crayon-h"> </span><span class="crayon-cn">2</span>;
<span class="crayon-h"> </span>   <span class="crayon-i">grid</span>-<span class="crayon-i">row</span>:<span class="crayon-h"> </span><span class="crayon-cn">1</span><span class="crayon-h"> </span>/<span class="crayon-h"> </span><span class="crayon-cn">2</span>;
<span class="crayon-h"> </span> }
<span class="crayon-h"> </span> .<span class="crayon-i">B</span><span class="crayon-h"> </span>{
<span class="crayon-h"> </span>   <span class="crayon-i">grid</span>-<span class="crayon-i">column</span>:<span class="crayon-h"> </span><span class="crayon-cn">3</span><span class="crayon-h"> </span>/<span class="crayon-h"> </span><span class="crayon-cn">4</span>;<span class="crayon-h"> </span><span class="crayon-c">/*(because we want it to skip the second, gutter column)*/</span>
<span class="crayon-h"> </span>   <span class="crayon-i">grid</span>-<span class="crayon-i">row</span>:<span class="crayon-h"> </span><span class="crayon-cn">1</span><span class="crayon-h"> </span>/<span class="crayon-h"> </span><span class="crayon-cn">2</span>;<span class="crayon-h"> </span><span class="crayon-c">/*(because it's the still the same row as A)*/</span>
<span class="crayon-h"> </span> }
<span class="crayon-h"> </span> .<span class="crayon-i">C</span><span class="crayon-h"> </span>{
<span class="crayon-h"> </span>   <span class="crayon-i">grid</span>-<span class="crayon-i">column</span>:<span class="crayon-h"> </span><span class="crayon-cn">5</span><span class="crayon-h"> </span>/<span class="crayon-h"> </span><span class="crayon-cn">6</span>;<span class="crayon-h"> </span><span class="crayon-c">/*(again, skipping the fourth column, which is another gutter)*/</span>
<span class="crayon-h"> </span>   <span class="crayon-i">grid</span>-<span class="crayon-i">row</span>:<span class="crayon-h"> </span><span class="crayon-cn">1</span><span class="crayon-h"> </span>/<span class="crayon-h"> </span><span class="crayon-cn">2</span>;
<span class="crayon-h"> </span> }
<span class="crayon-h"> </span> .<span class="crayon-m">D</span><span class="crayon-h"> </span>{
<span class="crayon-h"> </span>   <span class="crayon-i">grid</span>-<span class="crayon-i">column</span>:<span class="crayon-h"> </span><span class="crayon-cn">1</span><span class="crayon-h"> </span>/<span class="crayon-h"> </span><span class="crayon-cn">2</span>;<span class="crayon-h"> </span><span class="crayon-c">/*(back to the first column again because...)*/</span>
<span class="crayon-h"> </span>   <span class="crayon-i">grid</span>-<span class="crayon-i">row</span>:<span class="crayon-h"> </span><span class="crayon-cn">3</span><span class="crayon-h"> </span>/<span class="crayon-h"> </span><span class="crayon-cn">4</span>;<span class="crayon-h"> </span><span class="crayon-c">/*(...we are starting a new row!)*/</span>
<span class="crayon-h"> </span> }
<span class="crayon-h"> </span> .<span class="crayon-st">E</span><span class="crayon-h"> </span>{
<span class="crayon-h"> </span>   <span class="crayon-i">grid</span>-<span class="crayon-i">column</span>:<span class="crayon-h"> </span><span class="crayon-cn">3</span><span class="crayon-h"> </span>/<span class="crayon-h"> </span><span class="crayon-cn">4</span>;
<span class="crayon-h"> </span>   <span class="crayon-i">grid</span>-<span class="crayon-i">row</span>:<span class="crayon-h"> </span><span class="crayon-cn">3</span><span class="crayon-h"> </span>/<span class="crayon-h"> </span><span class="crayon-cn">4</span>;
<span class="crayon-h"> </span> }
<span class="crayon-h"> </span> .<span class="crayon-m">F</span><span class="crayon-h"> </span>{
<span class="crayon-h"> </span>   <span class="crayon-i">grid</span>-<span class="crayon-i">column</span>:<span class="crayon-h"> </span><span class="crayon-cn">5</span><span class="crayon-h"> </span>/<span class="crayon-h"> </span><span class="crayon-cn">6</span>;
<span class="crayon-h"> </span>   <span class="crayon-i">grid</span>-<span class="crayon-i">row</span>:<span class="crayon-h"> </span><span class="crayon-cn">3</span><span class="crayon-h"> </span>/<span class="crayon-h"> </span><span class="crayon-cn">4</span>;
<span class="crayon-h"> </span> }
</pre>
</div>
</div>

<p class="translated"><br/>(哦，对了，我偷偷加入了一些格式，因为，嗯，盒子。)无论如何，当盒子由于网格的默认位置而堵塞时，我们从元素消失在排水沟中开始:</p>
<p class="translated"><img decoding="async" loading="lazy" src="../Images/0378f255d76dac272ef2000b1aae33f2.png" alt="" data-original-src="https://cdn.thenewstack.io/media/2017/04/95891a17-gridgutters-300x146.png"/></p>
<p class="translated">到一个漂亮、整洁的——等等——网格！<br/> <img decoding="async" loading="lazy" src="../Images/2bf148bafdf3c51654bc60f078a7ffc3.png" alt="" data-original-src="https://cdn.thenewstack.io/media/2017/04/1ef0a046-gridgrid-300x186.png"/></p>
<p class="translated">但是现在已经不是2001年了，我们可能不希望在我们的web应用程序中出现一个方形的小内容框，对吗？网格理解。网格挖掘我们的设计需求，并以无限的弹性做出回应。网格框(区域)可以是适合行和列的初始网格声明的任何维度。我们只需要指定内容的开始和结束。</p>
<p class="translated">这是同一个网格声明，现在有四个不同尺寸的盒子。开始看起来像一个实际的布局，甚至:</p>
<p class="translated"><img decoding="async" loading="lazy" src="../Images/1cfe12d0a7c9a5455a90a9a27d65489a.png" alt="" data-original-src="https://cdn.thenewstack.io/media/2017/04/6a4980bb-gridlayout-300x163.png"/></p>
<p class="translated">注意，在Grid中，这些Grid子元素的标记顺序并不重要。这很酷:我们可以在HTML中从语法上做正确的事情，然后独立于源代码顺序放置这些元素，然而，我们希望在CSS中。:<br/></p>
<div id="crayon-641f0bc866238986815533" class="crayon-syntax crayon-theme-github-gist crayon-font-liberation-mono crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-always">
<p class="crayon-plain-wrap"/>
<div class="crayon-main">
<pre><span class="crayon-h"> </span>.<span class="crayon-st">A</span><span class="crayon-h"> </span>{
<span class="crayon-h">   </span><span class="crayon-i">grid</span>-<span class="crayon-i">column</span>:<span class="crayon-h"> </span><span class="crayon-cn">1</span><span class="crayon-h"> </span>/<span class="crayon-h"> </span><span class="crayon-cn">4</span>;
<span class="crayon-h">   </span><span class="crayon-i">grid</span>-<span class="crayon-i">row</span>:<span class="crayon-h"> </span><span class="crayon-cn">1</span><span class="crayon-h"> </span>/<span class="crayon-h"> </span><span class="crayon-cn">2</span>;
<span class="crayon-h"> </span>}
<span class="crayon-h"> </span>.<span class="crayon-i">B</span><span class="crayon-h"> </span>{
<span class="crayon-h">   </span><span class="crayon-i">grid</span>-<span class="crayon-i">column</span>:<span class="crayon-h"> </span><span class="crayon-cn">5</span><span class="crayon-h"> </span>/<span class="crayon-h"> </span><span class="crayon-cn">6</span>;
<span class="crayon-h">   </span><span class="crayon-i">grid</span>-<span class="crayon-i">row</span>:<span class="crayon-h"> </span><span class="crayon-cn">1</span><span class="crayon-h"> </span>/<span class="crayon-h"> </span><span class="crayon-cn">4</span>;
<span class="crayon-h"> </span>}
<span class="crayon-h"> </span>.<span class="crayon-i">C</span><span class="crayon-h"> </span>{
<span class="crayon-h">   </span><span class="crayon-i">grid</span>-<span class="crayon-i">column</span>:<span class="crayon-h"> </span><span class="crayon-cn">1</span><span class="crayon-h"> </span>/<span class="crayon-h"> </span><span class="crayon-cn">2</span>;
<span class="crayon-h">   </span><span class="crayon-i">grid</span>-<span class="crayon-i">row</span>:<span class="crayon-h"> </span><span class="crayon-cn">3</span><span class="crayon-h"> </span>/<span class="crayon-h"> </span><span class="crayon-cn">4</span>;
<span class="crayon-h"> </span>}
<span class="crayon-h"> </span>.<span class="crayon-m">D</span><span class="crayon-h"> </span>{
<span class="crayon-h">   </span><span class="crayon-i">grid</span>-<span class="crayon-i">column</span>:<span class="crayon-h"> </span><span class="crayon-cn">3</span><span class="crayon-h"> </span>/<span class="crayon-h"> </span><span class="crayon-cn">4</span>;
<span class="crayon-h">   </span><span class="crayon-i">grid</span>-<span class="crayon-i">row</span>:<span class="crayon-h"> </span><span class="crayon-cn">3</span><span class="crayon-h"> </span>/<span class="crayon-h"> </span><span class="crayon-cn">4</span>;
<span class="crayon-h"> </span>}
</pre>
</div>
</div>

<p class="translated"><br/>(有趣的是，你可以让盒子在网格中重叠。下面，A现在跨越了整个5列，B在grid-column中重叠:5/6；他们共有的地方。由于这是CSS，这可能会导致一些可怕的和意想不到的结果，但我仍然把这些信息藏在我的后口袋里，以便以后使用。因为你永远不知道它什么时候会在设计上派上用场。<em>告诫选择者。</em>)</p>
<h2 class="translated">行话时间！</h2>
<p class="translated">CSS网格布局模块的下一步需要一些新的词汇。</p>
<p class="translated">水平和垂直<strong>网格线</strong>组成网格。访问它们的默认方式是通过编号，但是也可以给它们指定一个名称。</p>
<p class="translated">一个<strong>网格单元</strong>是任意四条相交网格线之间的空间，是CSS网格系统中的最小单元。有点像电子表格中的单个表格单元格。</p>
<p class="translated">一个<strong>网格区域</strong>由多个网格单元组成。它必须仍然被四条网格线所限制。(所以我们这里说的是正方形和长方形，而不是“L”形)。</p>
<p class="translated"><strong>网格轨迹</strong>是垂直或水平网格线对之间的空间。在我们的例子中，我们有宽的网格轨道代表内容放置的空间，窄的网格轨道起着装订线的作用。</p>
<p class="translated"><img decoding="async" loading="lazy" src="../Images/a3f8aa422172dd581e07925b61d49aa0.png" alt="" data-original-src="https://cdn.thenewstack.io/media/2017/04/d7607586-gridterms-300x171.png"/></p>
<p class="translated">目前，网格区域之间的檐槽空间必须手动规划和放置。我可以预见，在命名网格线时记住排水沟将是一件痛苦的事情。即将出现的网格属性称为网格-列-间隙和网格-行-间隙，有助于这一过程，但它们还没有得到浏览器的广泛支持。在此之前，网格水槽是严格的DIY。但我认为你能处理好。</p>
<h2 class="translated">现在:启动电源</h2>
<p class="translated">在这一点上，如果你想做的只是设计表格的变化，网格看起来可能有点酷。“咩”是可以理解的回应。但是等等——还有更多！</p>
<p class="translated">CSS网格布局模块提供了一个内置的方法来快速创建和自动定位常见的网站组件，如侧栏和页脚。这是一个名为grid-template-areas的属性，它将命名的网格区域放在我们认为它们通常会去的地方。让我们从最简单的HTML标记开始:一个页眉、一个页脚、一些内容和一个侧栏:<br/></p>
<div id="crayon-641f0bc86623b031521889" class="crayon-syntax crayon-theme-github-gist crayon-font-liberation-mono crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-always">
<p class="crayon-plain-wrap"/>
<div class="crayon-main">
<pre><span class="crayon-sy">&amp;lt;</span><span class="crayon-e">div </span><span class="crayon-i">class</span>=<span class="crayon-s">"wrapper"</span><span class="crayon-sy">&amp;gt;</span>
 <span class="crayon-h"> </span> <span class="crayon-h"> </span> <span class="crayon-sy">&amp;lt;</span><span class="crayon-e">div </span><span class="crayon-i">class</span>=<span class="crayon-s">"header"</span><span class="crayon-sy">&amp;gt;</span><span class="crayon-e">Our </span><span class="crayon-i">Header</span><span class="crayon-sy">&amp;lt;</span>/<span class="crayon-i">div</span><span class="crayon-sy">&amp;gt;</span>
 <span class="crayon-h"> </span> <span class="crayon-h"> </span> <span class="crayon-sy">&amp;lt;</span><span class="crayon-e">div </span><span class="crayon-i">class</span>=<span class="crayon-s">"content"</span><span class="crayon-sy">&amp;gt;</span><span class="crayon-i">Coolio</span><span class="crayon-sy">&amp;lt;</span><span class="crayon-i">br</span><span class="crayon-sy">&amp;gt;</span><span class="crayon-sy">&amp;lt;</span><span class="crayon-i">br</span><span class="crayon-sy">&amp;gt;</span><span class="crayon-h"> </span><span class="crayon-i">Content</span><span class="crayon-h"> </span><span class="crayon-sy">&amp;lt;</span><span class="crayon-i">br</span><span class="crayon-sy">&amp;gt;</span><span class="crayon-h"> </span><span class="crayon-sy">&amp;lt;</span><span class="crayon-i">br</span><span class="crayon-sy">&amp;gt;</span><span class="crayon-i">Here</span><span class="crayon-sy">&amp;lt;</span>/<span class="crayon-i">div</span><span class="crayon-sy">&amp;gt;</span>
 <span class="crayon-h"> </span> <span class="crayon-h"> </span> <span class="crayon-sy">&amp;lt;</span><span class="crayon-e">div </span><span class="crayon-i">class</span>=<span class="crayon-s">"sidebar"</span><span class="crayon-sy">&amp;gt;</span>(<span class="crayon-e">Some </span><span class="crayon-e">Side </span><span class="crayon-i">Stuff</span>)<span class="crayon-sy">&amp;lt;</span>/<span class="crayon-i">div</span><span class="crayon-sy">&amp;gt;</span>
 <span class="crayon-h"> </span> <span class="crayon-h"> </span> <span class="crayon-sy">&amp;lt;</span><span class="crayon-e">div </span><span class="crayon-i">class</span>=<span class="crayon-s">"footer"</span><span class="crayon-sy">&amp;gt;</span><span class="crayon-e">The </span><span class="crayon-i">Footer</span><span class="crayon-sy">&amp;lt;</span>/<span class="crayon-i">div</span><span class="crayon-sy">&amp;gt;</span>
<span class="crayon-sy">&amp;lt;</span>/<span class="crayon-i">div</span><span class="crayon-sy">&amp;gt;</span>
</pre>
</div>
</div>

<p class="translated"><br/>为了将它设计成类似于页面的样式，我们以和前面一样的方式开始，建立网格。首先，在包装器上声明display: grid，然后定义grid-template列和grid-template-rows。这一次我删除了七列——四个内容，三个装订线——并用(更易响应的)12.5em/1em单位表示尺寸，而不是像素。全自动驾驶，看看会发生什么。</p>
<p class="translated">神奇的事情发生了:网格-模板-区域。为了定义我们想要什么去哪里，CSS大师Rachel Andrew 做了一个非常贴切的比喻来制作ASCII艺术:你必须在你想要它填充的每个位置键入一次元素名称。因为我们有七列，标题在最上面，我们从“标题标题标题标题标题标题标题标题标题标题标题”开始。</p>
<p class="translated">对于内容和侧边栏，内容得到了更多的发挥，因为侧边栏，嗯，放在一边:“内容内容内容内容内容内容。侧边栏。”也就是网格术语“让内容有五列宽，让第六列空着，给侧边栏分配一列。”句点字符告诉Grid将该网格单元格留空。<br/></p>
<div id="crayon-641f0bc86623c933255377" class="crayon-syntax crayon-theme-github-gist crayon-font-liberation-mono crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-always">
<p class="crayon-plain-wrap"/>
<div class="crayon-main">
<pre>.<span class="crayon-i">wrapper</span><span class="crayon-h"> </span>{
 <span class="crayon-h"> </span><span class="crayon-i">display</span>:<span class="crayon-h"> </span><span class="crayon-i">grid</span>;
<span class="crayon-h">  </span><span class="crayon-i">grid</span>-<span class="crayon-i">template</span>-<span class="crayon-i">columns</span>:<span class="crayon-h"> </span><span class="crayon-cn">12.5em</span><span class="crayon-h"> </span><span class="crayon-cn">1em</span><span class="crayon-h"> </span><span class="crayon-cn">12.5em</span><span class="crayon-h"> </span><span class="crayon-cn">1em</span><span class="crayon-h"> </span><span class="crayon-cn">12.5em</span><span class="crayon-h"> </span><span class="crayon-cn">1em</span><span class="crayon-h"> </span><span class="crayon-cn">12.5em</span>;
<span class="crayon-h">  </span><span class="crayon-i">grid</span>-<span class="crayon-i">template</span>-<span class="crayon-i">rows</span>:<span class="crayon-h"> </span><span class="crayon-i">auto</span>;
<span class="crayon-h">  </span><span class="crayon-i">grid</span>-<span class="crayon-i">template</span>-<span class="crayon-i">areas</span>:<span class="crayon-h"> </span><span class="crayon-s">"header header header header header header header"</span>
<span class="crayon-h">  </span><span class="crayon-s">"content content content content content . sidebar"</span>
<span class="crayon-h">  </span><span class="crayon-s">"footer footer footer footer footer footer footer"</span>;
<span class="crayon-h"> </span>    }
</pre>
</div>
</div>

<p class="translated"><br/>T9】</p>
<p class="translated">注意这里没有水平的檐槽，因为我们没有在网格模板行中声明任何水平的檐槽。有一个垂直的檐槽，感谢“.”在grid-template-areas values语句的第二行中。</p>
<p class="translated">另一件很酷的事情是:你可以在网格子元素中使用Flexbox！我希望侧边栏网格区域内的“一些附加内容”文本垂直和水平居中，而不是默认的块。所以通过声明display: flex on。我们可以使用align-items和justify-content Flexbox属性来居中侧边栏的文本内容。</p>
<h2 class="translated">结果是</h2>
<p class="translated">因此，这是基本的启动和运行信息，你需要跳进去，开始摆弄CSS网格布局模块的布局。有很多关于这是CSS布局工具的圣杯的宣传，但是到目前为止我仍然不相信。虽然在获得网格大师的地位之前，我还有很多东西要学——而且可能会出现一些我意想不到的奇迹——但从根本上来说，这是一个网格系统。</p>
<p class="translated">尽管我不得不说，希望网格的出现意味着，至少，我们可能永远不再需要漂浮任何东西，任何地方，永远不再。</p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
<title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>
</div>
</div>    
</body>
</html>