# 这样的例子不胜枚举:GitOps 的问题甚至更多

> 原文：<https://thenewstack.io/and-the-list-goes-on-even-more-problems-with-gitops/>

[Codefresh](https://codefresh.io/) 赞助本帖。

 [维克多·法西奇

Viktor Farcic 是 Codefresh 的首席 DevOps 架构师，Google 开发者专家和 Docker Captains 组的成员，也是一名出版作家。](https://www.linkedin.com/in/viktorfarcic/) 

GitOps 是一种新兴的管理系统实际状态的方法。但是，尽管 GitOps 作为一个想法很棒，我们甚至还没有接近让这个想法在实际意义上有用。还有很多工作要做。

在之前的两篇文章中，我探讨了许多关于 GitOps 当前实践的初始问题——比如它经常被认为是[管理 Kubernetes 部署的唯一方式](/the-problems-with-gitops-and-how-to-fix-them/)，以及 GitOps 原则[经常甚至不能应用于 GitOps 工具](/more-problems-with-gitops-and-how-to-fix-them/)。

在本帖中，我们将讨论没有良好模式的问题，以及连续交付(CD)和 GitOps 之间的联系。

## **没有成熟的模式**

GitOps 的一般原理众所周知，在此不再赘述。它们已经很好地建立起来了，尽管许多供应商试图“弯曲”它们以适应他们的产品。然而，没有很好定义的是实际的实现:

*   什么时候用推的机制比较合适，什么时候靠拉？
*   我们应该如何定义永久环境，它们应该不同于临时预览环境吗——比如那些与拉请求相关的环境？
*   环境应该如何组织？
*   我们应该为每个环境使用单独的存储库，还是依赖 monorepos，或者使用分支，或者完全不同的东西？
*   基于 Git 存储库变化的部署如何适应更广泛的连续交付管道？
*   什么时候我们应该让系统自己同步，什么时候我们应该使用手动确认？
*   我们应该在哪里进行这些确认？

诸如此类。有许多未回答的问题和相当多的“良好实践”有待定义。

我不能说没有人定义过任何“良好实践”但是大多数时候，那些实践被绑定到特定的实现，而这些实现在其他地方是不适用的。例如，Flux 就非常固执己见。这可以也应该被视为一套良好做法。但是它们在 Flux 之外的任何地方都不起作用。见鬼，除了那些从零开始的人，这些实践对任何人来说都是具有挑战性的。类似地，Jenkins X 在定义自以为是的工作流方面取得了相当大的进步，该工作流也可以被认为是一组最佳实践。然而，就像 Flux 一样，它未能定义一个除了 Jenkins X 内部以外的任何地方都可以遵循的“标准”,只有那些从零开始并且没有任何现有定义的人才能遵循。换句话说，它是如此的不灵活，以至于现有系统的团队不能使用它。

我们需要通用的 GitOps 模式，无论使用何种工具都可以应用；或者，更准确地说，工具可以在其上采用和创建自己的实现。

## **持续交付和 GitOps 之间的联系尚未建立**

我谅你也不敢创造一个遵循 GitOps 原则的持续交付管道。

现在，你可能会说这没什么大不了的。您甚至可以相对快速地创建一个。但是，如果你这样做了，很有可能要么不遵循 GitOps 的原则，是一个半生不熟的解决方案，需要重做几次，要么它会悲惨地失败，让你觉得自己很愚蠢。

问题是大多数 CD 管道不是基于 GitOps 原理，因为市场上的大多数工具都不是基于它们的。目前使用的大多数都是反方向的。大多数人认为管道应该直接与集群交互，或者依靠其他工具来实现。这是错误的。它与 GitOps 正好相反，GitOps 假设每次对实际状态进行更改之前都会对存储在 Git 中的期望状态进行更改。这意味着 CD 管道可以构建工件，创建发布，运行测试，以及完成许多其他任务。但是，当涉及到改变实际状态时，CD 管道应该将改变推送到 Git，而不是通过调用其他更专业的工具来直接或间接改变我们的系统。见鬼，管道不应该与集群交互，除了那些专门用于构建和运行测试的。

> 问题是大多数 CD 管道不是基于 GitOps 原理，因为市场上的大多数工具都不是基于它们的。

当试图将 GitOps 原则应用于 CD 管道时，您往往只能靠自己。您需要克隆环境仓库；添加、修改或删除文件。更改一些参数和自变量；创建拉式请求(PRs)或将变更直接推送到主线；诸如此类。所有这些都是可以脚本化的吗？当然可以。CD 工具应该为用户提供一种避免重复发明轮子的方法吗？绝对的。

不幸的是，除了少数例外，这是 CD 工具中所缺少的。它们不是围绕 GitOps 原则设计的，因此它们很难适应这些原则。

## **…这个清单还在继续**

不要认为我们已经解决了 GitOps 问题和误解。这个清单可能会持续一段时间，所以我会缩短它，只再提几个——比如大规模使用它的困难，将秘密融入 GitOps 原则的问题，等等。

我们前面的路还很长。自从这个想法出现以来，我们已经走了很长一段路，但是我们离最终的目的地还很远；我们甚至不确定我们是否走对了方向。这可能是时候按下重置按钮，重新开始，并根据我们的经验建立更好的东西。

## **GitOps 不好？**

所有这些是否意味着 GitOps 是个坏主意，或者我们还没有工具来实现它？一点也不。GitOps 是个好主意。早在 GitOps 这个术语被发明之前，它就已经存在了。

我们已经使用 GitOps 背后的原则很长时间了。在某种程度上，任何可以对 Git webhooks 做出反应或监控 Git 变化的工具都可以是 GitOps 工具，只要它使用来自 Git 的信息来改变实际状态。有太多的工具符合这种描述，所以我甚至不想尝试列出它们。

话虽如此，但仍有很大的改进空间。即使现有的工具可以用来应用 GitOps 原则，我们也可以并且应该努力改进它们。即使 GitOps 原则已经存在了一段时间，但仍然有很多可以改进的地方。

*如果你对 GitOps 和连续发货感兴趣，请尝试*[*code fresh*](https://codefresh.io/codefresh-signup/?utm_source=Blog&utm_medium=Post&utm_campaign=vfarcic-gitops-bad)*。你将获得终身免费的无限构建。*

通过 Pixabay 的特征图像。

<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 68 31" version="1.1"><title>Group</title> <desc>Created with Sketch.</desc></svg>