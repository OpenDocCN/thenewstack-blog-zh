# 六年后，Mesos 推出了 1.0 版本。现在真正的乐趣开始了

> 原文：<https://thenewstack.io/six-years-later-mesos-makes-version-1-0-now-real-fun-begins/>

去年的这个时候，威瑞森(许多人认为是北美领先的语音通信服务提供商)选择了 meso sphere DC/操作系统(当时还没有斜线)作为其数据中心服务的编排平台。因此，对于威瑞森和其他生活在财富 100 强上游稀薄空气中的中间层客户来说，这应该是一种安慰，Apache Mesos——商业 DC/OS 构建的平台——正式发布了最终的生产就绪版本 1.0。

那么，除了众所周知的鸡蛋计时器之外，Mesos 1.0 的声明实际上意味着什么吗？毕竟，Mesos 和来自 Mesosphere 的基于 Mesos 的商业产品已经进入了世界上的许多主要组织，而不仅仅是处于试验阶段。

“1.0 API 的引入真的会让所有运行在上面的框架受益，”Apache Mesos 的联合创始人 [Ben Hindman](https://twitter.com/benh?lang=en) 和 [Mesosphere](https://d2iq.com/) 的创始人兼首席架构师在接受 New Stack 采访时宣称。“因为我们引入了 1.0 API，Mesosphere 实际上将能够在框架上迭代得快得多。”

## 转换

在过去，对于 Mesos 以及历史上的许多其他软件平台，版本化的挑战一直围绕着依赖项的同步，包括库。新版本的平台通常会带来新的库，这些库会覆盖并取代旧的库。但是这种替代会对平台的旧版本产生不利影响，旧版本必须与新版本共存，尤其是在多租户环境中。

因此，Mesos 1.0 的重要之处在于，它将所有东西都打包成了一个更好、更紧凑的包。

“我们认识到，在如今的开源项目世界中，人们并没有真正很好地坚持版本化，”Hindman 说，“尤其是在 API 版本化方面。我们真的很想这么做。我们认为发布一个 API，并对其进行适当的版本化是非常重要的。我们已经看到开源领域的许多其他项目，包括容器领域和大数据领域，都滥用了这一点，这对用户和开发人员来说真是一个巨大的痛苦。”

Mesos 的新 HTTP API——Hindman 承诺，从这一点开始，将对[进行适当的版本化](http://semver.org/)——旨在使开发人员能够使用任何语言编写框架(Mesos 的术语，指在其平台上运行的应用程序)。以前，开发人员通常不得不使用为数不多的 Mesos 库之一[，其中一些是用 Go 编写的，但其他的是用更经典的语言，如 Java 和 C++。](http://mesos.apache.org/documentation/latest/api-client-libraries/)

具有讽刺意味的是，这使得数据中心有史以来最大的敏捷性催化剂之一的版本变更慢得令人痛苦。

因此，Hindman 和他的 Mesos 工程师同事们围绕 HTTP 开发了一个远程过程调用协议，类似于为 HTTP/2 开发的 [GRPC 协议](http://www.grpc.io/)。调用本身的语法要么是 [Google 的 **protobuf**](https://developers.google.com/protocol-buffers/) 要么是简单的 JSON。现在，发展 API 可以是一件更明智、迭代的事情。Hindman 说，Mesos 确实计划在未来的版本中直接支持 GRPC，因为“未来”可以划分为更多的近期区间。

“我认为最终，我们的想法是，在我们目前拥有的所有不同终端上，这是一个更加一致的 API，”Hindman 说，“这对我们的用户来说更好。我们只是想在称之为“1.0”之前推出它，不是因为 1.0 对我们来说是关于稳定性和成熟度的，而是因为它真的是关于用户的，在 1.0 到 2.0 的周期中，给他们一个他们会感到舒适的 API。”

## 统一集装箱

只有在像我们这样的行业里，某样东西才能被称为“集装箱”，而且很多从业者都知道它的确切含义。自从 Mesos 开始以来——在进化的规模上比 Docker 晚了很多很多周——它通过称为“容器”的 Mesos 组件完成了进程的划分。尽管从 0.20.0 版本开始，Mesos 提供了自己的容器，但它允许操作员用一个外部容器来代替。

“回到 2009 年我们刚开始的时候，集装箱化是我们正在做的事情的一个大前提，”Hindman 告诉我们。“我们的想法是，我们可以通过容器化技术实现轻量级资源隔离，这种技术存在于 Solaris 等设备中，在 Linux 中也逐渐成熟。因此，我们不得不“自己”进行容器化，在引用中，我们直接使用 Linux 的底层技术—控制组和名称空间—来容器化我们正在运行的应用程序。”

当 Docker 出现时，它引入了自己的容器化守护进程，随后很快推出了自己的容器映像格式。

“所以我们显然不会扔掉我们现有的所有容器化运行时，”他继续说道，“因为我们有一些用户无论如何都会继续使用它——苹果、PayPals、Netflixes 和 Twitters。我们不能只是说，'嘿，伙计们，你们现在都必须转移到这个 Docker 守护进程，因为我们将停止做容器化。'他们会奋起反抗的。"

因此，Mesos 增加了对 Docker 格式以及 CoreOS 的 appc 的支持，并计划在最终的 OCI 标准发布后立即支持它。在每一种情况下，Mesos 都不需要与格式相关的容器引擎的本地守护进程——他解释说，这可能是不确定的，因此难以自动化。Hindman 解释说，Mesos 1.0 在不调用外部容器的情况下正式支持 Docker 图像。

unified containerizer 的另一个新特性是能够在不关闭已经启动的容器的情况下关闭 Mesos 代理。他说，当升级 Mesos 或 DC/OS 时，这将被证明是有价值的，因为这个过程现在可以发生，而不需要关闭当前正在运行的任务。

还增加了嵌套容器支持——这意味着容器中的应用程序能够作为一个平台，在从属控制级别下旋转自己的容器。Hindman 指出，在 1.0 之前，Mesos 下的一个容器确实可以旋转另一个容器，但是作为一个*兄弟*。但这一进程开始带来严重的安全问题。

“从你开始引入兄弟容器的那一刻起，你就遇到了各种各样的架构问题，”他解释道，“包括诸如，如果你的容器死了会发生什么？你如何正确地知道清理兄弟容器？在这个同级容器中应该限制多少资源？如果你能任意启动兄弟容器，你能压倒机器吗？”

相比之下，嵌套容器只能访问授予父容器的相同资源。我们被告知，这将使[在容器](https://thenewstack.io/microservices-transforming-jenkins-cloud-platform/)中运行 Jenkins 的用例更加可行，也更加安全。

## 第二天

然后，Hindman 告诉我们一个主要的 Mesosphere 客户的故事，他采用了通用容器器，很快发现它不能在 Mesos 平台上部署它的一个应用程序——一个使用外部容器器和 Docker 守护进程运行得很好的应用程序。经过长时间的调试，Hindman 和他的同事们追踪到了这个客户使用的特定 Linux 发行版的内核。这个 bug 会阻止容器的正确创建，虽然它会将该消息报告给 Docker，但守护进程会忽略该报告并尝试执行容器。

Mesos 会让 Docker 乐意自己运行的同一个容器失败。虽然这个问题现在已经解决了，但 Hindman 说这次经历让他明白了两个平台在方法论上的不同。

“我们一直非常关注稳定性、正确性和资源隔离——这些是我们在大规模运行时真正关心的因素，”他说。“我认为 Docker 守护进程仍在不断成熟，所以你会在这样的例子中看到它。你可能会说你更喜欢 Docker 守护进程的体验，也就是“无论如何都要运行我的应用程序。”但这是其中的一件事，也许你让应用程序启动并运行，但后来当事情开始真正中断时会发生什么，然后你会想，'为什么会中断？我不明白！然后你意识到，哦，这是因为你没有被适当地隔离，所以你遇到了这个问题，而我们却提前发现了这个问题。

“我认为，一般来说，这是我们在 Mesos 社区中真正思考我们正在建设的东西的方式。我们真正考虑的是运营商，什么能给运营商最好的体验？”他说。

Hindman 将这种方法称为“第二天操作”，并向我们解释了纯配置驱动的自动化(如 Chef 和 Puppet 的原始风格)与通过 DC/OS 以及 Kubernetes 和 Docker Swarm 实现的更广泛的实时集群管理概念之间的差异。

“如果我们不只是转移部署责任，而是为运营商创造新的机会和新的增值，那就太好了，”他继续说道。“对我来说，我们需要的具体项目是第二天的操作。它实际上是在操作这些东西，不是在我们第一次部署它们的时候，而是在您想要升级它们、在您的集群中进行维护以及其他这些事情的时候。这是我们在构建集装箱化功能时真正仔细考虑过的事情。”

中间层是新堆栈的赞助商。

<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 68 31" version="1.1"><title>Group</title> <desc>Created with Sketch.</desc></svg>