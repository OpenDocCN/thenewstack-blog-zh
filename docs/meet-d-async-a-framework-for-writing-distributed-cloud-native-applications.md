# 认识 D-ASYNC:编写分布式云原生应用程序的框架

> 原文：<https://thenewstack.io/meet-d-async-a-framework-for-writing-distributed-cloud-native-applications/>

尽管无服务器平台已经在市场上出现了一段时间，但它最近才开始获得巨大的发展势头。许多人看到了这个想法本身的巨大潜力，许多人也认为无服务器对集装箱化是一个威胁。与此同时，许多人会同意，无服务器平台目前还不够成熟，不足以成为下一个继任者。让我们想象一下，无服务器是未来，它会是托管微服务和运行分布式工作流的最后一步吗？

也许现在回答这个问题还为时过早，然而，我的 D ASYNC 技术试图展示下一步的愿景。

## 抽象和专业知识

 [塞尔日·谢苗诺夫

Serge Semenov 是 D ASYNC 的创始人，这是他在闲暇时间对技术和创新的热情以及他努力为每个人改进和简化现有工具的结果。Serge 在 14 岁时开始了他的职业生涯，开发了一个照片级的光线跟踪 3D 渲染引擎，目前是 SkyKick Inc .的软件架构师，在那里他有机会与一个优秀的团队一起在一个激励人心的环境中工作，并设计云优先的大规模分布式应用程序。](https://github.com/tyrotoxin) 

开始为您托管物理服务器的公司迈出了非常重要的第一步，将计算单元的管理与使用分离开来，从而为最终用户创建了一个抽象层。这还不够，所以后来增加了新功能，使运行软件更加容易，如操作系统的自定义映像，各种“形状和大小”的虚拟机的动态分配，等等。

今天，我们有了容器、它们的编排和无服务器，所有这些都极大地简化了云应用程序的开发。然而，尽管有许多框架和服务可用，软件开发人员仍然很难从不同的组件构建内部分布式系统和微服务生态系统，这只是由于问题的复杂性。

这个任务不是工程师不能处理的，而是可以进一步优化，抽象出来，由专家处理，由其他公司作为服务提供。这就是 D ASYNC technology 介入的地方，它提出了如何达到下一个抽象层次的建议，旨在帮助软件开发人员更多地关注业务逻辑，并帮助公司以更低的成本更快地发展。

D ASYNC，其中 D 代表“分布式”，是一个使用通用编程语言编写云原生分布式应用程序的框架，仅使用其语法、面向对象编程范例和设计模式，其中函数被编译成有限状态机(“ASYNC”和“await”关键字)。目前的实现只支持 C#，下一个候选是 Python。

## 工作流程

大约 20 年前，在一台机器上进行并行编程并不现实，原因很简单，因为当时没有多核 CPU 来实现这一点。然后，我们必须构建定制的线程池，并将调度和运行工作项目的负担放到应用程序逻辑中。随着 C# 5.0 中 async-await 语法的引入，事情发生了巨大的变化，这使得异步编程变得“自然”(但不一定是最有效的)，隐藏了多核/CPU 系统的底层细节。为了实现这一点，一个“async”函数被编译到一个有限状态机(FSM)中，其中 FSM 的每个状态转换都可以作为一个工作项在一个线程池上进行调度。

分布式工作流系统做的事情几乎与一组“异步”功能相同——运行小步骤或工作项目(理想的幂等操作),其中不保证与特定流程或计算单元的相似性(与 async-await 相同，不保证在流程中的特定线程上执行)。分布式工作流框架还必须能够保存和恢复工作项的状态(输入、输出、上下文数据),以实现可伸缩性和弹性。

手动构建状态机可能非常困难、乏味、容易出错，理解包含大量代表状态转换的小函数的代码流并不容易，最重要的是，就像早期线程池的例子一样，它将意识到分布式环境的负担放到了应用程序逻辑中。

用 async-await 关键字构建状态机非常容易。如果观察 C#编译器如何生成状态机，您会注意到“await”关键字充当了状态转换之间的“分隔符”。

|  | 

异步 任务finitestatemachine 1()

{

//状态转换 1

等待finitestatemachine 2()；

//状态转换 2

}

 |

综上所述，如果您能够控制这种 FSM 的执行(等待前暂停，等待后恢复)，捕获并恢复暂停点的状态(包括输入参数和局部变量),那么您就可以构建一个框架，将您的“异步”功能作为分布式工作流运行。这是 D 异步技术概念的关键，尽管还有更多。

用 async-await 编写的函数自然属于事件驱动架构的范畴，这比现代微服务中实践的标准请求-响应设计有很多好处。另外，使用“await”语法(可能在 99%的情况下)会创建一个发布者-订阅者模型的特例，其中您正好有一个发布者(一个被调用的“异步”函数)和一个订阅者(调用“异步”函数的延续)。

## 微服务

D ASYNC 将接口和类描述为契约定义和微服务实现的候选者。

| 

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

28

29

30

31

32

33

34

35

36

37

38

 | 

//声明

//另一个服务可能是

//部署在不同的环境中。

公共 接口IFooService

{

任务Foo()；

}

公有 类bar service

{

私有IFooService_ fooService；

//另一个服务可以被

//作为依赖注入使用。所有对那个服务的调用

//都会被路由到那个

//具体部署使用其

//通信机制。所有回复

//都会被路由回这个服务。

//这就是依赖注入遇到

//服务发现和服务网格的地方。

publicbar service(IFooServicefoo service)

{

_ foo service=

}

公共 异步 任务 栏()

{

//简单调用另一个服务即可

//保存‘Bar’状态，

//‘Foo’预定执行。

//这种复杂性是隐藏的，以帮助你

//专注于业务逻辑。

恭候_ foo service。Foo()；

//执行‘Bar’的状态是

//在‘Foo’完成后恢复。

返回；

}

}

 |

代码本身没有什么引人注目或创新之处。然而，想法是将这种方法与用上述“异步”功能表达的分布式工作流相结合。因此，类上的方法不再仅仅是遵循请求-响应模型的相当小的例程的入口点，而是成为由事件驱动的服务交互机制管理的分布式工作流的一部分。

简单地用接口定义服务，并能够通过简单地注入依赖项来使用它们，将控制反转与服务发现绑定在一起，并成为应用程序代码的良好抽象层。这种服务可以独立发展和部署，但仍然形成分布式工作流。

在 C#中有例子并不限制这类微服务的使用。仅限基于. NET 或 D 异步的应用程序。您可以连接现有的使用请求-响应或其他事件驱动机制的应用程序，只要有一个通信契约就行，比如最近宣布的 CNCF 的 [CloudEvents 规范](https://github.com/cloudevents/spec)。

## 代码是抽象

到目前为止，仅仅描述概念来用代码表达分布式应用是不够的，但是该技术实现了更多的概念(参见我的 [D ASYNC syntax mapping](https://dasyncnet.wordpress.com/2018/05/04/dasync-syntax-mapping/) 帖子)，其他概念还在后面。即便如此，还需要另一个关键因素——将应用部署到云的持续交付管道。你只需将代码推送到一个版本控制系统，它就会自动部署，应用程序就会作为一个由微服务组成的分布式工作流运行(如 Azure Functions 上的 [D ASYNC 一文所展示的)。](https://dasyncnet.wordpress.com/2018/05/04/dasync-on-azure-functions/)

因此，具有特殊语法的应用程序代码本身成为无服务器平台(和/或容器或任何其他东西)之上的最终抽象层，它表达了应用程序应该如何运行，而无需完全了解宿主环境和用于使您的应用程序分布式的确切技术(以类似于 async-await 隐藏多线程复杂性的方式)。

## 又一个 RPC？不，谢谢

此时，你可能会想“又来了……这个 [RPC](https://en.wikipedia.org/wiki/Remote_procedure_call) 和 [CORBA](https://en.wikipedia.org/wiki/Common_Object_Request_Broker_Architecture) 和 [DCOM](https://en.wikipedia.org/wiki/Distributed_Component_Object_Model) 一起注定要失败。”如果你这样做了，暂停一分钟的想法。分布式计算很难，但是如果没有人试图让它变得更容易，它就永远不会变得容易。我们应该从过去的错误中吸取教训，而不是开出失败的处方。如果微服务仅仅是以前的[面向服务架构](https://en.wikipedia.org/wiki/Service-oriented_architecture)实现实践的再生，它们早就失败了。类似地，虽然 D 异步技术可能类似于 RPC 的一种形式，但在意识形态上它是另外一种东西，我将尝试简要地解释为什么。

任何框架的开发人员都试图通过提供高级接口和隐藏实现细节来使它尽可能易于使用。分布式工作流引擎也不例外，您可以找到许多 UI 工具，它们通常面向业务流程(例如，工作流定义存储在 XML 或 JSON 中)，或者面向软件开发人员公开其 API 的框架(应用程序代码本身通过使用 API 来定义工作流)。

无论您选择哪种方式，工作流定义和应用程序业务逻辑之间总会有一个界限，因为没有任何成熟的通用编程语言包含工作流定义语言。D ASYNC 技术填补了这一空白，使分布式工作流易于编写和理解，但它碰巧利用并重新利用了编程语言的现有语法(至少目前如此)来实现这一目标——这就是为什么该技术可能会成为另一个 RPC。但是由于分布式计算的[谬误，具有请求-响应模型的标准 RPC 无法工作，而“异步”功能意味着可能需要一些时间来完成，这是更好的，但仍然可能不可接受。](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing)

D ASYNC 不等待同一进程中“ASYNC”功能的完成，而是保存工作流的状态(为了弹性和伸缩性)并释放计算资源，这是 RPC 所做不到的。持久性部分允许将框架级别的故障与应用程序级别的故障完全隔离开来。也就是说，如果在执行引擎中出现异常，它将由引擎处理，并且永远不会“冒泡”到应用程序代码——不再有丑陋的错误处理程序与业务逻辑混在一起。如果应用程序代码引发异常，它将由应用程序中最近的“catch”语句处理。

这也适用于服务请求超时——相反，您应该在。NET 用于对时间敏感的操作—应用程序代码看不到任何超时异常。使用 D ASYNC，你[不用分发你的对象](https://martinfowler.com/articles/distributed-objects-microservices.html)，而是用与业务逻辑相同的编程语言创建一个工作流。

## 使用缺陷

你可能还会想，“如果我不知道‘异步’功能是否是工作流的一部分，我可能还是会陷入那些谬论中描述的麻烦。”这种说法绝对正确。再说一次，通用编程语言没有描述工作流的语法，所以你必须遵守一定的规则，首先使“异步”函数成为工作流的一部分。这肯定不是直观的，并且增加了相关问题的风险，但是有一些发展正在解决它——在工作流定义和它的业务逻辑之间画出一个清晰的可视边界并增加意识。

如果你熟悉 [LINQ](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/) ，你很可能知道不是所有的查询表达式都可以被查询提供者支持，这有时很难预料，除非你测试它。但这并不能阻止工程师使用它，因为它节省了开发时间，它只是方便而已。D ASYNC 可能会遇到类似的症状，这没什么——该技术不一定是完美和最有效的，但可以满足大多数情况，并且可以选择简单、方便和降低成本的技术。

## 项目状态

在 D ASYNC 能够展现其全部潜力之前，首先需要对无服务器平台以及编程语言本身和相关工具进行一些改变。这项技术有一定的好处，但可能不会提供特定的功能或满足一定的要求，以最好的方式处理所有的情况。然而，如果它可以降低 80%情况下的复杂性并节省大量工作，那就足以平衡其余 20%的复杂工作了。

d 异步为。NET 在 GitHub 上开源[，免费使用，并作为](https://github.com/Dasync/Dasync) [NuGet 包](https://www.nuget.org/packages?q=dasync)提供。目前的版本是预览版，但将保持快速增长，以达到生产级水平。

<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 68 31" version="1.1"><title>Group</title> <desc>Created with Sketch.</desc></svg>