<html>
<head>
<title>From Containers to Container Orchestration</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从容器到容器编排</h1>
<blockquote>原文：<a href="https://thenewstack.io/containers-container-orchestration/#0001-01-01">https://thenewstack.io/containers-container-orchestration/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">


<p class="translated"><a href="http://www.janakiram.com/" class="clearfix infoBlock " target="_blank"> <div class="infoBlockTextBlock"> <p class="infoBlockTitle">贾纳奇拉姆·MSV</p><p class="infoBlockText">贾纳奇拉姆·MSV是贾纳奇拉姆联合公司的首席分析师，也是国际信息技术研究所的兼职教员。他还是Google认证的云开发人员、Amazon认证的解决方案架构师、Amazon认证的开发人员、Amazon认证的SysOps管理员和Microsoft认证的Azure Professional。他之前的工作经历包括微软、AWS、Gigaom Research和阿尔卡特朗讯。</p> </div> </a></p><p class="translated">Docker平台和周围的生态系统包含许多工具来管理容器的生命周期。仅举一个例子，Docker命令行界面(CLI)支持以下容器活动:</p>
<ul>
<li class="translated">从注册表中提取存储库。</li>
<li class="translated">运行容器并可选地将终端连接到容器。</li>
<li class="translated">将容器提交给新映像。</li>
<li class="translated">将图像上传到注册表。</li>
<li class="translated">终止正在运行的容器。</li>
</ul>
<p class="translated">虽然CLI满足了在一台主机上管理一个容器的需求，但在管理部署在多台主机上的多个容器时，它就显得力不从心了。为了超越单个容器的管理，我们必须求助于编排工具。</p>
<p class="translated">编排工具将生命周期管理功能扩展到部署在机器集群上的复杂的多容器工作负载。</p>
<p class="translated">通过对主机基础架构进行抽象，编排工具允许用户将整个集群视为单个部署目标。</p>
<h3 class="translated">基线特征</h3>
<p class="translated">编排流程通常涉及工具，这些工具可以自动化应用程序管理的所有方面，从初始放置、调度和部署到稳态活动，例如支持扩展和故障转移的更新、部署、更新和运行状况监控功能。这些功能已经成为用户期望现代容器编排工具提供的一些核心特性的特征。</p>
<h3 class="translated">声明性配置</h3>
<p class="translated">流程编排工具为开发运维团队提供了一个选项，可以使用YAML或JSON等语言，在标准模式中声明应用工作负载及其配置的蓝图。这些定义还包含关于支持工作负载的存储库、网络(端口)、存储(卷)和日志的重要信息。这种方法允许编排工具多次应用相同的配置，并且总是在目标系统上产生相同的结果。它还允许工具在不同目标环境的开发、测试和生产的不同阶段接受相同应用程序的不同配置。</p>
<h3 class="translated">规则和约束</h3>
<p class="translated">工作负载通常对主机放置、性能和高可用性有特殊的策略或要求。例如，在同一台主机上提供主数据库容器和从数据库容器是没有意义的；这违背了初衷。同样，将内存缓存放在web服务器所在的主机上也是一个好主意。编排工具支持用于定义容器放置的关联性和约束的机制。</p>
<h3 class="translated">准备金提取</h3>
<p class="translated">供应或调度处理协商容器在集群中的放置并启动它们。此过程包括根据配置选择合适的主机。除了容器供应API之外，编排工具将调用特定于主机环境的基础设施API。</p>
<h3 class="translated">发现</h3>
<p class="translated">在由运行在多个主机上的容器组成的分布式部署中，容器发现变得至关重要。Web服务器需要动态地发现数据库服务器，负载平衡器需要发现并注册web服务器。编排工具提供或期望分布式键值存储、轻量级DNS或一些其他机制来实现容器的发现。</p>
<h3 class="translated">健康监控</h3>
<p class="translated">因为编排工具知道系统的期望配置，所以它们能够独特地跟踪和监视系统的容器和主机的健康状况。如果主机出现故障，这些工具可以重新定位容器。类似地，当容器崩溃时，编排工具可以启动替换。编排工具确保部署始终与开发人员或操作人员声明的期望状态相匹配。</p>
<h2 class="translated">深入了解三种流行的编排平台</h2>
<h3 class="translated">码头工人群</h3>
<p class="translated">Docker Swarm的目标是使用与核心Docker引擎相同的Docker API。Swarm透明地处理与Docker引擎池相关联的端点，而不是以代表一个Docker引擎的API端点为目标。这种方法的主要优点是，现有的工具和API将继续使用集群，就像它们使用单个实例一样。Docker的工具/CLI和Compose是开发人员创建他们的应用程序的方式，因此，他们不必重新编码来适应orchestrator。</p>

<p> </p>
<p class="translated">Docker Swarm带有几个内置的调度策略，使用户能够指导容器放置，以便最大化或最小化容器在集群中的分布。也支持随机放置。</p>
<p class="translated">Docker寻求遵循“包含电池但可拆卸”的原则，这意味着尽管它目前只附带了少量简单的调度后端，但未来它可能会通过可插拔的接口支持更多的后端。基于给定用例的规模和复杂性，开发人员或操作人员可能会选择插入一个合适的替代后端。</p>
<p class="translated">Docker Swarm支持约束和亲缘关系来决定容器在特定主机上的放置。约束定义了选择应该考虑调度的节点子集的要求。它们可以基于存储类型、地理位置、环境和内核版本等属性。亲缘关系定义了在主机上并置容器的要求。</p>
<p class="translated">为了发现每个主机上的容器，Swarm使用可插拔的后端架构，该架构与简单的托管发现服务、静态文件、IP列表、etcd、Consul和ZooKeeper一起工作。</p>
<p class="translated">Swarm支持基本的健康监控，防止在故障主机上提供容器。</p>
<h3 class="translated">库伯内特斯</h3>
<p class="translated">Kubernetes来自谷歌——一家声称每天处理20亿个集装箱的公司——享有独特的信誉。</p>

<p> </p>
<p class="translated">Kubernetes的架构基于一个主服务器和多个附属服务器。名为kubecfg的命令行工具连接到主服务器的API端点，以管理和编排附属服务器。下面是在Kubernetes环境中运行的每个组件的定义:</p>
<ul>
<li class="translated"><b> Master </b>:运行Kubernetes管理进程的服务器，包括API服务、复制控制器和调度器。</li>
<li class="translated"><b> Minion </b>:运行kubelet服务和Docker引擎的主机。奴才们接受主人的命令。</li>
<li class="translated"><b>kube let</b>:Kubernetes中的节点级管理器；它运行在一个奴才身上。</li>
<li class="translated"><b> Pod </b>:部署在同一个minion上的容器集合。</li>
<li class="translated"><b>复制控制器</b>:定义需要运行的箱或容器的数量。</li>
<li class="translated"><b> Service </b>:允许发现每个容器发布的服务/端口以及用于通信的外部代理的定义。</li>
<li class="translated"><b> Kubecfg </b>:与主服务器对话以管理Kubernetes部署的命令行界面。</li>
</ul>
<p class="translated">JSON文件中描述了服务定义以及规则和约束。对于服务发现，Kubernetes提供了一个稳定的IP地址和DNS名称，对应于一组动态的pods。当Kubernetes pod中运行的容器连接到这个地址时，源机器上运行的本地代理(称为kube-proxy)将连接转发到相应的后端容器之一。</p>
<p class="translated"><span>【cyclone slider id = " ebook-3-赞助商"】</span></p>
<p class="translated">Kubernetes支持用户实现的应用健康检查。这些检查由运行在每个minion上的 kubelet <span>执行，以确保应用程序正确运行。目前，Kubernetes支持三种类型的健康检查:</span></p>
<ul>
<li class="translated"><b> HTTP健康检查</b>:kube let将调用一个web端点。如果响应代码在200到399之间，则认为成功。</li>
<li class="translated"><b>容器执行</b>:kube let将在容器内执行命令。如果它返回“OK”，则认为是成功的。</li>
<li class="translated"><b> TCP套接字</b>:kube let将尝试打开容器的套接字并建立连接。如果建立了连接，则认为是健康的。</li>
</ul>
<h3 class="translated">阿帕奇Mesos</h3>
<p class="translated"><a href="http://mesos.apache.org/" class="ext-link" rel="external "> Apache Mesos </a>是一个开源集群管理器，它简化了在服务器共享池上运行任务的复杂性。Mesos最初旨在支持高性能计算工作负载，在0.20.0版本中增加了对Docker的支持。</p>

<p> </p>
<p class="translated">典型的Mesos集群由一个或多个运行mesos-master的服务器和一个运行mesos-slave组件的服务器集群组成。每个从模块向主模块注册以提供资源。主节点与部署的框架交互，将任务委托给从节点。以下是Mesos架构的概述:</p>
<ul>
<li class="translated"><b>主守护进程</b>:mesos-Master服务运行在主节点上，管理从守护进程。</li>
<li class="translated"><b>从守护进程</b>:mesos-Slave服务运行在每个从节点上，运行属于一个框架的任务。</li>
<li class="translated"><b>框架</b>:一个应用程序定义，由一个调度器和一个或多个执行器组成，调度器向主设备注册以接收资源提供，执行器在从设备上启动任务。</li>
<li class="translated"><b> Offer </b>:从节点的资源列表。每个从节点向主节点发送要约，主节点向注册的应用框架提供要约。</li>
<li class="translated"><b>任务</b>:框架调度的要在从节点上执行的工作单元。</li>
<li class="translated"><b> Apache ZooKeeper </b>:用来协调主节点集合的软件。</li>
</ul>
<p class="translated">与其他工具不同，Mesos使用Apache ZooKeeper确保主节点的高可用性，Apache ZooKeeper复制主节点以形成仲裁。高可用性部署至少需要三个主节点。系统中的所有节点，包括主节点和从节点，都与ZooKeeper通信，以确定哪个主节点是当前的主节点。主节点对所有从节点执行健康检查，并主动停用任何出现故障的从节点。</p>
<p class="translated">当Mesos与Marathon结合使用时，可以基于HAProxy TCP/HTTP负载平衡器启用服务发现，以及使用Marathon的REST API定期重新生成HAProxy配置文件的辅助脚本。或者，Mesos-DNS，一种基于DNS的服务发现机制，最近已经发布了测试版。</p>
<h2 class="translated">摘要</h2>
<p class="translated">集装箱生态系统正在迅速发展。从大型基础设施公司到PaaS供应商，再到早期创业公司，甚至在无服务器计算领域，每个人都在叫嚣着要在生态系统中占有一席之地。有许多致力于容器编排工具的贡献者，因为这些工具对于部署现实世界的应用程序是必不可少的，从而推动了Docker和容器的采用。我们试图强调构建流程编排工具的一些关键贡献者，但这不仅仅是显式流程编排工具，还必须了解构建、部署、CI/CD、PaaS以及流程编排者与之交互的其他工具，我们将在自动化和流程编排目录中详细介绍这些工具。</p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
<title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>
</div>
</div>    
</body>
</html>