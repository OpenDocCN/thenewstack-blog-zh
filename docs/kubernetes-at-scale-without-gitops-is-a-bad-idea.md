# 没有 GitOps 的大规模 Kubernetes 是个坏主意

> 原文：<https://thenewstack.io/kubernetes-at-scale-without-gitops-is-a-bad-idea/>

[](https://www.linkedin.com/in/madhuramaskasky/)

 [玛多拉·马斯卡斯基

玛多拉·马斯卡斯基在 Platform9 担任产品副总裁，领导公司的产品管理。在共同创建 Platform9 之前，Madhura 在 VMware Engineering 工作了七年，在那里她逐渐成为多个关键产品的技术主管，包括 vCloud Director、Update Manager 和 ConfigControl。Madhura 帮助带领 vSphere 转型为策略驱动的产品套件，并与各个团队广泛合作，共同实现愿景。Madhura 拥有斯坦福大学的计算机科学硕士学位，专攻数据库和分布式系统。](https://www.linkedin.com/in/madhuramaskasky/) [](https://www.linkedin.com/in/madhuramaskasky/)

随着 Kubernetes[环境开始扩展，跨多个环境或多个云一致管理集群配置的问题会变得很困难。由不同团队部署的集群可能无法满足或共享对整体治理和安全性至关重要的节点大小、自动扩展、网络或 RBAC 策略的相同配置，至少在最初是这样。因此，所需的群集配置无法在不同的群集之间完全复制。当然，手动识别漂移并在不同集群扩展时保持一致性不是一个可行的替代方案。](https://platform9.com/blog/kubernetes-deployment-the-ultimate-guide/)

DevOps 团队应该能够使用一组描述集群理想状态的策略管理模板来解决这些一致性挑战。模板应该允许 DevOps 团队为集群创建基于标准的定义，然后通过单个界面以最小的工作量在所有集群中复制这些定义。

在本文中，我们描述了企业在大规模部署 Kubernetes 集群时面临的问题和挑战。我们还描述了 GitOps 流程和工具如何允许组织获得对这些高度分布式环境的适当控制，同时改进安全性和合规性最佳实践。

## 管理挑战和集群蔓延

向虚拟化的转变带来了虚拟机蔓延的问题，部署的虚拟机数量之多使得有效管理虚拟机变得不可能。集装箱化和 Kubernetes 的广泛使用产生了企业必须处理的类似问题。

现在，随着大型分布式团队在其本地工作站、数据中心、公共云、边缘站点以及有时在最终客户站点的内部调配多个 Kubernetes 集群，企业经常必须应对集群和工作负载激增的混乱环境。

使用 Kubernetes 环境的企业 IT 必须确保由内部和现场团队启动的集群符合并遵守组织范围的策略。为面向最终用户的应用程序部署而创建的群集必须特别小心地进行监控，不得偏离预期的配置。然而，集群蔓延和云原生基础架构的碎片化使得实施全局策略变得尤为困难。

## 配置蔓延

Kubernetes 以其声明式 API 而闻名:集群中的每个组件，从配置设置到应用程序，无论多小，都是通过一个名为 resource 的配置片段进行配置的，通常表示为 YAML 文件。这意味着完整地描述和配置一个集群可能需要创建和维护数十或数百种不同的资源，从而导致管理上的噩梦。在这些资源上引入额外的抽象和特性(例如，模板)的工具过多，如 Jsonnet、Helm 和 Kustomize，会加剧这个问题。

## 宠物集群

在虚拟化时代，拥有“宠物”虚拟机是不可避免的，这种大型整体式虚拟机难以升级或维护，并且会产生容错瓶颈。Kubernetes 和 containers 领域也出现了类似的问题:随着企业开始大规模部署集群，拥有一些大型“宠物”集群开始成为一个普遍问题。这些集群有时可能有多达 1，200 个节点。

这种规模的集群必须分成多个节点组，每个节点组都需要自己的管理和维护。随着集群节点数量的增加，集成到集群中的 CNI 插件和其他解决方案可能会开始中断或出现意外行为。更好的解决方案是拥有大量的小型集群，每个集群都是为一个用例专门构建的，然后拥有更好的整体自动化来大规模管理集群。这解决了必须管理 pet 集群的问题，但反过来又产生了必须管理大量集群的新问题。这就是 GitOps 风格的自动化真正能够增加价值的地方。

## Kubernetes 中的期望状态管理

Kubernetes 的最大优势之一是它的声明式系统，该系统为在其范围内运行的所有应用程序处理所需的状态管理。当属于副本集的 Kubernetes pod 被删除时，Kubernetes 控制器会将正在运行的 pod 的数量与 pod 部署规范进行比较。系统会自动安排一个新的 pod 来维护所需数量的副本。管理员监督所有 Kubernetes 资源的生命周期，比如部署、状态集、作业等。

> 默认情况下，Kubernetes 没有一种机制来监视集群本身及其属性的变化，并自动协调状态。这就是 GitOps 的用武之地。

在后台，工作负载状态在 etcd 中维护，etcd 是 Kubernetes 的默认键值数据库，它是部署在集群上的资源配置的唯一真实来源。etcd 数据库维护工作负载的配置定义和当前状态。如果出现差异，kube 控制器管理器负责重新创建与原始定义相匹配的资源。

然而，默认情况下，Kubernetes 没有一种机制来监控集群本身及其属性的变化，并自动协调状态。例如，如果删除了整个名称空间，Kubernetes 不会重新创建名称空间或其中的对象。Kubernetes 的这一缺点正是 GitOps 的用武之地。

## 用于有效集群管理的 GitOps

GitOps 是一个可操作的框架，它使用源代码管理和 CI/CD 的中央存储库，围绕版本控制和源代码管理采用标准的开发最佳实践，并将其扩展到基础设施的管理。

在多云和多集群环境中，GitOps 是一个非常有价值和有效的流程，可以自动化 Kubernetes 集群和周围基础设施的配置管理、部署、更新和策略管理。

当使用 GitOps 原则大规模运行集群时，DevOps 团队不是在用户的工作站、客户站点、开发/测试/生产环境之间手工制作集群，而是将一组集群资源标准化，表示为 YAML、Kustomize 或 Helm(或组合)，这些资源可以分组到“模板”中；每个模板捕获特定类型集群的期望状态属性。期望的状态属性可以是关于集群的形状和大小、主节点和工作节点的数量、要在集群中部署的附加组件、要实施的网络和安全策略等等。模板存储在 Git 存储库中，这个存储库是存储所有配置的专用存储库。对模板的任何更新都会被版本化，这从治理和法规遵从性的角度来看是有帮助的。

## 灵活执行

只有当有一个执行引擎可以确保集群的实际状态始终与 Git 中描述的期望状态一致时，让模板来捕获集群的期望状态才有用。实施引擎应该允许使用模板中描述的属性创建新的集群，以及固定现有的集群以符合模板。

让我们以针对您的 Kubernetes 集群的 RBAC 策略管理为例，说明如何在 Kubernetes 环境中实现有效的基于模板的管理和实施。

Kubernetes 的好处之一是能够使用一个简单的命令行工具——kubectl——大规模地配置和管理集群。然而，让所有开发和运营团队成员——从自由职业的开发人员到 CTO——都能够访问 kubectl 来管理集群，这并不是一个理想的场景。最理想的是有一个易于使用的机制来为跨不同集群的用户配置 RBAC 策略，以精确地定义他们的访问级别。

然而，默认情况下，管理 Kubernetes RBAC 策略是复杂的。Kubernetes 迫使用户筛选编辑和更新各种 YAML 文件的复杂性，以正确配置和更新 RBAC 政策。许多(如果不是大多数的话)商业 Kubernetes 解决方案没有提供一种替代方案来显著地大规模简化该过程。

我们上面描述的 GitOps 风格的模型可以极大地简化这个过程。在这个模型中，DevOps SRE 工程师定义了一个或多个“RBAC 模板”,这些模板在名称空间或集群范围内捕获 Kubernetes 用户角色和角色绑定。RBAC 模板一旦定义，就可以应用于一个或多个集群，以便为一组用户授予对这些集群的适当访问级别。

“RBAC 模板”以声明的方式存储在您的 Git 存储库中，并且以不可变的方式存储，而不强迫用户访问 YAML 文件。一旦执行引擎被指示将集群与存储库(以及通常存储库中的路径)相关联，存储库路径的内容就定义了应用于集群的 RBAC 设置的“真实来源”，然后定期进行同步以确保它们随着时间的推移而继续被执行。

一个合适的系统不仅必须实施一个新的基本状态，还应该能够在请求被批准并合并到期望的状态之前对提交的请求进行测试。在 Git 上达到最终的、不可变的状态的过程是迭代的，并且保持了灵活性，因此它不仅执行策略，而且促进了变化。它还应该提供对 Git 和集群上的所有合并请求和变更的完整审计跟踪——这是 Git 的优点之一。

## 不明白这个意思

轻松无缝地审计对集群所做的可能与 Git 存储库上的配置不同的更改的能力是至关重要的——称为“漂移”如上所述，正确实现的模板系统应该提供“漂移分析”，其中系统可以通过单个命令来确定并报告部署的集群与模板中捕获的期望状态之间是否存在差异。当发生变更时，应根据变更的严重性和重要性向相关运营负责人发送警报。

使用 [Flux](https://github.com/fluxcd/flux) 或 [Argo CD](https://github.com/argoproj/argo-cd) 时，当 Kubernetes 中的特定对象发生变化时，可能会发生漂移——例如，无论是管理员无意中造成的，还是在网络攻击的过程中。集群配置策略和其他设置已被覆盖(而不是在 GitHub 上手动更改，然后在集群级别更改)。

因此，所有的更改都应该首先在 Git 中进行，然后再推广到生产环境中，这样 Git 和集群中的配置才能保持一致。Git 的状态代表不变的“真实的单一来源”,也是云原生安全性和合规性的主要组成部分，例如，通过满足萨班斯-奥克斯利法案定义的此类要求。

这个过程不应该涉及的是一行一行的手工检查，以确定声明定义和运行的资源是否不同。如果发生了漂移，应该会自动识别对群集所做的更改。集群配置将不再符合 Git 中定义的状态，因此使用正确的工具，可以自动识别补救更改并将其应用到集群，同时发送警报。换句话说，配置漂移应该总是显而易见的，并且是系统的一个重要方面。

## 阈值起点

可以手工制作和管理单个或少量集群的配置。然而，当试图一致地手动管理 10 个或更多 Kubernetes 集群时，这种痛苦变得显而易见，尤其是当单个集群的规模很大时。

可以说，如果没有 GitOps 工具和流程来支持大规模集群的配置管理和实施，小型 DevOps 团队尝试管理多集群环境是不可行的。客观地说，多集群环境可以很容易地由 50 多个名称空间和多个团队访问的无数微服务组成。

如上所述，GitOps 工具和流程已经成为解决组织在大规模部署集群时面临的许多管理、安全性、合规性和其他挑战的最终方法。通过帮助消除“宠物集群”、漂移、缺乏集中控制的集群蔓延、缺乏标准化以及其他快速消耗开发运维资源和 sap 生产力的问题，GitOps 成为一个必要的运营框架。GitOps 为 CI/CD 提供的以 Git 为中心的管理和集中控制还可以通过自动化许多原本由运营甚至开发团队成员负责的任务来提高生产率。

最终，GitOps 作为一个框架，利用了 Kubernetes 最初创建的目的:为部署在多个高度分布式容器化环境中的应用程序提供显著的计算优势、资源节约和兼容性。

<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 68 31" version="1.1"><title>Group</title> <desc>Created with Sketch.</desc></svg>