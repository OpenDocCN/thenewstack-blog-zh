<html>
<head>
<title>Kubernetes Chief: We Back Docker, Although appc Might Have Merit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes酋长:我们支持Docker，虽然appc可能有优点</h1>
<blockquote>原文：<a href="https://thenewstack.io/kubernetes-chief-we-back-docker-although-appc-might-have-merit/#0001-01-01">https://thenewstack.io/kubernetes-chief-we-back-docker-although-appc-might-have-merit/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">


<p class="translated">谷歌上周宣布支持CoreOS努力成为一个新兴的容器规范appc T1的维护者。旨在使容器能够承载多个流程，这似乎是对<a href="https://github.com/appc/spec/blob/master/SPEC.md#app-container-image" class="ext-link" rel="external "> CoreOS的大胆宣言</a>的认可，因为容器可以更紧密地与Kubernetes对集群的支持保持一致。</p>
<p class="translated">周一，Kubernetes领导人兼谷歌集团产品经理Craig McLuckie的博客文章彻底抹杀了T4的这一表现。在这篇文章中，McLuckie重新表述了谷歌对appc的支持，从“Kubernetes项目的一个重要里程碑”(他上周称之为“T8 ”),到“我们可能会在未来的某个时候……引入”谷歌容器引擎。</p>
<p class="translated">“我们宣布获得AppC和RKT支持的意图是将Kubernetes(我们的开源项目)打造成容器世界的中立阵地，”McLuckie写道，他指的是CoreOS的容器系统新品牌，以前称为Rocket。</p>
<p class="translated">“客户应该能够仅仅根据其技术优点来选择他们的容器运行时和格式，我们确实认为随着技术的成熟，AppC提供了一些合理的潜在优点，”他继续说道。“不知何故，这被误解为‘a对b’的选择，这是完全不真实的。有了选择，世界几乎总是变得更美好，不同的工具可以用于不同的目的，这是非常自然的。”</p>
<p class="translated">McLuckie最后称赞Docker Inc .使容器技术“民主化”，并重申Google计划“无限期地”支持Docker标准。</p>
<p class="translated">谷歌产品经理的声明正式表明了他的观点，这一观点最早出现在<a href="https://twitter.com/cmcluck/status/595313016410738688" class="ext-link" rel="external ">5月4日，当时他在推特</a>上写道:“很难过rkt/Docker在<a href="https://twitter.com/kubernetesio" class="ext-link" rel="external "> @kubernetesio </a>上的支持被视为非此即彼:</p>
<blockquote><p class="translated">肯定是两者都有。rkt/appc 很有前途，但是Docker有真正的吸引力。</p></blockquote>
<p class="translated">在周一的博客帖子之后，麦克卢奇补充了这条推文:</p>
<blockquote><p class="translated">最近一直在为不必要的闹剧难过。</p></blockquote>
<h2 class="translated">重置里程碑</h2>
<p class="translated">上周，CoreOS首席执行官Alex Polvi将谷歌的Tim Hockin与Red Hat的Vincent Batts和Twitter的Charles Aylward放在一起，不仅作为appc的官方维护者和合作者，而且作为Polvi描述的单一、通用容器标准的支持者。</p>
<p class="translated">Polvi写道:“在推出appc后的几个月里，我们已经看到通用应用容器规范背后的采用和支持在快速增长。”“这些公司和个人正走到一起，以确保应用程序容器有一个定义良好的规范，为确保堆栈之间的安全性、开放性和模块化提供指导方针。”</p>
<p class="translated">但是波尔维从来没有暗示过他相信<strong> appc </strong>会在Kubernetes中取代Docker的<strong> libcontainer </strong>。所以，没有任何一个重要人物提出过这样的观点:在今天使用Docker的开源生态系统中，<strong> appc </strong>将会取代Docker。</p>
<p class="translated">也就是说，谷歌对appc的支持不仅仅是口头上的，确实是对CoreOS的一个赌注。仅仅因为你赌了不止一匹马，并不意味着你不是一个赌徒。</p>
<p class="translated">此外，虽然许多开源生态系统在“民主化”的前提下取得了成果，并让客户选择正确的组件，但在某种程度上，客户会遵从某人关于“正确的组件”是什么的判断。这就是为什么这个问题远远不止是一个关于规范文档语法的小冲突。</p>
<p class="translated">新兴的<strong> appc </strong>格式选择的分发机制将是Quay.io，CoreOS于去年8月收购了它。正如CoreOS的Polvi在本月早些时候告诉新堆栈的那样，Quay.io不是appc容器的“默认注册表”,就像Docker Hub是Docker容器的默认注册表一样。尽管如此，Quay是一个独立的生态系统，其所有者目前声称，不应该有一个单独的默认集装箱图像分发中心。</p>
<p class="translated">谷歌的人应该对这个观点非常熟悉。“我们选择‘市场’而不是‘商店’这个词，因为我们觉得开发者应该有一个开放和无障碍的环境来提供他们的内容，”这是谷歌的朱立伦在2008年提出的支持开放独立的安卓市场的论点——一个服务的名字，尽管朱棣文提出了这个论点，但还是被改成了。</p>
<p class="translated">在周二下午对新堆栈的一份声明中，CoreOS首席执行官Alex Polvi对McLuckie的帖子做出了如下回应:</p>
<blockquote><p class="translated">我们相信这篇文章是在说，这个世界因为有选择而变得更好，而且appc 确实有优点。</p></blockquote>
<p class="translated">Polvi继续说道:“<strong> appc </strong>社区坚信，用户需要基本的安全功能，以及一个可以由各种供应商共享的标准运输容器。“我们认为这是用户想要的，也是他们成功使用容器所需要的。我们看到,<strong> appc </strong>方法与各种软件社区——包括Kubernetes产生了牵引作用。”</p>
<h2 class="translated">红帽不是旁观者</h2>
<p class="translated">对许多企业来说，技术上的“开放”并不意味着容忍不同的标准，而是坦率地讨论单一标准的可能性。由于开源开发者至少据称是<em>开放的</em>，企业客户可能会认为，如果这些开发者未能共同努力，为实现符合每个人最大利益的目标制定一个单一的、通用的标准，那么一定有一个很好的理由。</p>
<p class="translated">这是红帽战略高级总监Lars Herrmann周二在温哥华OpenStack峰会上的观点。</p>
<p class="translated">“作为一个行业，我们有机会通过集装箱化来达成一个单一的格式，并使它为每个人服务，”赫尔曼告诉新的堆栈，“而不是将其分割成不同的格式。因为这只会产生大量的冗余和多余的工作，却没有任何好处。我们已经在格式层面忍受这种分裂很久了。现在我们有机会克服这一点。”</p>
<p class="translated">Herrmann指出，<strong> appc </strong>和Docker的<strong> libcontainer </strong>之间的差异远不止语义上的，这引发了关于Docker的守护进程是否应该负责启动进程而不是CoreOS所依赖的<strong> systemd </strong>的争论。Herrmann承认，Docker的设计选择确实使容器更难管理，也更难利用其安全性。他说，正是因为这个原因，Red Hat指派了一名工程师负责appc规范。</p>
<p class="translated">“理想情况下，我们真的希望让社区明白如何一起工作，而不是相互对抗，”Herrmann说。“我们真的不认为我们需要另一种形式。”</p>
<p class="translated">尽管Red Hat是systemd的主要作者之一，他继续说道，“我们认为仅仅从Docker守护进程基础设施转换到systemd还不足以抛弃同质的、统一的格式。我们真的鼓励社区一起工作。这就是我们两者都参与的原因。”</p>
<p class="translated">在新的一期节目中，我们将会看到更多关于赫尔曼的采访。</p>
<p class="attribution translated">CoreOS和Red Hat是新堆栈的赞助商。</p>
<p class="attribution translated">通过Flickr Creative Commons<a href="https://www.flickr.com/photos/photographingtravis/16359934852/in/photolist-oFMN3a-qVEWEh-oY2ctt-pWiih4-pWB3Hj" class="ext-link" rel="external ">获取专题图片。</a></p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
<title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>

</div>
</div>    
</body>
</html>