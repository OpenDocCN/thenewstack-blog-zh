# Apcera NATS 公司转向持久性实时信息流

> 原文：<https://thenewstack.io/apcera-nats-moves-real-time-message-stream-brokering/>

在开源领域，尤其是在“大数据”领域，分布式系统越来越多地受到 Apache Kafka 等[数据流消息代理](https://thenewstack.io/apache-streaming-projects-exploratory-guide/)的驱动，这些代理将比任何单台机器的存储容量都大的数据引入企业河流。

通过这样做，这些架构为其流数据引入了一个新的有价值的特征: *[持久性](http://kafka.apache.org/documentation.html#persistence)* ，本质上是通过让操作系统利用大型快速内存池作为其磁盘缓存。

现在，Apcera NATS 消息平台已经扩展到处理这种大量的实时数据，并提供所需的持久性。

直到这个版本，“NATS 缺少的东西，尽管它的性能、简单性和易用性都很好，却是坚持，”Apcera NATS 产品经理 Larry McQueary 承认道。“如果你看看我们在企业消息传递中了解到的，有一件事是你肯定需要持久化数据，以便进行事务性处理，同时维护事件历史，以便重新捕获和重新创建应用程序状态，用于故障排除、恢复目的，或者可能用于分析目的，正如我们所看到的，这在今天的大数据、快速数据和事件处理中非常普遍。”

麦克奎里说，Apcera 认为，NATS 加入这场运动，不需要重新发明轮子或创造另一个新的复杂系统。相反，公司工程师的目标是以各种方式促进事件流的重放，同时保持 NATS 的本地发布/订阅模式。

NATS 流是他们工作的高潮。这是 7 月初推出的 NATS 客户端，覆盖了基本的 NATS 客户端。从那里，它用自己的协议覆盖 NATS 传输，在这个过程中添加流和重放功能。消息继续使用基于文本的原语和二进制有效载荷，尽管流补充最终比 NATS 典型的“自由形式”有效载荷更加结构化，正如 McQueary 所描述的:

*“我们在基本的 NATS 客户端协议上覆盖了一个简单但结构化的 [protobuf](https://developers.google.com/protocol-buffers/) 消息。基本 NATS 是使用发布/订阅的实时消息的开/关流。客户端使用非常简单的发布 API 机制发布一个数据 blob，这个 blob 可能是文本、文件的一部分或者某种状态信息。它被发布到 NATS 服务器——基于 Go 的 NATS 守护进程，NATS 内部的消息路由器。它可以集群化，并具有高可用性和容错性。但是流过的信息流都是实时的。我们称之为“发射并忘记”模式；有些人称之为“喷雾祈祷””*

## Apcera 和 NATS

在 Apcera 创始人[德里克·科利森](https://twitter.com/derekcollison)围绕着他建立的公司建立容器中转平台之前，他为互连的分布式系统设计和构建消息传递系统。打个比方，科利森发明了很多将云平台结合在一起的粘合剂——最令人难忘的是云铸造。实际上，Apcera 的首席执行官负责发明一个很好的基础设施，支持我们所说的现代数据中心中的“新堆栈”。

早些时候，科利森为 TIBCO 创建了一个名为 Rendezvous 的中间件平台[，这是一种开发人员使用通用语言，使用简化的发布/订阅(“pub/sub”)模型来构建事件驱动的应用程序的方式。这是一种松散但足够可靠的连接，其中消息被广播，并且各种订户可能期望在将来的某个时间接收事件消息。最初，他使用 UDP 作为系统的传输协议来传输*多播*消息，从一台主机发送到一系列接收者——为所有那些接收者(或者至少是尽可能多的接收者)触发一个极其复杂的路由和重路由过程来获取他们的消息。](http://www.tibco.com/products/automation/enterprise-messaging/rendezvous)

> 为了让 NATS 加入这场运动，Apcera 决定不需要重新发明轮子或创建另一个新的复杂系统。相反，公司工程师的目标是以各种方式促进事件流的重放，同时保持 NATS 的本地发布/订阅模式。

然后他想到，随着越来越多的网络开始快速跟踪具有最高流量级别的数据包，他们将 TCP 数据包优先于 UDP 数据报，这仅仅是因为 TCP 是网络的主干。最终，强力发送消息更有意义——例如，通过 TCP 向单个接收者重复发送 30 条消息，而不是通过 UDP 向同一组 30 条消息发送一条多播消息。

所有这些工作最终以 [NATS 而告终，这是一个分布式工作负载的消息代理](https://thenewstack.io/demonstrating-nats-apceras-simple-high-performance-messaging-system/)在彼此之间传递数据。最初是用 Ruby 编写的，后来科利森重写了 Go 的消息传递核心，以提高性能。

## 偏移和耐用品

通常，在发布消息时，订户必须连接到 NATS。客户端只过滤那些它们订阅了主题的消息流。这不同于消息队列模型，例如 [RabbitMQ](https://github.com/rabbitmq/) ，发布者按顺序发布消息，而客户端在任何时候找到消息时，都以相同的顺序检索它们。正如麦克奎里指出的那样，这使得 NATS 更适合于信号和实时事件处理(RTEP)等任务。

但是增加持久性给了 NATS 一个 RabbitMQ 和它的对手们最初认为是优势的好处:例如，能够调出历史，回顾过去，作为一个订阅选项。像阿帕奇卡夫卡一样，NATS 流媒体引入了*偏移*的概念，这是一个简单的指针，可以启动回看，也可以保持一个人最后观看的位置供以后使用——后一种用例，借助于一个称为*耐用*的功能。

“在大多数消息传递系统中，您可以在自己的代码中做任何您想做的事情。你的客户可以记录很多不同的东西。麦克奎里解释说:“不过，当你试图跟踪的是你无法控制的东西，比如数据流时，这有时会很麻烦。

因此，耐久性能使 NATS 流服务器跟踪数据流中任何最新确认的消息，而不是强制客户端跟踪它接收或确认的最后消息。这样，如果客户端碰巧断开一段时间(可能是长时间中断，或者是广域网上的网络中断)，当客户端重新连接时，它确实需要立即从中断的地方恢复，而不必跟踪该信息本身。耐久允许客户端订阅该主题，并且使用上次订阅时使用的相同耐久 ID，服务器将开始向该客户端发送消息，从上次确认后的最后一个序列号开始。

最初，NATS 不承认确认(或者数字通信人们称之为“确认”，只有一个音节)。尽管 TCP/IP 确实在其握手序列中使用 ACK 来建立接口连接，但是 HTTP——位于 TCP/IP 之上的 Web 协议——是一种无状态协议，不依赖于来自 Web 浏览器的确认。它假设 TCP 已经处理了底层连接。因此，很难在本质上利用 HTTP 的协议上构建确认系统。

NATS 流在消息服务层添加了 NATS 一直缺少的确认协议。这给了 NATS 以前没有的东西:交货保证。尽管 NATS 自己只能提供 T2 的德里克·科利森承认的“最多一次”交付(T3)(换句话说，当然不是复制)，NATS 流媒体现在可以提供“最少一次”交付(T5)。

“对于一个主题的任何给定消息，以及该主题的任何合格订户，”Apcera 的 McQueary 描述道，“每条消息将至少被传输到该客户端一次，在某些情况下会被传输两次。但是，因为我们将这些邮件标记为重复邮件，大多数应用程序会对此感到满意，因为他们能够接收所有邮件并忽略重复邮件，而不会错过订阅的任何邮件。”

## 捆绑什么和如何捆绑

目前，Apcera 的计划是避免将 NATS 流媒体嵌入 NATS 的主要服务器。“我们真的想让 NATS 尽可能简单，”麦克奎尔里说，“并抵制把书中的每一个功能都加入其中的冲动，让它成为核心平台的一部分。”他引用了 [Apache ActiveMQ](http://activemq.apache.org/) (在向他在那个项目中工作的朋友致以应有的敬意之后)作为一个项目的例子，这个项目以一个崇高的目的开始，但是在他看来，它承担了太多的目标，结果是功能过载。

出于这个原因，他解释说，NATS 流媒体将不会与 NATS 捆绑或集成，尽管 NATS 流媒体现在与嵌入式 NATS 服务器一起发货，直接加载到流媒体进程中。

McQueary 认为 NATS 流的最佳用例候选是“任何需要处理可能实时发生的事件或从数据源重播的事件，以重建特定系列事件的状态或进行时间序列分析之类的事情的应用程序”，以及“任何需要进行控制平面类型处理的应用程序”，后者是对使用 Kafka 的[网飞微服务架构](https://www.infoq.com/news/2016/03/netflix-keystone-data-pipeline)的参考。

今天，Kafka 几乎和实时消息代理同义。NATS 流媒体是否在这一领域取得了进展，并在与卡夫卡相同的句子中被提及，可能在很大程度上取决于 Apcera 的集装箱化平台在涉及 Docker 的对话中利用的相同因素:[其自身工艺的质量](https://thenewstack.io/intro-to-apcera-community-edition/)。

<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 68 31" version="1.1"><title>Group</title> <desc>Created with Sketch.</desc></svg>