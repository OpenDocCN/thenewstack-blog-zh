<html>
<head>
<title>A Look at SCONE: Secure Linux Containers in Untrusted Environments with Intel SGX</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">看一看SCONE:使用SGX在不可信环境中保护Linux容器</h1>
<blockquote>原文：<a href="https://thenewstack.io/look-scone-secure-containers-linux/#0001-01-01">https://thenewstack.io/look-scone-secure-containers-linux/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">


<p class="translated">对于云中敏感的容器化工作负载，良好的安全实践不仅需要防范外来入侵，还需要防范云系统本身的超级用户。您的云提供商有史努比管理员吗？还是马虎的保安？或者只是法规遵从性比你自己的更宽松？</p>
<p class="translated">正是这种担忧促使一组研究人员创建了<a class="utm-none ext-link" href="https://www.usenix.org/system/files/conference/osdi16/osdi16-arnautov.pdf" rel="external "> SCONE </a>(英特尔SGX上的安全Linux容器)<a href="https://www.usenix.org/conference/osdi16/technical-sessions/presentation/arnautov" class="ext-link" rel="external ">在去年的<a href="https://www.usenix.org/conferences/byname/179" class="ext-link" rel="external "> USENIX操作系统设计和实现研讨会</a>上展示了</a>。该架构提供了一种方法，通过使用内置于该公司基于<a href="https://ark.intel.com/products/codename/37572/Skylake" class="ext-link" rel="external "> Skylake </a>架构的芯片中的<a href="https://software.intel.com/en-us/sgx/details" class="ext-link" rel="external ">英特尔SGX </a>(软件卫士扩展)，在不可信的云服务上运行容器化的可信应用。集装箱本身装有与SGX接口的软件。</p>
<p class="translated">虽然SCONE似乎提供了一个可行的解决方案，但让SCONE部署工作并正确工作可能是一项艰巨的任务，仍然不能提供完全的安全保护，微软Azure工程师和著名的容器安全专家Jess Frazelle最近在纽约市举行的<a href="http://paperswelove.org/" class="ext-link" rel="external "> Papers We Love </a>活动中谈到USENIX论文时指出。</p>
<p class="translated">“在实现这一点的过程中，用户需要处理很多事情，这使得实现起来非常困难。而且很难做好，”弗雷泽勒警告说。</p>
<p class="translated">尽管如此，这项技术还是值得一看。上个月，微软Azure <a href="https://azure.microsoft.com/en-us/blog/introducing-azure-confidential-computing/" class="ext-link" rel="external ">开始提供</a>可信执行环境(TEE)，也称为“飞地”，阻止除授权代码之外的任何人访问数据，包括主机服务器固有的任何超级用户权限。可以想象，在Azure上使用SCONE进行受保护的操作是可能的。</p>
<p class="translated">TEE通过受SGX保护的服务器内存部分来发挥这种魔力。该论文的许多作者指出，SGX飞地“屏蔽了其他软件对应用程序代码和数据的访问，包括更高权限的软件”。该项目利用的“enclave”是芯片上的enclave页面缓存(EPC)，这是一个由18条指令控制的内存分区，外部代码无法访问。</p>
<p class="translated">当规划SGX的“可信计算基础”时，它将在飞地内运行，SCONE研究人员受到两个主要要求的引导:一是保持代码基础尽可能小，以最小化攻击面。另一种方法是通过不引入额外的延迟来保持性能，这是“飞地”模型中固有的，因为任何对内核的系统调用都需要线程跳到飞地之外，这涉及到所有伴随的内存复制。</p>
<p class="translated">“这份报告完全是关于交易几率的，真的，”Frazelle说。SCONE的大部分工作是平衡安全性和性能。</p>

<p/>
<p class="translated">最初，研究人员研究了微软的<a href="https://www.microsoft.com/en-us/research/publication/shielding-applications-from-an-untrusted-cloud-with-haven/" class="ext-link" rel="external "> Haven模型</a>的安全操作。然而，这种方法需要将大部分操作系统放在容器中，对于所有需要的库来说，这对于Linux来说是不可行的。代码库会太大，并且会增加延迟。此外，如果enclaved操作系统存在漏洞，整个系统可能会受到损害，“它可能适用于Windows，但对于Linux，这不是一件好事，”Frazelle说。</p>
<p class="translated">研究人员还研究了另一个极端，即剥离所有的库用于最小的安装基础，留下少量调用操作系统所需的系统调用。然而，这种方法也有它的问题，因为它会给保护不属于enclave权限范围的数据和操作带来更大的负担。</p>
<div id="attachment_3292250" class="wp-caption aligncenter"><a class="utm-none ext-link" href="https://www.usenix.org/system/files/conference/osdi16/osdi16-arnautov.pdf" rel="external "><img aria-describedby="caption-attachment-3292250" decoding="async" loading="lazy" class="wp-image-3292250 size-full" src="../Images/259a579ecce5eb028d10556b0ae92116.png" alt="" data-id="3292250" data-original-src="https://storage.googleapis.com/cdn.thenewstack.io/media/2017/10/c385f1fe-scone-arch.png"/></a><p id="caption-attachment-3292250" class="wp-caption-text translated">安全容器设计的三种可能性(USENIX论文)。</p></div>
<p class="translated">他们选定的烤饼做法是两者的结合。大量使用的<a href="http://www.csse.uwa.edu.au/programming/ansic-library.html" class="ext-link" rel="external "> C标准库</a>被隔离，消除了许多外部系统调用的需要。SCONE为enclave内外的所有套接字操作提供了一个“网络屏障”，使用来自容器文件系统的私钥和证书为每个连接提供TLS握手和加密/解密。</p>
<p class="translated">还引入了“异步系统调用机制”。它的实现使用共享内存来传递系统调用参数和返回值，并发出应该执行系统调用的信号。系统调用由运行在SCONE内核模块中的独立线程执行。因此，enclave中的线程在执行系统调用时不必退出，”该论文称。</p>
<p class="translated">研究人员认为，这种方法产生了最佳结果。在SCONE下，一组应用程序(Apache、Redis、NGINX、memcached)的运行速度大约是本机执行速度的0.6到1.2倍。由于Memcache处理加密的方式有些奇怪，该软件实际上在封闭环境中运行得更快。</p>
<h2 class="translated">在每一个梦里，都有心痛</h2>
<p class="translated">Frazelle指出，一个迫在眉睫的问题是每个应用程序都能很好地执行。异步系统调用在性能上非常昂贵，因此在enclave下，进行大量系统调用的应用程序会受到严重影响。“任何通过系统调用进出超快的东西，用这个都会超慢，”她说。SCONE提供了多线程机制来减轻这种痛苦，尽管单线程应用程序(如Redis)的性能会特别糟糕。</p>
<p class="translated">内存页面故障也会降低性能，L3缓存未命中也是如此，从enclave来看，其速度会慢12倍。“那真是糟糕透了，”弗雷泽勒提醒观众。</p>
<p class="translated">“虽然你获得了一个安全的地方来运行容器，但你的性能受到了巨大的打击，”她说，并补充说，她希望随着时间的推移，随着更多的人从事代码库的工作，性能会有更大的提高。</p>
<p class="translated">还有其他的权衡。一个是用户方面的投资。</p>
<p class="translated">Frazelle总结道:“当你用这个做什么的时候，有很多事情要考虑。”SCONE承诺原始应用程序代码可以在enclave中不加修改地运行，但是仍然需要大量的工作来装备系统运行SCONE。</p>
<p class="translated">设置enclave的所有软件都必须安装在Docker容器中。还需要一个enclave内核模块来处理系统调用。SCONE也不支持<strong> fork </strong>系统调用，限制了可以使用的应用程序范围。</p>
<p class="translated">Frazelle指出，传递系统调用和进行必要的加密和解密的复杂性增加了额外的攻击面。“如果你在那个飞地放了任何bug，那你就完了，”她说。</p>
<p class="attribution translated"><a href="https://azure.microsoft.com/en-us/?v=17.14" class="ext-link" rel="external ">微软</a>是新堆栈的赞助商。</p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
<title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>

</div>
</div>    
</body>
</html>