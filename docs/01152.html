<html>
<head>
<title>Developers: Fuzzing, Symbolic Execution with Regression Testing Offers App Resilience</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开发人员:模糊化、符号化的回归测试为应用提供了弹性</h1>
<blockquote>原文：<a href="https://thenewstack.io/developers-fuzzing-symbolic-execution-with-regressive-testing-offers-app-resilience/#0001-01-01">https://thenewstack.io/developers-fuzzing-symbolic-execution-with-regressive-testing-offers-app-resilience/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">


<p class="translated"><a href="https://www.linkedin.com/in/mel-llaguno-23aa9659/?originalSubdomain=ca" class="clearfix infoBlock " target="_blank"> <div class="infoBlockTextBlock"> <p class="infoBlockTitle">梅尔·拉古诺</p> <p class="infoBlockText">梅尔·拉古诺是ForAllSecure公司的商业解决方案主管，他负责开拓新市场，并在行业内采用该公司屡获殊荣的技术。此前，他在Synopsys工作，负责运营他们的Coverity SCAN项目，该项目为世界上一些最重要(也是最大)的OSS项目提供商业级SAST。</p> </div> </a></p><p class="translated">今年的<a href="https://www.blackhat.com/" target="_blank" rel="noopener noreferrer external " class="ext-link">黑帽</a>再一次体现了软件正成为我们日常生活中必不可少的组成部分这一认识。甚至有更多的解决方案正在被吹捧，以应对软件不断增长的恶意威胁。不幸的是，许多解决方案集中在处理我们当前困境的症状上，而没有解决根本的事实——尽管我们尽了最大努力，软件仍然是不安全的。</p>
<p class="p1 translated">需要的是改变观点。软件<em>就是</em>基础设施。</p>
<p class="p1 translated">在安全临界系统中尤其如此。想想汽车工业、航空和医疗设备的最新进展。如果没有引入软件作为创新的一部分，这一切都是不可能的。然而，这有一个不幸的副作用，即给这些系统注入了一个额外的特征——硬件和软件的融合使这些系统本质上成为信息物理系统。问题是，我们为应对现代软件开发的挑战而开发的过程总体上还没有达到生死攸关的系统所需的成熟度。</p>
<p class="p1 translated">这个过程中缺少的是弹性的概念。弹性是面对不利条件时抵御灾难性失败的能力。弹性是安全关键的信息物理系统的基本要求，特别是当这些系统预计将运行几十年，而不仅仅是几年。</p>
<p class="p1 translated">虽然有许多技术可以帮助解决构建弹性系统的挑战，但它们本身只能解决问题的一小部分。让我们来看看这些解决方案的各种优势和劣势:</p>
<ul class="ul1">
<li class="li1 translated"><strong>软件组成分析</strong>允许组织找到过时的软件依赖关系。通过使用这些组件的非易受攻击的版本，可以立即提高安全性。挑战在于这种安全感是在一个时间点上。不能保证拥有最新的组件，你的应用程序就能安全抵御<em>未来的</em>威胁。</li>
<li class="li1 translated"><strong>静态分析</strong> (SA)可以应用于一个程序的源代码，但是与一个抽象一起工作，这个抽象不针对实际执行的代码。此外，即使是最好的工具也需要组织的努力来使用，因为该技术存在一个基本问题，即误报(FP)，即错误识别实际上是<em>而不是</em>缺陷的问题。随着代码库规模的不断增长，SA的应用变得更加复杂。虽然最好的SA工具的FP率可以低于5%，但是当应用于1MLoC到10+MLoC(代码行)的项目时，这导致识别出大约50k–500k的缺陷(使用5%作为FP率)。这个数量的缺陷需要大量的时间和资源来解决。想象一下，当正在使用的SA工具具有更高的FP速率时…</li>
<li class="li1 translated"><strong>动态分析</strong>(如协议模糊器、交互式应用安全工具——IAST、漏洞扫描器)在验收测试的环境中很有用，但是这些工具的应用需要了解<em>在软件开发生命周期(SDLC)中的</em>何时可以应用。这些工具通常适用于完全开发/部署的应用程序，这从根本上改变了它们在SDLC中的位置<em>最右边</em>。开发人员反馈周期中的这种滞后是有代价的。</li>
<li class="li1 translated"><strong>软件审计和渗透测试</strong>也可用于保护软件，但成本较高(因为它需要一定程度的专业知识),并且受到人力规模的限制。该选项通常仅适用于有资源租用/购买这些服务的组织，这使得大多数公司面临不必要的风险。</li>
</ul>
<p class="p1 translated">那么解决办法是什么呢？</p>
<p class="p1 translated">覆盖引导模糊化是一种越来越受欢迎的技术，这得益于云规模基础设施的最新进展。模糊化是生成伪随机输入并输入到程序中以查看它是否以意外方式运行的过程。令人惊讶的是，这种技术在发现可能具有稳定性/安全性含义的新缺陷方面非常有效。众所周知，黑客使用模糊化来发现新的漏洞。</p>
<p class="p1 translated">谷歌(通过<a href="https://github.com/google/oss-fuzz" target="_blank" rel="noopener noreferrer external " class="ext-link">OSS-模糊倡议</a>)和微软(通过开发其<a href="https://www.microsoft.com/en-us/security-risk-detection/" target="_blank" rel="noopener noreferrer external " class="ext-link">安全风险检测引擎</a>)已经非常成功地应用了这项技术，使他们的应用程序更具弹性。</p>
<p class="p1 translated">这种技术的尖端结合了模糊化和符号执行(SE)。虽然模糊化可以被认为是暴力突变输入测试，但SE可以查看程序的执行上下文，并发现有趣的分析路径，而模糊化本身很难取得进展。</p>
<p class="p1 translated">此外，测试用例是作为分析的一部分自动生成的<em/>。这些测试案例非常重要，因为:</p>
<ol class="ol1">
<li class="li1 translated">它们可以作为软件未来版本的回归测试，而不需要额外的开发工作。您可以测试一个依赖项的最新版本，以确保程序行为的完整性，而不是等待将来版本报告缺陷/漏洞。</li>
<li class="li1 translated">一个发现的缺陷对正在运行的程序有直接/可测量的影响，并且不太可能导致误报。</li>
<li class="li1 translated">它们可以被简化为一个最小的案例集，来执行所发现的执行路径。这比运行程序的完整分析要快得多，并且可以很容易地集成到DevOps管道中。这使得开发人员可以立即看到通过分析发现的回归/缺陷。</li>
<li class="li1 translated">它们可以用来提供缺陷再现器，这样开发人员就可以快速识别代码需要修复的地方。本质上，测试给出了一个有经验的审计员/测试员可以提供的环境类型。</li>
<li class="li1 translated">随着分析的进行，新的测试用例被生成。</li>
</ol>
<p class="p1 translated">虽然没有一个分析可以声称找到所有可能的bug，但是拥有一个与程序一起发展的测试用例集合可以让组织相信一个经过分析的程序是有弹性的。</p>
<p class="attribution translated">通过Pixabay的特征图像。</p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
<title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>
</div>
</div>    
</body>
</html>