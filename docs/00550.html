<html>
<head>
<title>This Week in Programming: Mostly Harmless</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">本周编程:基本无害</h1>
<blockquote>原文：<a href="https://thenewstack.io/this-week-in-programming-mostly-harmless/#0001-01-01">https://thenewstack.io/this-week-in-programming-mostly-harmless/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">


<p class="translated">纵观计算机科学的历史，看“<a href="https://en.wikipedia.org/wiki/Considered_harmful" class="ext-link" rel="external ">被认为有害的</a>”文章的趋势，最有趣的部分可能是他们陷入了<a href="https://meyerweb.com/eric/comment/chech.html" class="ext-link" rel="external ">认为“被认为有害的”文章有害的</a>的元循环的趋势。正如杰夫·阿特伍德(Jeff Atwood)很久以前在他题为“<a href="https://blog.codinghorror.com/id-consider-that-harmful-too/" class="ext-link" rel="external ">我也会认为那是有害的</a>”的博客文章中所指出的，第一篇具有里程碑意义的“被认为是有害的”文章出现在<a href="https://en.wikipedia.org/wiki/Edsger_Dijkstra" class="ext-link" rel="external ">艾德格斯格·迪克斯特拉(Edsger Dijkstra)1968年的</a>论文“<a href="http://www.u.arizona.edu/~rubinson/copyright_violations/Go_To_Considered_Harmful.html" class="ext-link" rel="external ">后藤被认为是有害的</a>”中，几十年后，这篇文章遭遇了“‘后藤被认为是有害的’被认为是有害的”以及更深入的兔子洞，“‘后藤被认为是有害的’被认为是有害的？”</p>

<p/>
<p class="translated">只有程序员(或者可能是哲学家)能够达到这种嵌套层次而不爆头。对于大多数编辑来说，甚至写下最后一句话(我认为我正确地关闭了所有的引号)都是困难的。</p>
<p class="translated">正如开发者Tim Oxley在一篇博客文章(四年前撰写)中所言，如果那些迷失在“被认为有害的”论点的嵌套循环中的人能够<a href="http://blog.timoxley.com/post/47041269194/avoid-else-return-early" class="ext-link" rel="external ">避开else并尽早返回</a>该多好。奥克斯利的帖子仅仅是另一篇“被认为有害”的文章吗？这是坏脾气和哀怨的程序员的悠久传统吗？我们是否抛弃了仅仅基于这样一种想法的任何论点，即它们反对教条主义的实践，而这些实践本身又导致了不同种类的教条主义的实践？</p>
<p class="translated">在我看来，这个论点的核心是围绕它的<a href="https://www.reddit.com/r/programming/comments/878zi2/avoid_else_return_early/" class="ext-link" rel="external ">论点</a> <a href="https://news.ycombinator.com/item?id=16678209" class="ext-link" rel="external ">。虽然有很多受过大学教育的传统程序员，但这里也有很多自学成才的类型，我发现，至少这些互联网讨论是我学到最多的地方。</a></p>
<p class="translated">回到正题，在文章中奥克斯利提出了四点TL/dr；–</p>
<ul>
<li class="translated">一旦您知道您的方法不能做任何更有意义的工作，就立即返回</li>
<li class="translated">通过使用if/return而不是顶级if/else来减少缩进</li>
<li class="translated">试着将你的方法的“实质”保持在最低的缩进层次。</li>
<li class="translated">错误处理是噪音。</li>
</ul>
<p class="translated">有这么简单吗？你应该抛弃传统的if-then-else语句方法吗？这仅仅是<a href="https://www.youtube.com/watch?v=XDqZemwVXUk" class="ext-link" rel="external ">其他被认为有害的</a>吗？你应该搬到<a href="https://en.wikipedia.org/wiki/Fail-fast" class="ext-link" rel="external ">快速</a>并且早点回来吗？你多年来的“如果，那么，否则”的退出方式有没有把你引入歧途？</p>
<p class="translated">正如一位Reddit评论者<a href="https://www.reddit.com/r/programming/comments/878zi2/avoid_else_return_early/dwb96ak/" class="ext-link" rel="external ">指出的</a>，“如果你正在使用一种需要在返回之前清理东西的语言，提前返回是一件坏事”，指出需要“释放内存、套接字、文件句柄和其他资源”另一个<a href="https://www.reddit.com/r/programming/comments/878zi2/avoid_else_return_early/dwbuypz/" class="ext-link" rel="external ">回复</a>认为这在C++中是必要的，而在作者使用的Javascript中是不需要的。在<a href="https://news.ycombinator.com/item?id=16678209" class="ext-link" rel="external ">的另一个讨论</a>中，一位评论者<a href="https://news.ycombinator.com/item?id=16678284" class="ext-link" rel="external ">提出</a>这可能只是<a href="https://refactoring.com/catalog/replaceNestedConditionalWithGuardClauses.html" class="ext-link" rel="external ">“保护条款”</a>的一种情况，这已经在Swift 中<a href="https://thatthinginswift.com/guard-statement-swift/" class="ext-link" rel="external ">形式化了。</a></p>
<p class="translated">无论是哪种情况，也许回到冗长的、学术性的反驳和“被认为有害的”循环的永恒嵌套循环的时代，我们都可以抛弃这个论点作为另一个例子，但正是在这里，我觉得我学到了最多。见鬼，如果没有它，我可能会一直不知道这种奇妙的“有害”现象。</p>
<p class="translated">总之，再次感谢匿名的网络评论者和潜在的不知道“被认为有害”的作者教会了我关于这个世界的新东西。这是我这周学到的关于编程世界的一些新东西。</p>

<p/>
<h2 class="translated">本周的节目中</h2>
<ul>
<li class="translated"><strong> TypeScript 2.8带来了条件类型:</strong>微软<a href="https://blogs.msdn.microsoft.com/typescript/2018/03/27/announcing-typescript-2-8/" class="ext-link" rel="external ">宣布了TypeScript 2.8 </a>，它说“带来了一些我们认为你会无条件地爱上<em>的功能</em>！”斜体强调的是，作为此次声明的重要部分之一，包含了<a href="https://blogs.msdn.microsoft.com/typescript/2018/03/27/announcing-typescript-2-8/#conditional-types" class="ext-link" rel="external ">条件类型</a>，这是TypeScript中的一个新构造，允许您基于其他类型选择类型。当然，TypeScript的一个定义特性是它向JavaScript添加了可选的静态类型，这“有助于保证您的代码避免输入错误和其他愚蠢的错误。”ITWorld将这一新特性总结为“在运行时帮助基于类型的简单选择建模，同时允许更具表达性的设计时构造”。该结构采用以下形式:A扩展了B？C : D。应该理解为“如果类型A可赋给B，则该类型归结为C，否则就变成D”。条件类型还提供了一种新的方法来根据新的infer关键字从类型中推断新的类型，该关键字引入了一个新的类型变量。"</li>
<li class="translated"><strong>谷歌基于云的文本到语音转换:</strong>谷歌<a href="http://cloudplatform.googleblog.com/2018/03/introducing-Cloud-Text-to-Speech-powered-by-Deepmind-WaveNet-technology.html" class="ext-link" rel="external ">引入了云文本到语音转换</a>作为其<a href="https://cloud.google.com/" class="ext-link" rel="external ">谷歌云平台</a>的一部分，它可以让你从12种语言和变体的32种不同声音中进行选择。该公司声称，“云文本到语音转换可以正确地读出复杂的文本，如姓名、日期、时间和地址，以便在一开始就发出听起来真实的语音，”尽管如果这与谷歌地图试图读出街道名称等类似内容有所不同，那么……云文本到语音转换功能由WaveNet提供支持，允许您定制音高、语速和音量增益，并支持各种音频格式，包括MP3和WAV。<a href="https://cloud.google.com/text-to-speech/" class="ext-link" rel="external ">云文本到语音转换</a>现已推出公测版</li>
<li class="translated"><strong> Rust 1.25的一堆东西:</strong>当我们向<a href="https://thenewstack.io/week-programming-rusts-roadmap-epoch-release/" class="local-link"> Rust的“新时代版本”</a>前进的时候，我们又得到了<a href="https://blog.rust-lang.org/2018/03/29/Rust-1.25.html" class="ext-link" rel="external "> Rust 1.25的另一个增量版本</a>，博客帖子说“包含了一堆东西！”Rust 1.25已经从LLVM 4的<a href="https://github.com/rust-lang/rust/pull/47828" class="ext-link" rel="external ">升级到LLVM 6的</a>，并且现在允许<a href="https://github.com/rust-lang/rust/pull/47948" class="ext-link" rel="external ">嵌套的导入组</a>，这允许在一行中导入(或者其他)，这取决于你的偏好。此外，在该语言不断努力使学习Rust更容易的过程中，<a href="https://doc.rust-lang.org/rust-by-example/" class="ext-link" rel="external "> Rust By Example现在包含在doc.rust-lang.org</a>中。这只是其中的几个亮点，但请务必查看<a href="https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1250-2018-03-29" class="ext-link" rel="external ">发行说明</a>和<a href="https://blog.rust-lang.org/2018/03/29/Rust-1.25.html" class="ext-link" rel="external ">博客文章</a>以了解全部细节。</li>
<li class="translated"><strong> Wear OS开发者预览:</strong>谷歌更名后的Wear OS(之前的Android Wear)在本周的开发者预览中<a href="http://android-developers.googleblog.com/2018/03/wear-os-by-google-developer-preview.html" class="ext-link" rel="external ">发布，为可穿戴设备带来了Android P。预览版包括官方Android仿真器上的更新系统映像，以及华为Watch 2蓝牙或华为Watch 2 Classic蓝牙的可下载系统映像。正如谷歌对Android应用程序所做的一般，它在这个版本的Wear OS中实施了与非SDK方法和字段</a>相关的<a href="https://g.co/dev/appcompat" class="ext-link" rel="external ">限制。此外，预览版提供了一个黑暗的UI系统主题，并通过限制后台活动，关闭身体时关闭无线电，以及在蓝牙断开时关闭WiFi来改善电源使用。</a></li>
<li class="translated"><strong>tensor flow YouTube官方频道:</strong>谷歌还宣布了<a href="https://www.youtube.com/watch?v=BXgBOwDYsNg" class="ext-link" rel="external ">tensor flow YouTube频道</a>，用于直播3月30日正在直播的TensorFlow Dev峰会。显示包括<a href="https://goo.gl/XZTYsT" class="ext-link" rel="external ">编码张量流</a>、<a href="https://goo.gl/G9Y46n" class="ext-link" rel="external ">张量流满足</a>、<a href="https://www.youtube.com/results?search_query=%23AskTensorFlow" class="ext-link" rel="external "> #AskTensorFlow </a>。</li>
<li class="translated"><strong> Android Studio 3.1: </strong>本周加入dot发布的长长列表的是<a href="https://android-developers.googleblog.com/2018/03/android-studio-3-1.html" class="ext-link" rel="external "> Android Studio 3.1 </a>，<a href="https://sdtimes.com/android/sd-times-news-digest-android-studio-3-1-microsoft-open-sources-wsl-sample-valohais-machine-learning-funding/" class="ext-link" rel="external "> SDTimes </a>将其总结为包括“C++性能分析器、Kotlin链接检查、数据库代码编辑、IntelliJ平台更新、新构建输出窗口、快速启动和C++ CPU分析”Android Studio 3.1现已于今日<a href="https://developer.android.com/studio/index.html" class="ext-link" rel="external ">下载</a>。</li>
</ul>

<p/>
<ul>
<li class="translated">没有复杂性的兼容性: JAXEnter介绍了最近提出的<a href="https://jaxenter.com/go-package-versioning-proposal-142768.html" class="ext-link" rel="external "> Go包版本提案</a>，它说该提案提供了没有复杂性的兼容性。根据这篇文章，Go一直在处理版本信息方面有困难，但是一个新的提议超越了特设工具，以“在不增加复杂性的情况下提供向后的能力。”文章解释说“Go 1的主要特点实际上并不是任何类型的语言变化或特殊功能”，而是“一个简单的承诺:Go对向后兼容性的坚持”，强调了这种生产使用的可靠性如何推动Go的发展。不幸的是，如果有任何渐进的代码修复或部分代码升级，这会导致问题。“解决办法？<a href="https://github.com/golang/go/issues/24301" class="ext-link" rel="external ">Russ Cox提出了一个名为vgo </a>的新提议，该提议“表明导入兼容性和语义版本化共同需要<a href="https://research.swtch.com/vgo-import" class="ext-link" rel="external ">语义导入版本化</a>。"</li>
<li class="translated"><strong>集装箱？改为无服务器怎么样？</strong>最后，本周，Matt Asay在Infoworld上提出了一个论点，建议开发人员继续前进，<a href="https://www.infoworld.com/article/3265457/containers/why-serverless-is-the-better-option-than-containers.html" class="ext-link" rel="external ">跳过容器，转而进行无服务器计算</a>。虽然我们谈到了<a href="https://thenewstack.io/week-programming-embracing-thing-everyone-else-talking/" class="local-link">拥抱其他人都在谈论的与容器相关的</a>，但Assay认为“尽管它们很棒，但容器有一个内在的缺陷:它们还不够简单。”Assay将无服务器描述为向开发人员提供了一种专注于编写应用程序逻辑而不是服务器基础设施的方式，它还标志着开发人员需要“相信AWS、微软或谷歌会得到正确的基础设施，但拥抱这些云后端的好处是巨大的。”你怎么看——集装箱还是无服务器，FTW？</li>
</ul>

<p/>
<p class="attribution translated">谷歌和微软<a href="https://azure.microsoft.com/en-us/?v=17.14" class="ext-link" rel="external ">是新堆栈的赞助商。</a></p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
<title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>

</div>
</div>    
</body>
</html>