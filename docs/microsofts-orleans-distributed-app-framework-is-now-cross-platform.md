# 微软的奥尔良分布式应用框架现在是跨平台的

> 原文：<https://thenewstack.io/microsofts-orleans-distributed-app-framework-is-now-cross-platform/>

微软[奥尔良](https://github.com/dotnet/orleans)是一个开源编程框架。NET，最初由微软研究院的极限计算小组开发，使用虚拟角色简化分布式应用程序开发。这些是具有自己状态的单线程对象，不共享任何内存，通过使用异步远程过程调用交换消息来进行通信，按需激活，不再使用时进行垃圾收集，并根据需要无缝重新激活。

因为运行时负责激活、清理和跨服务器分发虚拟角色(Orleans 称之为 grains ),开发人员可以编写他们的代码，就像它将在单台机器上运行一样，而不用担心并发性，并且可以根据需要扩展到任意多的服务器。

当微软[在 2015 年初](https://thenewstack.io/project-orleans-the-net-framework-from-microsoft-research-used-in-halo-4/)开源 Orleans 时，它需要。NET 框架，这意味着它只能在 Windows 服务器上运行。2.0 版通过迁移到使 Orleans 跨平台。NET Core，可以运行在 Linux 和 macOS(都是。支持 NET Core 2.0 和 2.1，开发者不用升级自己的版本。NET 使用新奥尔良版本)。

“我们看到很多人对在 Linux 上运行 Orleans 感兴趣，无论是微软内部还是 Orleans 社区外部，尤其是容器，”微软研究院 Orleans 团队的首席软件工程负责人 [Sergey Bykov](https://github.com/sergeybykov) 告诉 New Stack。“当他们的堆栈的其他部分在该环境中运行时，他们自然希望在相同的环境中运行奥尔良。”

但是尽管主要目标是兼容。NET Core，该团队借此机会做出了一些突破性的变化，Bykov 说，否则可能很难证明。“我们让奥尔良对开发商更加友好；我们更新了 API，使之与 ASP.NET 以及。NET 核心与配置选项和依赖注入。干净多了；它更加结构化、更加灵活，开发者也更加开心。”

虽然 Orleans 已经支持依赖注入，但它主要是允许开发人员在运行时将依赖注入到他们自己的应用程序代码中。“在 Orleans 2.0 中，我们重组了一切，所以几乎所有运行时的内部组件都是可注入的，”Bykov 告诉我们；这意味着无论是测试还是生产，开发人员都可以替换运行时的基础部分。“依赖注入提供了在启动时组装东西的功能，所以你不会有 2.0 之前的僵化结构。他们可以为测试服务注入模拟和定制植入。”一个名为提醒的设施显示了你可以安排每天或每周要做的事情，当时间到了，谷物就会被激活和调用。如果您想要运行一个测试，并且运行速度超过一天或一周，您可以注入您自己的提醒服务的实现。

Bykov 将原始的 Orleans 代码库描述为“更加单一:随着时间的推移，我们变得更加去耦合，使用所有这些技术来灵活地构建运行时。”因为当项目在 2010 年开始时，该框架的许多部分都没有现成的 API，所以团队不得不为日志记录之类的事情创建自己的代码。现在定制代码被移除，这样 Orleans 的开发人员(他们通常熟悉 ASP.NET)可以使用更熟悉的工具和模式；例如，[日志实现](https://www.nuget.org/packages/Microsoft.Extensions.Logging/)与 ASP.NET 核心中的实现相同。

由于这种程度的解耦，运行时的组织方式也发生了变化；Bykov 指出，虽然虚拟角色颗粒的抽象保持不变，但配置和启动它们运行的筒仓更像 ASP.NET。“我们过去只是扫描文件夹中的颗粒组件，因此如果一个文件夹中有 150 个组件，启动需要一分钟左右的时间。在 Orleans 2.0 中，它们的 API 名称与 ASP.NET 相同。我们从这个程序集中加载它们，启动时间非常快，特别是对于测试用例，因此开发人员可以在更短的时间内运行他们的测试。配置更加灵活；这不是一个黑匣子，它会进行缩放。”

## 打开奥尔良设计

让奥尔良使用熟悉的 ASP.NET 概念使新开发人员更容易学习，也使社区更容易为奥尔良做出贡献，这对项目越来越重要。

“即将到来的 2.1 版本中最大的变化之一是调度程序，它处理竖井中数百万任务的执行，”Bykov 指出。新的调度程序提供了 30%的更好的吞吐量——它是由 GitHub 社区成员编写的，他只贡献了三年，但他的贡献在这段时间里使 Orleans 的性能翻了一番。

另一个重要的特性是新的代码生成器。“奥尔良的一大价值主张是它易于使用。即使一个对象是远程的，你也可以像它是本地的一样编写你的代码；为此，我们生成透明代理类和序列化程序。你可以原生地编写代码，接受特定类型的参数，但需要神奇地从一台机器转移到另一台机器，我们编写序列化程序来完成这一任务。”

Orleans 2.1 中新代码生成包的大部分代码也是由社区贡献的。这用的是罗斯林。NET 编译器的代码分析，以避免与不同版本的。NET Core SDK。“新版本的代码生成使用代码到代码的编译:它根本不加载程序集，也没有版本绑定—它只是查找代码并为序列化程序和代理引用生成代码。”

奥尔良内部的分离水平使得社区更容易为奥尔良做出这些重大贡献，这也使得微软在该项目中的角色更加清晰。

“去耦合允许我们无法扩展交付的创新，”Bykov 解释道。“它允许我们继续专注于我们提供最大价值的关键功能，并允许其他人构建插件。也许你想取代奥尔良的信息传递方式；我们的信息传递很好，非常快速和灵活，但这是我们传递信息的方式。”

另一个开发人员可能需要执行稍有不同的消息传递，现在他们可以使用依赖注入来取代对 Orleans 工作方式如此重要的东西。

<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 68 31" version="1.1"><title>Group</title> <desc>Created with Sketch.</desc></svg>