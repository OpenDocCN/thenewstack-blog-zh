# 什么通量？React 状态管理生态系统概述

> 原文：<https://thenewstack.io/flux-overview-react-state-management-ecosystem/>

对于 JavaScript 来说，这是疯狂的几年！如果我们回到 10 年前——甚至更短的时间 JavaScript 的前景看起来和以前完全不同。JavaScript 不仅已经成为一种可行的后端编程语言，而且还在继续发展；有人会说它发展得太快了。

我们可以回顾 2015 年，或者许多人都知道的“[应对疲劳](https://medium.com/@ericclemmons/javascript-fatigue-48d4011b6fc4#.vw6jw7oxw)的一年。”有一段时间，每个人都对谷歌的[棱角分明感到满意。JS](https://thenewstack.io/google-preps-angular-2-final-release/) 框架，以及它给前端编程带来的严谨感。然而，由于种种原因，许多人对 Angular 越来越不满意。

许多开发人员对 Angular 的一个主要问题是，它是一个非常固执己见的框架；做任何事情都有一个角度。当脸书的 [React](https://facebook.github.io/react/) 作为一个相对较小的“视图”图书馆出现时，许多人觉得这是一股新鲜空气。由于 React 的范围如此之小，所以它很容易理解，开发人员会推出由 React 和其他库组成的框架。

这就是事情开始变糟的地方，一个相反但同样痛苦的问题出现了:太多的决策和未解决的问题。国家管理是缺乏适当解决方案的最大领域之一。

## 香草反应

在 React 中，唯一提供的状态管理原语是不可变属性和可变状态。由于状态更难推理，React 鼓励你尽量少用状态，把精力放在道具上。

如果你有一个需要改变的组件，在大多数情况下，你会扔掉那个组件，并生成一个带有所需属性的新组件。那些了解 React[虚拟 DOM](https://facebook.github.io/react/docs/glossary.html) 的人会知道，为了获得性能优化，实际上还有更多的事情要做，但从概念上来说，事情就是这样。

因此，React 开发人员将在他们的组件层次结构中隔离更高的状态，并将其作为道具向下传递，让状态从树的顶部流向底部。在许多情况下，这是非常优雅的，但坦率地说，被渴望深入了解完整 React 生态系统的开发人员忽略了。

当组件树变得很高时，问题就开始出现了，并且在树上有彼此远离的组件，并且一个组件不是另一个组件的后代，并且两个组件都依赖于相同的状态位。

简单来说，假设您有一个导航栏和一个显示新消息的组件。在导航栏中，有一个组件会提示您是否有新邮件。在这种情况下，navbar 组件和 messages 组件将依赖于相同的状态。在这里，两个组件都不是另一个的后代，这使得管理状态更具挑战性。

为了避免“多个真实来源”,在这种情况下正确的做法是将这种共享状态存储在最近的共同祖先(或任何共同祖先)中，并从那里将状态作为道具传递下去。

对于中小型应用程序来说，这是一种不错的方法，但是对于大型应用程序来说，这种方法很麻烦，而且必须将状态放在组件树的较高位置，这可能会影响性能。

对于那些自己没有遇到过这个问题的人来说，这个问题是 Flux、Redux、Relay 和相关数据管理工具的主要动力之一。他们都采取不同的方法来解决这个问题，但从根本上说，他们都在试图解决同一个问题。

所有这些工具不是将状态从一个组件向下传递到层次结构，而是将状态移动到一个或多个外部存储，这取决于状态管理工具。然后，尽管所有提到的解决方案中的机制都非常不同，但是在这些解决方案的每一个中，组件都将声明对它们感兴趣的存储的依赖。

每当存储发生变化时，这些组件将重新提取数据，并重新呈现其子组件。这些经常被称为“容器”的组件将把数据从商店传递给它们的孩子作为道具。在上述所有解决方案中，vanilla React 的组件状态的角色被边缘化了。

## 一支流动大军

脸书的 [Flux](https://facebook.github.io/flux/) 是 React 的原始状态管理库，尽管它更像是一个模式，而不是一个库或框架。虽然脸书提供了一个用于 Flux 的 [NPM 包](https://www.npmjs.com/package/flux)，但是它的产品非常稀少，大部分的重担都留给了应用程序开发者。

Flux 的一个主要思想是状态应该是公共可读的，但只能以松散耦合的方式修改。React 组件不是为存储调用某种 setter 方法，而是创建动作。应用程序中的所有商店都将通过一个集中的调度程序接收该操作，然后商店将自己决定是否应该更新其状态以响应该操作。

> 在 vanilla Flux 实现中有太多的样板文件和太多的间接层。这导致了大量的 Flux 实现。

这些动作是简单的 JavaScript 对象，具有类型属性，以及可选的附加有效负载信息。如果某个存储对该操作感兴趣，它将更新其状态，订阅该存储的组件将重新呈现。

这种架构将复杂的 UI 状态依赖分解为一个简单的系统。如果两个 UI 组件对同一个状态感兴趣，那么它们都会监听同一个存储。每当有导致共享状态更改的操作时，这两个组件都将重新呈现以响应该更改。虽然基本原理很棒，但是 vanilla flux 的实现细节有点难以理解。起初，集中式调度程序似乎是不必要的，而且有大量的代码用于创建 flux 存储。总而言之，大多数开发者认为。

## 通量太大

在 vanilla Flux 实现中有太多的样板文件和太多的间接层。这导致了大量的 Flux 实现。

过去一年中，许多这样的库来了又走，但是这种“有流而无流”的 Redux 已经成为 React 应用程序中事实上的标准。Redux 不使用调度程序和事件监听器，而是依靠函数式编程和不变性来支持单一存储。

另一个强大的国家管理选项是脸书的[中继](https://facebook.github.io/relay/)框架，它受 Flux 的启发，但走了不少弯路。Relay 依赖于 [GraphQL](http://graphql.org/docs/getting-started/) 和与组件共存的数据依赖关系。请关注本文的第二部分，我们将深入探讨为什么这些特定的解决方案赢得了如此多开发人员的关注。

通过 Pixabay 的特征图像。

<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 68 31" version="1.1"><title>Group</title> <desc>Created with Sketch.</desc></svg>