# JavaScript 预测:ECMAScript 2022 的前景如何？

> 原文：<https://thenewstack.io/javascript-forecast-whats-ahead-for-ecmascript-2022/>

编者按:这篇文章已经更新，以澄清哪些私人课堂提案已经达到第四阶段。

JavaScript 继续发展，ECMAScript 的下一个年度更新将于 2022 年 7 月获得批准，它正式标准化了 JavaScript 语言。这将包括到 2022 年 3 月已经达到第四阶段的所有新功能提案，这些提案已经由 ECMAScript 编辑签署，通过了测试套件，并在至少两个实施中发布。

少数提议已经进入第三阶段[。通过查看哪些特性已经达到第三阶段，规范已经签署，测试已经通过，您可以了解还有哪些特性可以进入 ECMAScript 2022。但是这些建议需要在实现中进行试验，以观察它们在实践中的实际效果如何。](https://github.com/tc39/proposals/blob/master/finished-proposals.md)

例如，能够像在 Python 中一样从最后一个元素开始通过数组向后执行[的提议目前被实现为 polyfill，试图发现它是否与任何常用的 JavaScript 框架冲突。](https://github.com/tc39/proposal-relative-indexing-method)

我们请负责 ECMAScript 标准化的 TC39 委员会的两位联合主席， [Rob Palmer](https://www.linkedin.com/in/robpalmer2) (彭博 JavaScript 基础设施和工具团队的负责人)和[Brian Terlson](https://www.linkedin.com/in/brian-terlson-6822aa61/)(Azure SDK TypeScript 和 JavaScript 的主要架构师，该规范的前编辑)挑选出一些最重要的提议——包括对日期处理的重大改进。

## 顶级等待

JavaScript 从 [ECMAScript 2017](https://thenewstack.io/async-officially-coming-javascript-year/) 开始就有了异步函数，但是开发者必须显式声明一个函数是异步的。

“如果你正在运行一个模块初始化器——当你的模块开始运行时，你的代码的顶层——这并不总是被认为是异步的，”帕尔默说。

如果其他代码试图读取尚未返回的结果，使用 await 函数等待异步进程可能会导致语法错误，并且试图通过使用 async main 来避免这种情况，会使代码更加复杂，更难测试或执行静态分析。

有了[顶级 Await](https://github.com/tc39/proposal-top-level-await) (已经达到第四阶段，并且已经在三个主要的浏览器 JavaScript 引擎中实现)，模块系统为您协调所有的异步承诺。

顶层 Await 对于[集成 WebAssembly 模块和 JavaScript](https://github.com/WebAssembly/esm-integration/tree/main/proposals/esm-integration) 很重要。这也将有助于共享样本和代码片段的开发人员，Terlson 说:“我不需要在它们周围加上异步函数名来使它们可以复制/粘贴。”

顶级的 Await 成为 ECMAScript 的一部分需要一段时间，因为担心它会使开发人员更有可能在他们的代码中制造死锁。

帕尔默警告说:“当我们允许异步操作放在那里时，人们可以编写任意长时间运行的操作——比如查询数据库，发出网络请求。”

“如果您不小心使用此功能，您可能会延迟整个应用程序的加载。您甚至不能运行第一个 main 函数，因为您现在正在等待某个任意操作完成。”

但他补充说，在浏览器中调用异步代码非常常见，因为如果你必须等待一段代码完成运行，然后才能运行其他任何代码，阻塞代码会导致性能问题。

对于顶级 Await，ECMAScript 与 Node.js 不同，后者使用 CommonJS 模块，为了向后兼容，这些模块将保持同步。开发人员将无法在 CommonJS 文件中同步加载 ECMAScript 模块；他们应该使用动态导入操作符，它返回的不是模块，而是对模块的承诺，异步加载它。

## 最后，私有字段

默认情况下，JavaScript 类中的属性是公共的，可以从代码中的任何地方调用。但有时这会暴露一些您不希望从代码中的其他地方访问(或可能更改)的字段:您可能希望在库中有一个稳定的接口，但能够随着时间的推移更改实现该类的代码，这意味着确保开发人员不会依赖任何特定的实现细节。

到目前为止，惯例是在属性名的开头使用下划线来标记私有字段，但是 JavaScript 语言并没有阻止来自类外部的访问。对于私有类字段，使用#作为字段名的开头意味着它只能在声明它的类体内直接访问。

关于实现私有字段的讨论已经持续了很多年(它们已经在 Node.js 中可用)。组成新的[类字段](https://github.com/tc39/proposal-class-fields)的建议套件已经准备好成为 ECMAScript 2022 的一部分，其中混合了针对公共、私有和[静态](https://github.com/tc39/proposal-static-class-features)字段、[方法](https://github.com/tc39/proposal-private-methods)和访问器的建议，包括一种检查私有字段是否存在的方式。

所有的浏览器现在都在实现关键部分。能够[声明静态字段](https://github.com/tc39/proposal-class-static-block)的实例并使它们私有用于数据封装已经在 Chrome 和 Safari 中实现了。

据帕尔默称，这开启了今年早些时候进入第四阶段的关键提案。

## 时态，用于与日期相关的 Javascript

[时态](https://github.com/tc39/proposal-temporal)，泰尔森称之为“我们的破日期对象的[的替代品”，在今年早些时候达到了第三阶段。它将取代像 Moment.js 这样的库，这些库在填补 JavaScript 的一个空白方面做得很好，这个空白是如此普遍，以至于将该功能作为语言的一部分更有意义。](https://maggiepint.com/2017/04/09/fixing-javascript-date-getting-started/)

`Temporal`是一个全局对象，它将成为新的日期和时间 API 的顶级名称空间，涵盖所有日期、时间、时区、日历甚至公共假日。

无论您需要当前时间、Unix 时间戳、特定年份的星期几、离圣诞节还有几天、列出营业时间的企业是开门还是关门、对日期和时间进行排序的简单方法，还是涉及多个时区的更复杂的事情，时态 API 都能满足您的需求。

“Temporal 将完全改变我们编写与日期相关的 JavaScript 代码的方式，[通过]能够实际做日期数学而不陷入无数不同的陷阱，”Terlson 说。“它有很好的方法来表示日历日期或时钟上可能存在的时间:这些是我们现在无法在 JavaScript 中完成的事情，它总是必须附加到时区和特定的 UTC 实例，这导致了无数的问题。”

在时态中从单一日期对象到多个选项可能感觉需要更多的工作，但 Terlson 建议在实践中更容易使用，因为它更严格。

“我们现在拥有的约会对象感觉很简单，因为你没有意识到你在六次搬起石头砸自己的脚，”他说。“新的日期系统迫使你提前考虑到这种复杂性，所以你只是在提前做寻找漏洞的工作。

> Temporal 将取代 Moment.js 之类的库，moment . js 很好地填补了 JavaScript 中的一个空白，这个空白如此普遍，以至于将该功能作为语言的一部分更有意义。

“日期是很难测试的事情之一；“你不能在单元测试中轻易改变系统日期，”他补充道，“正确的做法是模仿它——但是很多人就是不碰他们的日期代码，所以他们没有发现(问题)。”

此外，泰尔森说，“你几乎需要成为数据专家，才能知道有趣的测试案例是什么。”他建议说，并不是每个开发人员都会考虑测试闰年的行为，或者当闰秒被声明时，他们的代码是否会正确运行。“或者当用户改变时区时，一个移动应用程序——它会倒下吗？”

帕尔默称 Temporal 是他见过的“在某些方面争议最小的提议”。他指出，每个人都希望看到它的进步——但因为它是一个如此大的 API，完全实现和测试它并接受反馈可能需要一点时间。

然而，生产质量的 polyfill 已经在开发中，并且在由早期 poly fill 支持的 [Temporal](https://tc39.es/proposal-temporal/docs/index.html) 文档中有一个沙箱，因此开发人员可以在他们的浏览器开发工具中试用它。

他还看到了强大的开发人员需求，并预计 Temporal 将很快开始被使用，因此开发人员可以从他们的应用程序中删除 Moment.js，“使每个人的代码更轻，下载更快。”但是 API 的庞大意味着测试需要时间。

“这些图书馆如此庞大和复杂的原因不是偶然的复杂，”帕尔默说。“这是因为我们世界中的日期和时间规则非常复杂，所以你希望尽可能多地将这些知识转移给专家，这些专家已经考虑到了这一点，并在 API 中嵌入了所有这些知识。”

将 Temporal 迁移到第四阶段也必须等到互联网工程任务组(IETF)标准化用于日历和时区注释的[字符串格式的工作完成之后；预计在 2022 年。](https://github.com/nodatime/nodatime/pull/1653)

## 链接错误原因

同样处于第三阶段的是一项提案，泰尔森将其视为与[ECMAScript 2021](https://thenewstack.io/ecmascript-2021-whats-next-for-javascript-webassembly/):[Error Cause](https://github.com/tc39/proposal-error-cause)中的 Promise.any 一起标准化的总错误，该提案已经在 Chrome、Firefox、Safari 和 Node.js 中实现

“当你有不同的错误来源时，总错误被用于这种情况:当你在做不同的过程时，你会得到一堆错误，这些错误只与它们是由相同的活动引起的这一事实相关，”特尔森说。

“错误原因建议”是一种将导致其他错误的错误联系起来的方法，例如，将网络请求作为将使用该网络请求的更大操作的一部分。通常，如果网络请求失败，开发人员会抛出一个错误，这不会提供任何由于网络请求失败而导致操作失败的上下文。

使用 Error Cause，开发人员可以抛出一个错误，包括一个带有 Cause 属性的错误代码，该属性记录了提交了多少个请求，每个请求都有自己的错误和更多信息，这些错误可以依次链接更多的错误。

“它让你捕捉一个错误并抛出一个有更多上下文的错误，同时保留原来的错误，”Terlson 说。

还有一些有趣的提案只到了第二阶段——有了完整的规范，提案可能会继续发展并成为 ECMAScript 的一部分，但还没有足够的共识来签署一个可以在实现中测试的完整规范。

## 记录和元组进行更好的匹配

用户界面开发人员会对第二阶段[记录和元组](https://github.com/tc39/proposal-error-cause)提议感兴趣，该提议为界面开发中经常使用的不可变数据结构提供了一流的支持。如今，这是通过像 Immutable.js .和 Immer 这样的库来实现的，但是在 JavaScript 语言中实现这一点将使新的`Record`和`Tuple`数据结构更容易调试。

帕尔默说:“`Record`类似于一个冻结的物体，`Tuple`类似于一个冻结的阵列。”因为它们是原语而不是对象(对象具有同一性)，并且它们通过值进行比较，所以您可以比较包含相同内容的两个单独的对象，比如一个人的名字，即使它们在不同的对象中，每个对象都有自己的同一性，它们也会被认为是相同的。

如果您使用这个名字作为映射的键，那么您希望能够在代码的其他部分进行查找，在那里您生成一个新的记录，但是希望找出这个人的名字是否在映射中。使用记录和元组，您将获得匹配而不是失败，因为新记录是一个全新的身份对象。

“以前，当你想对多个事物使用组合键时，人们不得不尝试一些技巧来使地图工作良好，比如用不同字段之间的特殊标记将内容序列化为字符串，以便按值比较字符串，”帕尔默说。

将对象的内容读入字符串是引入错误的机会；现在你可以使用适当的语言结构，并使用常规的三重等式比较。

Palmer 建议说，这对于 JSON 风格的深度对象树的比较特别有用。"你会得到一种更具语义风格的平等."

使用`===`还可以提高性能，减少呈现用户界面的计算量。

“一个常见的功能模式，就像你在 React 中看到的，是你检查你的数据属性，并查看自上次渲染以来它们是如何变化的，”帕尔默说。“你可以做优化:如果我的输入数据没有改变，我希望渲染图保持不变，所以你不需要重新计算它。”

他认为语法没有现有的库那么麻烦:“这提供了一种处理不可变数据结构的真正、简洁、清晰的方式。此外，如果你是一个图书馆作家，你现在有一个共同的货币与世界其他地方交换。它标准化了传递不可变数据的方式。”

## 管道操作符仍在管道中

其他一些有趣的提议不太可能成为 ECMAScript 2022 时间表。

大多数脚本环境都有一个管道操作符，允许您将一个函数的输出“管道”到另一个函数中(管道也广泛用于函数式编程)。如果没有管道操作符，您必须构建一个难以阅读的嵌套函数层次结构，或者创建和管理临时中间变量来存储和传递函数间的结果。

到目前为止，JavaScript 还没有一个原生管道选项(尽管有许多库添加了它)，添加这个是 JS 2020 调查的[州的四大请求之一。](https://2020.stateofjs.com/en-US/opinions/#missing_from_js)

多年来，关于如何在 JavaScript 中使用管道已经有了[许多建议，目前有几个](https://github.com/tc39/proposal-pipeline-operator/blob/main/HISTORY.md)[竞争建议](https://gist.github.com/tabatkins/1261b108b9e6cdab5ad5df4b8021bcb5)遵循 F#或 Hack 语言中采用的方法。

[黑客风格的提议](https://github.com/tc39/proposal-pipeline-operator)已经进入第二阶段，已经有 Babel 的插件和 Firefox 中支持新操作符的功能标志，但也有[正在进行的讨论](https://github.com/tc39/proposal-pipeline-operator/issues/221)关注对浏览器引擎内存和性能的影响，因此管道操作符仍然是绝对实验性的，似乎不太可能出现在 ECMAScript 2022 中。

<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 68 31" version="1.1"><title>Group</title> <desc>Created with Sketch.</desc></svg>