<html>
<head>
<title>Reactive Programming for the New Mobile Stack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">针对新移动堆栈的反应式编程</h1>
<blockquote>原文：<a href="https://thenewstack.io/new-mobile-stack-reactive-applications/#0001-01-01">https://thenewstack.io/new-mobile-stack-reactive-applications/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">


<p class="translated"><a href="https://realm.io/" class="clearfix infoBlock " target="_blank"> <div class="infoBlockTextBlock"> <p class="infoBlockTitle">亚历山大·斯蒂格森</p> <p class="infoBlockText">亚历山大是领先的移动数据平台Realm的联合创始人兼首席执行官，该平台嵌入了超过35亿个移动应用程序。</p> </div> </a></p><p class="translated">当一项技术进步开始时，行业的其他部分必须利用他们所拥有的任何工具来赶上这项技术的潜力。这就是为什么，即使我们已经有了十年的iPhone，我们仍然在努力开发能够充分利用其功能的应用程序。</p>
<p class="translated">问题其实并不在于iPhone，而在于大多数优秀的应用程序只有连接到服务器，进而连接到其他用户和客户端，才会变得优秀。这是出色移动工作的基础。这意味着移动堆栈也需要服务器和后端堆栈。</p>
<p class="translated">移动应用程序所依赖的服务器端堆栈看起来很像web堆栈，并且遵循web模式，因为这是我们开始的地方。我们采用了服务器端框架，使用它们构建RESTful APIs变得更容易，并要求JSON来响应我们的网站曾经提出的相同请求。这些是我们拥有的工具，我们肯定让它们发挥了作用——在过去的十年里，流式传输数据也变得更加容易，而不是简单地坚持请求和响应，这对于始终连接的移动设备来说肯定感觉更加自然。</p>
<blockquote><p class="translated">当您最终将后端和移动团队集合在一起时，您可能会注意到仅仅让两个堆栈相互通信就要花费多少工作。</p></blockquote>
<p class="translated">但是在植根于网络的堆栈上构建的成本是巨大的。当您最终将后端和移动团队集合在一起时，您可能会注意到仅仅让两个堆栈相互通信就要花费多少工作。对于应用程序中的每个视图，以及你可以在该视图中采取的每个操作，你必须解决一个难题:如何让移动应用程序用服务器端世界的语言说话，这种语言在我们理解移动应用程序需要什么之前就已经发展了。</p>
<p class="translated">让两个不相称的堆栈一起工作的最大、最痛苦的问题是处理应用程序的数据。首先，你要运输它。这意味着为您的后端工程师构建端点，为您的移动开发人员构建和解析对这些端点的请求。在这个过程中，您还必须多次序列化您的数据:从后端数据库上的SQL到可以通过网络发送的JSON，最后到您可以在移动应用程序中以一种有帮助的方式进行交互的东西。最后，您需要持久化这些数据，以便于使用和高效地存储和访问，这目前意味着精通两种不同的数据库技术，比如服务器上的PostgreSQL，以及设备上的SQLite和相关的ORM。</p>
<p class="translated">在这种微妙舞蹈的每一步中，每当这条道路上的任何代码发生变化时，都会出现脆弱性。这种脆弱性对两个团队的工程师都有影响。</p>
<h2 class="translated">新移动堆栈的四个原则</h2>
<p class="translated">如果问题是用数据做事情，那么解决之道在于理解移动应用程序需要从它们的数据和数据库中得到什么。</p>
<p class="translated">考虑到这一系列问题，以及我们如何在Realm解决这些问题，我为新的移动堆栈制定了四个原则:</p>
<h3 class="translated">1.事件驱动的</h3>
<p class="translated">移动开发必须是事件驱动，而不是请求驱动。应用程序充满了按钮和动作以及使用的后果，HTTP请求或流协议是我们必须硬塞进这些动作的东西。或者，让我们简化创建和同步应用程序行为核心的事件，并在客户端和服务器上对这些事件做出反应。</p>
<p class="translated">在这一过程中，我们最终会将大量逻辑从请求成功回调转移到在创建或更新数据时调用的函数中。</p>
<h3 class="translated">2.数据必须流动</h3>
<p class="translated">数据必须流动，而不是被推动或请求。我们可以想当然的认为，app使用会产生数据。我们应该能够理所当然地认为，数据可以同步到服务器和其他客户端，而无需编写我们当前需要做的所有网络和序列化代码。数据流应该从数据操作中抽象出来，让您专注于为用户使用数据。</p>
<p class="translated">我们还需要明确我们的数据如何移动的能力，通过让开发人员控制冲突解决方案，以及让用户知道他们的数据是否是新的和主动同步的工具。</p>
<h3 class="translated">3.数据棒</h3>
<p class="translated">当您离线时，数据应该还在。移动使用意味着你不会一直保持联系——现在，你只需要关上电梯门，就能看到你使用应用程序的能力是多么薄弱。有了持久的本地数据，您仍然可以访问、创建和编辑使应用程序有用的数据。</p>
<h3 class="translated">4.实用逻辑</h3>
<p class="translated">任何移动开发人员都应该能够编写服务器端和客户端逻辑。你不应该依赖后端团队来发布移动功能。相反，您应该能够编写响应数据更改的服务器端、无服务器的代码，并且能够访问允许您监视和运行代码的环境，而无需学习全新的框架和语言。</p>
<h2 class="translated">新的希望:将移动堆栈付诸实践</h2>
<p class="translated">综上所述，这些原则为开发优秀的应用程序提供了一个移动优先的视角。它们提高了开发人员的工作效率和幸福感，并消除了我们在试图维护复杂的移动应用时所面临的巨大挑战。我们只需要工具来体现这些原则。</p>
<p class="translated">新方法的核心是这些想法——反应是每一个操作的基础。通过从一开始就在数据层中构建无缝的实时同步，只需几行代码就可以在服务器和数据之间自动同步数据。即使同步停止并离线，这些数据也会保留在本地客户端数据库中，以便您的应用不会因用户连接而中断。</p>
<p class="translated">您还可以获得构建复杂应用所需的所有服务器端工具，但采用移动优先的架构，包括访问控制和身份验证，移动开发人员无需任何服务器端代码即可实现。</p>
<p class="translated">新的移动堆栈正在建立，希望开发人员可以利用反映移动需求和最佳工作的技术来创建他们真正梦想的应用程序。开发人员需要一个学习曲线来学习如何使用这些创新工具构建反应式移动应用程序，这些工具是新移动堆栈的一部分，这就是为什么我们创建了<a href="https://academy.realm.io/" class="ext-link" rel="external "> Realm Academy </a>，这是一个全面的免费存储库，包含书面、音频和视频内容以及关于最流行的移动开发工具和方法的培训，涵盖苹果iOS、谷歌Android和其他移动平台。面向那些希望学习和完善他们使用最新解决方案的技能的有经验的开发人员，目标是让每个人都能够不受干扰地工作，没有牺牲，或者不必不断适应早在任何人拥有iPhone之前就存在的堆栈。</p>
<p class="attribution translated">贾米森·麦克安迪<a href="https://unsplash.com/photos/uf4oyaimWwg" class="ext-link" rel="external ">通过Unsplash </a>拍摄的特写图片。</p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
<title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>

</div>
</div>    
</body>
</html>