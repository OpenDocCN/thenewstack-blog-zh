# 关于僵尸代码，架构师应该知道什么

> 原文：<https://thenewstack.io/what-architects-should-know-about-zombie-code/>

“死代码”，也称为僵尸代码，指的是驻留在应用程序和公共库中的、不被任何当前服务调用的不可访问的遗留代码。它以不可预测的方式出现，并随着时间的推移而增长，导致技术债务，并为网络攻击带来未知的潜在安全风险。

## 什么是僵尸代码，我们为什么要担心它？

死代码在整个 Java 社区中并没有被广泛谈论，但是它确实存在。在 [vFunction](https://vfunction.com/) 中，我们称之为僵尸代码，因为如果它“真的死了”,它不会在开发人员不知道的情况下被不可预测地访问——如果无人管理，它会变得越来越危险。

[https://www.youtube.com/embed/RG-QaXfSbHY?feature=oembed](https://www.youtube.com/embed/RG-QaXfSbHY?feature=oembed)

视频

因此，虽然许多开发人员可能没有意识到僵尸代码的存在，但它仍然需要一些关注。如果您是一名架构师或开发人员，希望重构您的遗留系统，并开始一个持续现代化的过程，这将帮助您尽早消除技术债务。

## 事实 1:僵尸代码很难被发现

如果您意识到这一点，那么“死代码”可能是您更熟悉的术语。死代码通常被称为不可访问的代码——它驻留在永远不会被访问的服务或应用程序中。

 [奥利弗·怀特

奥利弗·j·怀特是 vFunction 的社区关系总监。自 2007 年以来，他一直在帮助 ZeroTurnaround(被 Perforce 收购)和 Lightbend 等公司和初创公司讲述他们的技术故事，并建立数字内容社区。](https://cz.linkedin.com/in/thinkingoutloud) 

假设您继承了一个遗留应用程序，该应用程序随着时间的推移根据新的功能和用户需求进行了重大的更新。曾经需要的遗留代码现在不再使用某个功能，所以代码仍然在那里，但是没有被使用。作为开发人员或架构师，您很少能洞察哪些功能和代码不再被使用。

理论上来说，你永远不会碰这个代码。根据这种死代码的复杂性，IntelliJ IDEA 或 Visual Code Studio 等集成开发环境(IDE)可能会指出它，这意味着您可以删除它。然而，对大多数人来说，有些情况下，由于代码应该运行的上下文，不可能识别出不运行的代码。

这需要额外的工具，如分析器和运行时的动态分析，以真正了解代码是否被使用。如果它真的是死代码，它永远不会在您的生产应用程序的上下文中运行，尽管它可能会运行并包含在您的测试中。虽然测试覆盖率有利于确保基本的安全措施，但它也使得这些代码极难找到。

请记住:僵尸代码是前几年遗留下来的，即使您的系统现在可能以不同的方式运行，相同的遗留代码和类仍然会被调用到您的项目中。没有人真正知道它将如何被使用；这些类可以通过不同的 API 调用，也可以不调用。正是这种缺乏透明性和可预测性使得应用程序中的死代码充满风险。

## 事实 2:僵尸代码积累了技术债务(不应该被忽视)

寻求使遗留应用程序现代化的开发团队可能会试图摆脱“不要碰任何东西，因为它可能会坏掉”的心态。然而在这里，人们不禁要问，如果代码正在被测试(不知何故)并且没有破坏任何东西，为什么我们不能忽略死代码呢？

简而言之，死代码随着时间的推移而积累，直到它的技术债务水平大到开始阻碍开发。事实上，高速开发团队会以死代码的形式更快地积累技术债务。

让我们看看在遗留系统中保留死代码的最佳情况。您可以简单地继续测试和维护这些永远不会运行的代码。那么你只是在浪费时间和资源在实际上不做任何事情的代码上。

现在，最坏的情况是，这段代码已经有一段时间没有被维护或正确测试了。如果你是一名开发人员，正在添加新的功能，没有什么可以阻止你偶然发现这些死代码——它没有被跟踪、监控或识别。

这意味着一个古老的、被遗忘的类可以很容易地通过添加到应用程序功能中的一些新的行为路径复活。因为没有人知道它的存在，所以您不能确信这个死代码不会在以后的应用程序中产生下游问题。

## 事实 3:僵尸代码随着时间的推移增加了复杂性

到目前为止，我们已经讨论了僵尸代码的类型，它更像是额外的包袱，只是随波逐流，并没有真正打扰到任何东西(我们希望如此)。然而，随着死代码的积累，它很容易变得更加复杂。

想象一个场景，其中 Java 类被用在几个域中，多个服务可能以不同的方式使用同一个类。某个服务可能以一种方式使用一个类，而不同的服务将以不同的方式使用同一个类，调用不同的代码路径。

当我们只在特定服务的上下文中分析特定的类时，那么所有不是从该特定服务调用的都可以被视为死代码。如果我们采用同一个类，并查看它在另一个服务中的使用情况，那么一半的代码将会失效，但标准代码覆盖测试和应用程序性能管理(APM)工具(如 New Relic 和 Datadog)会显示这些类正在运行。没有死代码，对吧？

不完全是。这是您开始查看运行时环境的地方，而不是您的 IDE 可能能够标记的特定类。这是整个调用树和一个接一个被调用的类栈。只有通过查看基于服务、域和端点的类调用位置的上下文，您才能深刻理解代码中哪些路径不应该在那里。

这是您需要从静态和动态分析中获得更好的智能的地方(顺便提一下，我们在 [vFunction](https://vfunction.com/) 中所做的),以识别导致混乱、复杂和破坏代码模块化的更复杂的死代码类。

## 事实 4:僵尸代码是一个潜在的安全威胁

如果您是一名架构师或开发人员，查看您的代码库，您通常会花更多的时间在您实际工作的类上，而不是您的遗留系统中的其他 1000 万行代码。

僵尸代码的本质是，除非某些东西在编译时出错，否则从事项目的大多数开发人员都不知道这些代码的存在。无法洞察完整的代码库不仅对生产力是一种风险，对安全性也是一种风险。

除了 T2 著名的 Equifax 和雅虎等公司的数据泄露事件，最近一个名为大象甲虫的组织发现了一种利用遗留 Java 应用的方法，价值高达数百万美元。因此，众所周知，传统技术为网络攻击提供了机会。

这就是技术债务露出丑陋嘴脸的地方:你的代码库中的死代码仍然被同样的工具扫描，但是它没有以同样的方式被维护。五年或十年前编写代码时开始的过程和最佳实践不太可能在今天仍然适用。

因此，如果您没有看到这些堆积如山的死代码，还有谁会看到呢？这里的安全威胁是死代码不会影响您的普通用户。这意味着任何试图找到它的坏人都有可能利用遗留漏洞利用它。

## 事实 5:你可以手动(DIY)或使用自动化和人工智能来消除僵尸代码

搜索僵尸代码有点像试图用望远镜看到黑洞——更多的是检测某种东西的缺失，而不是见证它的存在。当查看您的应用程序的 Java 类的星座时，您需要寻找中间黑暗的地方。

那么，手动识别和销毁您自己的遗留系统中的僵尸代码会是什么样的呢？DIY 过程从哪里开始，看起来如何？

这里列出了手动分析系统死代码的过程和想法。当然，这一切都始于意识，就像任何关于好的软件工程的事情一样。

1.  **不要放过**:你是否发现了一段看似熟悉但却不知道用途的代码？下一次，不要跳过它:将它标记为以后的调查，作为删除死代码的第一个主动步骤。
2.  **使用代码覆盖工具**:如果你使用这些工具，再深入挖掘一下，看看各种工具覆盖了或者没有覆盖哪些类。如果某个类根本没有被覆盖，在测试之后，您可能会认为它是死代码。
3.  **创建特定的测试**:如果你偶然发现可疑的代码，考虑创建一组简单的特定测试来发现为什么它没有被覆盖。一些测试会与一个特定的服务或者模块相关，所以你可以看到那些特定部分的覆盖范围，而不是整个系统的所有测试。
4.  **利用 APM 平台**:如果您的生产系统中运行有诸如 New Relic、Datadog、AppDynamics 或 Dynatrace 等 APM 工具，您可以使用这些数据与您的覆盖报告进行比较，以查看哪些路径被覆盖。

如果您能够手动准备和运行这些不同的测试场景，那么这对您是有好处的！但是输出是什么，你如何把所有的东西整合在一起？

想象一下，一个遗留应用程序有 10，000 个 Java 类，您需要在整个团队中分配手动交互、测试创建、CI/CD 管道部署，并深入研究结果报告和日志。团队中不同水平的专业知识和动机会使工作难以分配。

动态流程提供了基本信息，为您提供了贯穿系统的真实生产流程。死代码本身不会在这些流程中运行，所以您需要进行静态分析，并对那些特定流程中没有出现在动态分析中的部分进行切割。

现在，让我们看看另一种替代方案，使用人工智能(AI)和自动化来完成繁重的工作。

## 如何消灭僵尸代码— AI +自动化

DIY 现代化过程对于大多数团队来说是相当沉重的负担；除非您的组织能够获得执行团队的认可，将您最优秀、最有经验的工程师从他们的核心目标中重新分配出去，否则任何现代化项目都将是困难的。

遗留下来的巨石柱呈现出工程师们必须处理的具有挑战性的现实问题。那么，如果我们可以自动化这个过程的一部分甚至大部分，会怎么样呢？与花费数周或数月来分析 monolith 中的一些类相比，安装软件来完成这部分工作最终只需要几分钟或几小时。

死代码必须删除，但是很难知道具体在哪里。一个类中与其他三个必需的类相关联的相互依赖性不能简单地被消除。我们支持迭代测试和重构，这样你就可以决定是否重构第一个类并去掉另外两个类。

利用人工智能的自动化分析是我们在 vFunction 做的事情。我们的专利分析方法将动态分析与静态分析在您的领域、服务和应用环境中进行比较。通过编制一张所有事物的地图，你能够快速识别依赖图中的黑洞，给你一个开始的地方。

vFunction 不是显示单个数据点的长篇报告，而是将所有内容汇集到一个大画面中，以便您可以看到正在发生的事情，然后找出如何采取行动。

如果你厌倦了像我们一直在谈论的那样管理旧系统，你可以访问[vfunction.com](https://vfunction.com/)并查看我们的[投资回报率计算器](https://vfunction.com/roi-calculator/)。这将使您了解每年维护遗留应用程序的成本，并有可能帮助您获得现代化计划的项目支持。

<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 68 31" version="1.1"><title>Group</title> <desc>Created with Sketch.</desc></svg>