<html>
<head>
<title>Tutorial: Tame Your Access Log with Unix Pipes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">教程:用Unix管道驯服您的访问日志</h1>
<blockquote>原文：<a href="https://thenewstack.io/tutorial-tame-your-access-log-with-unix-pipes/#0001-01-01">https://thenewstack.io/tutorial-tame-your-access-log-with-unix-pipes/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">


<p class="translated">上个月，开发人员社区注意到了Jessie Frazelle的一篇博客文章，她是一位受人尊敬的程序员，曾在Docker、Google和微软等知名公司工作过，并将自己描述为“所有Linux容器的黑客”在博文中，Frazelle解释了<a href="https://blog.jessfraz.com/post/for-the-love-of-pipes/" target="_blank" rel="noopener noreferrer external " class="ext-link">为什么她欣赏Unix的pipe命令</a>，称其为“卓越的软件设计……能够激发创造力，重视简单性，并且不会将用户限制在一个盒子里。”</p>
<p class="translated">“程序简单并且能做好一件事，就容易被破解。不过，美妙之处在于，与|这样的运营商相结合，该计划成为一个更大计划中的一步。”</p>
<p class="translated">我不得不同意。我的一个朋友曾经开玩笑说，你可以为Unix中的任何东西编写一个命令——但是那个命令可能有六行长，用管道连接一长串。</p>
<p class="translated">让我分享我自己最喜欢的真实世界的例子——使用管道从典型的web服务器的访问日志中提取一个非常方便的报告——一系列命令实际上有它们自己丰富多彩的历史。</p>
<h2 class="translated">半个世纪的管道？</h2>
<p class="translated"><a href="https://www.cs.dartmouth.edu/~doug/" target="_blank" rel="noopener noreferrer external " class="ext-link">道格·麦克洛伊</a>，从1965年到1986年领导贝尔实验室著名的计算技术研究部门，在50多年前首先提出了管道的想法。他在1964年写道“我们应该有一些耦合程序的方法，就像一个花园软管一样，”<a href="http://doc.cat-v.org/unix/pipes/" target="_blank" rel="noopener noreferrer external " class="ext-link">——他实际上是在打字机上敲出来的——他说这种方法可以让程序员“在需要以另一种方式处理数据时，拧入另一个程序段。”</a></p>
<p class="translated">它直到1973年才真正实现，但是麦克洛伊认为这是导致Unix哲学的发展，它将强大的个人工具结合起来，每个工具做好一件事。</p>
<p class="translated">13年后的1986年，当他吹捧pipes是数学传奇人物Donald Knuth编写的10页Pascal程序的高级解决方案时，他仍然在想这个问题。</p>
<p class="translated">Knuth的程序报告了文本文件中最常用的单词，并发表在计算机械协会通讯中Jon Bentley的“编程珍珠”专栏中。道格·麦克洛伊写了一封信来回应称赞Knuth聪明的专栏——然后他指出,<a href="http://www.leancrew.com/all-this/2011/12/more-shell-less-egg/" class="ext-link" rel="external ">同样的事情只用六个Unix命令通过管道</a>连接就可以复制。</p>
<p class="translated"><code class="">tr -cs A-Za-z '\n' |<br/> tr A-Z a-z |<br/> sort |<br/> uniq -c |<br/> sort -rn |<br/> sed ${1}q<br/> </code></p>
<p class="translated">“UNIX老手本能地知道如何在瞬间解决这个问题……”麦克洛伊写道，并补充说“上面给出的简单管道将足以立即得到答案，而不是下周或下个月。”</p>
<p class="translated">当我读到这个例子时，我很激动，因为我自己也偶然发现了麦克洛伊的部分解决方案——有用的三命令组合<tt>sort | uniq -c | sort -rn </tt></p>
<h2 class="translated"><strong>管道与您的访问日志</strong></h2>
<p class="translated">多年来，我一直使用相同的组合来处理来自我的web服务器的访问日志的数据(几十年来,一直遵循一种标准化的格式，包括每个请求的日期、时间和时区，以及它的起始IP地址和关于推荐者的任何信息)。</p>
<p class="translated"><code class="">68.186.130.95 - - [15/Feb/2019:08:18:46 -0800] "GET /sloop-john-b.htm HTTP/1.1" 200 2106 "https://www.google.com/" "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit<br/> /537.36 (KHTML, like Gecko) Chrome/72.0.3626.96 Safari/537.36"</code></p>
<p class="translated">我想知道的是是否有人给我的网站带来流量——以及在某一天哪些页面最受欢迎。</p>
<p class="translated">救援管道…</p>
<p class="translated">这有点像组装的，但是我注意到被访问的文件的名称总是第七个文本块(用空格分隔)。Unix的<em> awk </em>命令确实可以让您打印出一行中的特定部分，在定义(用F标志)分隔这些部分之后。在我的例子中，那是一个空格。</p>
<p class="translated"><code class=""><tt> cat access.log | awk -F" " '{print $7}'</tt></code></p>
<p class="translated">这个命令给出了前一天访问过的每个文件的列表——将它们显示在我的屏幕上。显然，我可以将它们输入Unix的less命令，一次读取一屏——但是我真正想要的是一个只列出今天访问过的每个文件的报告——每个文件只列出一次<em/>——理想情况下，从访问最多到访问最少排序(并显示计数)。</p>
<p class="translated">幸运的是，这正是<tt>sort | uniq -c | sort -rn </tt>所做的。sort命令将整个列表按字母顺序排列——这允许uniq命令删除(同时计数)所有相邻的重复项。这个列表的唯一问题是它没有按照从大到小的顺序进行排序，但是通过sort命令第二次输出可以很容易地解决这个问题，这一次使用它的r标志表示“逆序”，最大的数字优先。</p>
<p class="translated"><code class=""><tt> cat access.log | awk -F" " '{print $7}' | sort | uniq -c | sort -nr </tt></code></p>
<p class="translated">然后将所有内容输入到<em> more </em>命令中，这样你就可以一次读满屏幕。</p>
<p class="translated"><code class=""><tt> cat access.log | awk -F" " '{print $7}' | sort | uniq -c | sort -nr | more</tt></code></p>
<p class="translated">或者，如果您只想查看最近的热门话题，可以将所有内容都输入到<em> tail </em>命令中。</p>
<p class="translated"><code class=""><tt> access.log | awk -F" " '{print $7}' | sort | uniq -c | sort | tail -20</tt></code></p>
<p class="translated">这是这些管道命令字符串中未被欣赏的乐趣之一。你可以改变一个参数，而你的光荣管道的其余部分仍然工作——这使得它非常容易实验替代输出。例如，我可以通过改变awk命令打印出的访问日志的哪一部分来生成同样有用的报告。比方说，我想看看哪个网站发送了最多的推荐，而不是哪些页面被浏览了最多。只需用<em> $print 11 </em>替换<em> print $7 </em></p>
<p class="translated"><code class=""><tt> cat access.log | awk -F" " '{print $11}' | sort | uniq -c | sort -nr | more</tt></code></p>
<p class="translated">例如，如果你只想看到来自谷歌的流量，这是很方便的。</p>
<p class="translated">有趣的实验才刚刚开始。这条管道最终成为一种存根，我用它来生成其他几个有用的日志处理报告。我编写了脚本，使用grep来查找对某个特定页面的访问——然后将它们放入我的Unix bin中，并给它们一个别名，这样，在命令行中键入一个单词，就会神奇地显示出相应网页今天被访问的频率报告。</p>
<p class="translated"><code class=""><tt>grep 'pagename' access.log | awk -F" " '{print $11}' | sort | uniq -c | sort -r | more</tt></code></p>
<p class="translated">有时我也会搜索<strong> access.log.0 </strong>(和access.log一起)来得到一份48小时的报告，其中也包括昨天的流量。</p>
<p class="translated">在我看来，烟斗的唯一问题是那种“沉醉于权力”的感觉。很快我就用Perl脚本复制了同样的功能，然后把它们都放在我的网络可访问的cgi-bin中，这样我就可以用我的网络浏览器访问我自己开发的实时网站分析。然后，我将它与Firefox的关键字功能结合起来，这样只需在浏览器中键入“hits”一词，而不是一个URL，就可以将我带到那个CGI脚本的URL——这将立即调出最新的报告(从我的访问日志中新抓取的)。</p>
<p class="translated">就在这个时候，我意识到我的朋友是对的。</p>
<p class="translated">您会有一个强大而不可动摇的信念，无论您想对可用的数据进行何种神奇的转换…</p>
<p class="translated">…几乎可以肯定，您可以通过一长串管道命令来实现这一点。</p>
<p class="attribution translated">专题图片:Paul Goyette创作的一堆管道的知识共享照片</p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
<title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>
</div>
</div>    
</body>
</html>