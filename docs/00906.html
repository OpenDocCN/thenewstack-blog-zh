<html>
<head>
<title>How Paybase Overcame Default Kubernetes Security Settings for PCI DSS Compliance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Paybase如何克服默认的Kubernetes安全设置以实现PCI DSS合规性</h1>
<blockquote>原文：<a href="https://thenewstack.io/how-paybase-overcame-default-kubernetes-security-settings-for-pci-dss-compliance/#0001-01-01">https://thenewstack.io/how-paybase-overcame-default-kubernetes-security-settings-for-pci-dss-compliance/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">


<p class="translated">“想象一下，你在一个复杂的支付平台的基础设施上工作了一年多，但在渗透测试不到30分钟的时间里，整个生产集群就完全暴露了。我们说的是能够绕过防火墙规则，获得你无法获得的谷歌云服务——所有这些都是在一个小小的容器内完成的。”</p>
<p class="translated">安娜·卡林(Ana Calin)最近在T2举行的QCon伦敦会议(QCon London talk)上谈到了通过Kubernetes在云中实现灵活支付的风险和回报，她就是这样开始演讲的。Calin是T4 Paybase T5的系统工程师，这是一家API驱动的支付服务提供商，专注于市场、gig共享经济和加密货币。凭借难以获得的<a href="https://www.incapsula.com/web-application-security/pci-dss-certification.html" target="_blank" class="ext-link" rel="external "> PCI DSS(数据安全标准)Level One </a>合规性，Paybase旨在让客户更容易进行监管。当这些企业决定是自己成为受监管的支付机构，还是通过与第三方整合来节省资金时，他们的解决方案非常方便。</p>
<p class="translated">Calin提供了一些方法，他们能够克服Kubernetes托管解决方案中的一些默认安全障碍，以实现最高级别的合规性——尽管监管机构通常缺乏对容器技术的了解。</p>
<h2 class="translated">防止Kubernetes妥协的两种方法</h2>
<p class="translated">这种妥协来自于Paybase生产集群的内部基础设施渗透测试，该测试在客户积极使用之前进行。测试人员最终通过在容器中提供的访问权限，获得了他不应该获得的Google云服务的访问权限。</p>
<p class="translated">Calin分析了造成这种安全危害的原因，以及采取了哪些缓解措施来防止未来的攻击。这不是一个详尽的Kubernetes安全入门，而是一个团队关于他们默认发现的错误的故事。</p>
<h3 class="translated">薄弱环节#1:谷歌Kubernetes引擎</h3>
<p class="translated">Google Kubernetes Engine (GKE)是Google云平台的Kubernetes托管服务，1.12.0之前的版本带有一些默认不安全的选项:</p>
<ul>
<li class="translated">计算引擎范围—这是从GKE到谷歌计算引擎(GCE)的读写访问范围</li>
<li class="translated">默认服务帐户-默认情况下，这与GCP的编辑角色相关联。GCP的服务帐户允许在给定的GCP服务和其他服务之间进行编程访问。默认情况下，任何Google项目提供的默认服务帐户都具有编辑角色和编程访问权限，可以编辑Google Cloud中的任何服务，包括更改防火墙规则。</li>
<li class="translated">默认情况下，旧元数据端点处于启用状态。通过查询GKE集群中的元数据端点，您可以以kubelet的身份访问Kubernetes API，kube let是在集群中的每个Kubernetes节点上运行的代理，它确保容器在pod中运行。您可以使用它从任何节点或计划的pod读取机密。在1.12.0版本中，默认情况下这是禁用的，但任何以前的版本仍然存在风险。</li>
</ul>
<p class="translated">Calin警告说，如果不指定非默认的服务帐户，并且不禁用节点的元数据端点，有人就可以访问Kubernetes APIs的某些秘密。</p>
<h3 class="translated">薄弱环节2:舵柄</h3>
<p class="translated">Helm是一个开源工具，用于简化Kubernetes应用程序的安装和管理。<a href="https://helm.sh/docs/glossary/" target="_blank" class="ext-link" rel="external "> Tiller </a>是Helm的服务端组件，负责管理图表的发布，这些图表是打包在一起的Kubernetes模板化资源。</p>
<p class="translated">Helm的文档已经建议您永远不要在集群中提供所有默认选项的Tiller，但是，在Paybase，虽然该平台仍在开发中，没有用户，但他们保留了这些默认选项，并计划在产品上线前更改它们。</p>
<p class="translated">“我们这样做了，但我们说我们以后会改变它，并决定保留默认设置，以便进行渗透测试，看看设置会在多大程度上受到损害，”Calin说。</p>
<p class="translated">Tiller自带<a href="https://en.wikipedia.org/wiki/Mutual_authentication" target="_blank" class="ext-link" rel="external "> mTLS(相互传输级安全)客户端和服务器之间基于密钥的认证</a>，默认禁用。任何危及Tiller安全的人——比如Calin的pen tester——都拥有集群管理权限，这是Tiller正常工作所需的集群管理Kubernetes基于角色的访问控制(RBAC)角色。然后，他们可以随意删除或提供任何内容。</p>
<p class="translated">为了减轻这种情况，Calin说要用mTLS来启用Helm。或者，你可以在你的集群中运行不带舵柄的舵轮-“<a href="https://rimusz.net/tillerless-helm/" target="_blank" class="ext-link" rel="external ">不带舵柄的舵轮</a>”。</p>
<p class="translated">至少，她建议将Tiller绑定到localhost，这意味着Tiller将只监听运行它的pod的IP地址。</p>
<p class="translated"><img decoding="async" loading="lazy" class="aligncenter" src="../Images/90993d4e9962d270941a4b242c50a0ed.png" alt="" data-id="7004340" data-original-src="https://cdn.thenewstack.io/media/2019/03/9e0ab315-kubernetes-mitigation-final-1024x577.png"/></p>
<h2 class="translated">安全性和弹性:安全的Kubernetes集群</h2>
<p class="translated">在提供了可能使您的集群处于风险中的两种配置之后，Calin进入了他们发现的更安全的Kubernetes集群所必需的基础知识——因为没有什么是不可穿透的。</p>
<p class="translated">她提到了最低特权原则，她说你应该只允许工程师做他们工作绝对需要的事情。</p>
<p class="translated">Calin还建议您根据需要使用<a href="https://kubernetes.io/docs/concepts/services-networking/network-policies/" target="_blank" class="ext-link" rel="external "> Kubernetes网络策略</a>来限制对某一组pod的流量访问，或者应用启用授权规则的<a href="https://istio.io/" target="_blank" class="ext-link" rel="external "> Istio </a>设置来限制流量访问。</p>
<blockquote><p class="translated">“无论你在构建什么，你都应该始终假设它会失败，有人会破坏它。”—安娜·卡林，薪酬基础</p></blockquote>
<p class="translated">她继续说，您应该编写<a href="https://kubernetes.io/docs/concepts/policy/pod-security-policy/" target="_blank" class="ext-link" rel="external "> pod安全策略</a>，以便“如果您的集群通过容器受到危害，攻击者只能部署具有特定权限的Pod，并且被限制将主机文件系统挂载到新创建的Pod中。”</p>
<p class="translated">对所有软件的一个很好的保证是启用基于角色的访问控制(RBAC)。默认情况下，提供Kubernetes托管服务的主要云提供商Google Cloud、Azure和AWS都启用了Kubernetes RBAC，但是，这只是最近才在Azure的Kubernetes服务下启用。</p>
<p class="translated">并且始终在集群中使用安全扫描图像。</p>
<p class="translated">Calin说一个有弹性的Kubernetes集群应该:</p>
<ul>
<li class="translated">考虑到失败和弹性，</li>
<li class="translated">具有稳定的可观测性堆栈，</li>
<li class="translated">被测试了很多，包括混沌工程。</li>
</ul>
<h2 class="translated">克服Kubernetes对PCI DSS合规性的挑战</h2>
<p class="translated">Calin将Paybase的<a href="https://en.wikipedia.org/wiki/Payment_Card_Industry_Data_Security_Standard" target="_blank" class="ext-link" rel="external ">一级支付卡行业数据安全标准(PCI DSS) </a>合规性描述为一项巨大的成就。这是对支付服务提供商(PSP)的要求，但大多数金融机构选择支付年度罚款，而不是达到这一合规水平。2017年，<a href="https://www.goanywhere.com/blog/2017/02/03/8-shocking-pci-compliance-statistics" target="_blank" class="ext-link" rel="external ">超过80%的企业</a>仍然不合规。</p>
<p class="translated">由于大多数金融机构仍然在传统的遗留体系结构上运行，当金融监管机构对分布式系统没有充分了解时，这一点尤其如此。</p>
<p class="translated">PCI请求。6.5.1声明您的应用程序不能容易受到注入缺陷的影响。为了选中这个框，Paybase利用了PQL (Paybase查询语言)，这是一种特定于领域的语言，由内部开发，受SQL的启发。Calin说PQL是抗注入的，因为它不允许变化的语法，并且具有数据库不可知的额外好处。</p>
<p class="translated"><img decoding="async" loading="lazy" class="aligncenter" src="../Images/038675493417a70d360ae7f704836a76.png" alt="Lexical analysis for tokenized input, syntactical analysis for parse tokenised input to AST, and abstract syntax tree to specific database query" data-id="7004435" data-original-src="https://cdn.thenewstack.io/media/2019/03/ff8e4b47-overcome-pci-req-6.5.1-1024x502.png"/></p>
<p class="translated">PCI请求。2.2.1表示，作为一个兼容的PSP，您只需要在每台服务器上实现一个主要功能，以防止需要不同安全级别的功能出现在同一台服务器上。</p>
<p class="translated">当然，正如Calin所说，“我们没有任何实际的服务器，标准也没有提到虚拟机，更不用说容器了。”</p>
<p class="translated">对于这个需求，Paybase将“服务器”翻译成“可部署的单元”,如pod或container。如果这种解释被广泛接受，那么容器就成了帮助遵从的合理解决方案。对工资基数来说是这样。他们通过使用限制不同服务流量的网络策略、应用不同的Pod安全策略，以及仅使用内部可信、扫描和批准的映像来满足要求。</p>
<p class="translated">PCI Req，6.4.4要求PSP在系统上线或投入生产之前从系统组件中删除所有测试数据和帐户。</p>
<p class="translated">Calin描述了“云提供商的正常方式是有一个组织，然后一个主要项目，然后在那个项目[亚马逊网络服务帐户]下，你有所有的服务。AWS建议您应该有一个帐户用于计费，然后另一个帐户用于应用程序的其余部分。然后，您可以在同一个集群内的Kubernetes命名空间级别对其进行拆分。”</p>
<p class="translated">这样，从PCI兼容的角度来看，你的范围将是谷歌云平台中的一切，因为一切都封装在同一个虚拟专用网络或VPC下。</p>
<p class="translated">相反，对于每个环境，Paybase都有不同的项目。然后他们有一些额外的项目，用于重要的事情，如图像存储库、备份和地形状态(T2)。这导致将PCI的范围缩小到生产项目，从而创建了符合法规要求的关注点分离、更容易的RBAC和风险降低。</p>
<p class="translated"><img decoding="async" loading="lazy" class="aligncenter" src="../Images/b040dd552a8a7e1419f88c59bcc606d7.png" alt="" data-id="7004590" data-original-src="https://cdn.thenewstack.io/media/2019/03/69112f2f-common-way-split-gcp-environments-1024x554.png"/> <img decoding="async" loading="lazy" class="aligncenter" src="../Images/a42042c2690c11c47a900a9fdeeaa16a.png" alt="" data-id="7004601" data-original-src="https://cdn.thenewstack.io/media/2019/03/26d2dd62-paybase-way-split-gcp-environments-1024x546.png"/></p>
<p class="translated">最后，PCI请求。11.2.1要求PSP执行季度内部漏洞扫描，以解决这些漏洞，然后重新扫描，证明所有高风险漏洞都已消除。</p>
<p class="translated">“当你在容器上运行时，你没有这样的内部基础设施。相反，我们确保所有在集群中使用过的图像都被扫描过，没有通过漏洞扫描的图像不会被创建，”Calin说。</p>
<p class="translated">“当开发人员将代码推送到我们的源代码管理时，会运行一些集成测试，并触发一个构建映像步骤。然后，如果映像构建成功，它会扫描映像中的每个包，如果映像除了低[风险]之外没有任何漏洞，它会成功地将映像标签推入GCR[谷歌云存储库]。如果扫描失败(发现高于中等风险的漏洞)，我们的开发人员就没有任何办法将该图像发布到GCR，”她继续说道。</p>
<p class="translated"><img decoding="async" loading="lazy" class="aligncenter" src="../Images/a58e765f310ec31ac7beedfb14daeef5.png" alt="A diagram illustrating image built goes through image scan. If it fails, there's no way of sending the build. If it passes, then the image is retrieved and successfully pushed into the GCM" data-id="7004620" data-original-src="https://cdn.thenewstack.io/media/2019/03/8cee5892-overcome-pci-req.11.2.1-1024x576.png"/></p>
<p class="translated">在Paybase，新的映像构建每天都在发生，因为它们运行的是由实体分隔的分布式整体，因此所有不同的应用服务都运行在同一个映像上。这可确保我们每天扫描映像中的软件包，这意味着群集中出现带有漏洞的旧软件包的可能性非常低。</p>
<h2 class="translated">开源安全是一个持续的旅程</h2>
<p class="translated">“安全不是一个时间点，而是一个永无止境的持续旅程。这只是意味着我们的工作更加安全，而不是100%安全——没有完全安全这回事，”Calin说。</p>
<p class="translated">她继续说，你肯定可以使用像Paybase is这样的开源软件，并且仍然可以获得很好的安全性。</p>
<p class="translated">“这只是需要一定的工作量，但我们是工程师，我们喜欢挑战，”她说。</p>
<p class="translated">虽然Calin喜欢好的挑战，但她确实主张尝试改变PCI合规现状。她分享了这样一个故事:Paybase雇佣了一名对容器和谷歌云服务有着一般了解的审计员，但他们仍然不得不花大量时间解释这一切是如何工作的。</p>
<p class="translated">“这不应该是我们的工作。这应该是培训合格安全顾问的人的工作，”卡林说。</p>
<p class="translated">最后，她建议工程师和团队中的每个人都应该参与进来，让你的公司符合标准。</p>
<p class="translated">“他们(工程师)知道变得顺从有多痛苦，他们会更加珍惜为了保持顺从他们必须做的事情，”Calin说。</p>
<p class="attribution translated">管理Kubernetes项目的云本地计算基金会是新堆栈的赞助商。</p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
<title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>

</div>
</div>    
</body>
</html>