# 开发人员指南，不会丢失您需要的指标

> 原文：<https://thenewstack.io/the-developers-guide-to-not-losing-the-metrics-you-need/>

[InfluxData](https://www.influxdata.com/) 赞助了这篇文章。

 [吉安卢卡·阿尔贝扎诺

吉安卢卡是 InfluxData 的 SRE。他是几个项目的开源贡献者，包括但不限于 Zend Framework、Docker 和 InfluxDB。他还是 Docker 队长，也是 doctor ORM 开发者团队的成员。他热衷于为全球开发者开发最佳实践，最近一直专注于在 AWS、DigitalOcean 和 OpenStack 之上构建可扩展的基础设施。他熟悉多种编程语言，如 Javascript 和 Golang，并在欧洲各地的会议上积极发言，分享他领导的项目的经验和知识。](https://www.influxdata.com/) 

收集和存储指标是开发人员在整个生产周期中必须完成的许多并行任务之一。因为您永远不知道不利事件何时可能发生，所以当您需要时，您有调试问题所需的度量。

但是，您不能永远存储所有指标。这甚至适用于专门构建的[时间序列数据库](https://en.wikipedia.org/wiki/Time_series_database)，比如 [InfluxDB](https://www.influxdata.com/time-series-database/) 提供的那个，它是为高基数数据设计的。当谈到可伸缩性时，时间序列数据库可能看起来“很神奇”，但它们不具备无限扩展的能力，在某些时候，即使是 InfluxDB 的工具也会达到一个极限。

时间序列数据库的局限性是您应该将存储作为一组不同大小的试管来管理的原因。当您不知道一个指标或一个跟踪是否有用时，或者如果因为收集了太多指标而导致存储变得太昂贵时，您总是可以将它们存储一小段时间。如果它们变得有用，您也可以在以后移动它们，或者在聚集它们以减少它们对您的系统的压力之后移动它们。

如果您正在使用 InfluxDB，那么您可以为您的所有指标设置一个最小保留策略(例如，只有两到三天)。然后，您可以将指标移动到另一个 InfluxDB 实例(具有更长的保留策略) [Kapacitor](https://www.influxdata.com/time-series-platform/kapacitor/) ，即 [TICK 堆栈的](https://www.influxdata.com/time-series-platform/)本地数据处理引擎。

这是一个困难的问题，但是让 ogs、traces 和 metrics 在同一个地方让我感到不舒服。最终的结果是从你的系统中很容易地聚合所有这些不同的观点。因为在一天结束时，指标和日志只是与您的系统现实不同的表示——将它们放在一起就像一个强大的水晶球，能够以更高的粒度水平回答有关您的系统状态的问题。

如上所述，存储如此大量数据的唯一方法是通过保留策略和数据聚合。一个解决方案是 [Kapacitor](https://www.influxdata.com/time-series-platform/kapacitor/) ，它可以处理来自 InfluxDB 的流和批处理数据——它允许您插入自己的定制逻辑或用户定义的函数，以处理具有动态阈值的警报，匹配模式的指标并计算统计异常。它还根据这些警报执行特定的操作，如动态负载重新平衡。

将 Kapacitor 与 InfluxDB 一起使用很简单，可以让您按原样存储数据或将其作为一个集合发送。无论哪种情况，这都是一种直接的方式，让您开始查看您的指标数据，以确定您需要保留什么——所有这些都不需要猜测。

此外，谈到收集系统和应用程序数据，今天的开发人员还谈到了[日志](https://www.influxdata.com/blog/influxdata-log-release/)事件和跟踪。访问度量标准就像能够睡个好觉，而事件就像一记耳光。您首先以漂亮的图表形式设计指标，以理解正常的系统操作。当一些事情偏离了正常的功能，当一个事件发生时，你会被一巴掌打醒。

伴随着每一次午夜意外的拍打，困惑随之而来。你环顾四周，想知道发生了什么，谁打断了你的梦，为什么，但是数据和事件并不能说明全部。这就是仅仅监控的不足之处。

在这一点上，重要的是要提醒自己，监控有助于你知道什么时候出了问题，但不能回答以下问题:

1.  这是怎么回事？
2.  我该怎么修复它，才能再次回去睡觉？

在这一点上，如果问题存在于您的应用程序中，您就要开始研究日志，看看到底发生了什么。如果你在一个小的低流量的环境里，你大概会找到你要找的东西，然后你就完事了。

但是，如果您的系统是一个复杂的系统，它可能是分布式的，或者严重依赖于第三方服务，其中日志是海量的，并且您无法通过简单地查看它们来识别出什么被破坏了——在这种情况下，您需要减少中断的范围。要做到这一点，你可以看看你的痕迹。尽管识别痕迹是一项挑战，但您可以采取两种措施:

*   首先，在日志中公开 trace_id(每个跟踪/请求的标识符)来连接它们。它将帮助您过滤特定请求的日志。
*   其次，告诉您的支持团队和客户为什么 trace_id 是必不可少的。他们应该知道这是发现正在发生的事情的关键。如果你的客户是技术人员，那么为他们提供一个 HTTP 头会更容易。如果您的客户是非技术人员，那么让您的 UI 发回适当的标识符是一个好策略。

我遇到的真实问题促使我写了这篇博客。我所写的一切都是从分布式应用程序的故障排除中获得的经验:也就是说，指标、事件、日志和跟踪并不相互排斥。它们是使调试、监控和可观察性成为可能的工具。我迫不及待地想有一个单一的解决方案来将它们组合在一起，以使我作为开发人员的生活比现在更加美好。

通过 Pixabay 的特征图像。

<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 68 31" version="1.1"><title>Group</title> <desc>Created with Sketch.</desc></svg>