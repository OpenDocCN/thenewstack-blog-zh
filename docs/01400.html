<html>
<head>
<title>Open Source Summit: Kubernetes as the New Linux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开源峰会:Kubernetes作为新的Linux</h1>
<blockquote>原文：<a href="https://thenewstack.io/open-source-summit-kubernetes-new-linux/#0001-01-01">https://thenewstack.io/open-source-summit-kubernetes-new-linux/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">


<p class="translated">尽管Linux基金会庆祝其开源操作系统内核的持续成功，但不断变化的技术格局可能会将操作系统推到一边，将另一个玩家放在众所周知的新基础设施堆栈的中心:容器编排引擎。因为编排引擎让开发人员考虑应用程序本身，而不用担心底层的操作系统。</p>
<p class="translated">“Linux已经进入了每一个市场，它已经完全占据了主导地位，”本周在洛杉机举行的<a href="http://events.linuxfoundation.org/events/open-source-summit-north-america" class="ext-link" rel="external ">开源峰会</a>上，<a href="https://twitter.com/jzemlin" class="ext-link" rel="external ">的吉姆·泽姆林</a>指出。超级计算机、嵌入式系统、大型机、云计算服务由Linux主导，移动市场也是如此，基于Linux的Android占据了82%的市场份额。</p>
<p class="translated">对于Linux，目前有4300名开发人员在开发代码库，每天增加10000行代码，修改2000行代码，删除2500行代码。代码库每小时变化八次。</p>
<p class="translated">Zemlin声称，今年，Linux第一次在本地企业服务器市场取代了Unix，仅次于Windows。今年3月，很大程度上得益于Android，基于Linux的客户端现在占据了互联网客户端的大多数，首次超过了Windows。</p>
<p class="translated">“你知道这意味着什么吗？”泽姆林问道。没错，2017年是Linux桌面的第<a href="https://www.reddit.com/r/linux/comments/3038d4/when_was_the_first_year_of_the_linux_desktop/" class="ext-link" rel="external ">年</a>，他说，这让观众非常开心。</p>

<p/>
<p class="translated">但是，即使Linux享受了另一个隐喻的胜利，它发现自己在我们正在出现的<a href="/category/cloud-native/" target="_blank">云原生时代</a>中，越来越多地扮演一个新的，也许是被削弱的角色。</p>
<p class="translated">在一次开源峰会上，<a href="https://twitter.com/llunved" class="ext-link" rel="external "> Daniel Riek </a>，一位Red Hat系统设计和工程的高级主管，解释说由于容器和云原生技术，Linux发行版的角色正在彻底改变。</p>
<p class="translated">那些已经在这个行业呆了一段时间的人总是认为，在现代软件栈中，操作系统是基础设施的关键部分。然而，云计算的原生观点将应用作为中心，使得操作系统的主要角色与基础设施分离。相反，操作系统的目的只是为应用程序提供一个公共运行时。</p>
<p class="translated">Linux发行版在很大程度上是第三方库和软件包的集合，一旦安装在PC或服务器上，往往不会得到更新。RPM和up2date、yum和apt等二进制打包方案提供了一种跨服务器标准化部署的方法，尽管这也导致了依赖地狱，用户永远无法使用该库的正确版本或发行版上可用的应用程序，或者一台机器可能需要同一库的两个冲突版本。</p>
<p class="translated">虚拟机为流程带来了一些统一性，允许组织构建预构建的映像，基本上是在每个虚拟机上放置一个服务。虚拟机使得跨不同服务共享硬件变得更加容易。此外，单个虚拟机可以跨开发、测试和生产运行。这在一定程度上减少了依赖性，尽管它造成了虚拟机蔓延的新问题，即虚拟机在完成其最初目的后仍将长期运行。</p>
<p class="translated">“你转向集中控制来解决你在这么多机器上遇到的可扩展性问题，”Riek说。这种大规模管理的问题是，修补软件包的问题仍然存在。事实上，情况变得更糟了。</p>
<p class="translated">与此同时，数量庞大的库和支持程序开始淹没Linux发行版。一个发行版可以由成千上万个包组成，其中至少有一些包一发货就过时了。更复杂的是，开发人员使用他们自己喜欢的依赖版本，而不是使用OS发行版中包含的版本。</p>
<p class="translated">“我们看到Linux发行版在这种复杂程度下收益递减，”Riek说。“试图在rpm中重新打包80万个上游包是没有意义的。你可以雇佣半个欧洲，但还是赶不上。冻结的二进制发行版在这种复杂程度下是不可伸缩的。</p>
<p class="translated"><img decoding="async" loading="lazy" class="aligncenter size-full wp-image-3060652" src="../Images/77a549267379ea12886b10961a3d7f0a.png" alt="" data-id="3060652" data-original-src="https://storage.googleapis.com/cdn.thenewstack.io/media/2017/09/aee259cf-2017.09.13_mesoscon_la_coveragelivestream_eventspagepromo.png"/></p>
<p class="translated">尤其是容器，它帮助开发人员从以应用程序为中心的运行时的角度来考虑问题，以最小的开销提供最大的灵活性。有了容器，用户共享内核，但是他们有自己独立的名称空间。“它将Linux重新变成了一个多实例、多版本的环境，因为突然间我有了独立的名称空间，我可以安装任何我想安装的东西，而且我不能破坏任何其他人的，”他说。</p>
<p class="translated">今天的容器化应用程序通常由一组容器组成，通常由Kubernetes或Docker Swarm这样的容器编排器控制。一个容器只能容纳几个服务(理想情况下只有一个服务)。容器提供了二进制级别的可重复构建，具有内置的自动化和传输机制。默认情况下，每个应用程序都是分布式应用程序。</p>
<p class="translated">“Kubernetes是标准化编排模型的一个缺失部分，它将我运行二进制文件的Linux机器转变为一个全面的集群环境，可以运行由多个容器组成的容器化应用程序，”Riek说。“我用服务定义来定义我的应用程序。Kubernetes展开集装箱。高可用性成了这种环境的产物。”</p>
<p class="translated">这种方法为开发人员铺平了道路，他们根本不用考虑容器，而是考虑应用程序本身。他们会想到“部署数据库服务”，等等。“应用程序不知道它在哪里运行。Kubernetes将这些抽象化了。</p>
<p class="attribution translated">Linux基金会和T2红帽是新堆栈的赞助商。</p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
<title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>

</div>
</div>    
</body>
</html>