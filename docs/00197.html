<html>
<head>
<title>Down the Right Corridor: Dynatrace Jump-Starts Cloud Foundry Unit Testing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">右边走廊:Dynatrace启动云铸造单元测试</h1>
<blockquote>原文：<a href="https://thenewstack.io/right-corridor-dynatrace-jump-starts-cloud-foundry-unit-testing/#0001-01-01">https://thenewstack.io/right-corridor-dynatrace-jump-starts-cloud-foundry-unit-testing/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">


<p class="translated">如果您是一名Cloud Foundry应用程序开发人员，那么在将工作部署到生产环境之前，您会对其性能进行怎样的测试？CI/CD框架可以帮助您在沙箱系统中对代码运行一系列自动化测试。但是它能让你进行单元测试吗？</p>
<p class="translated">“Cloud Foundry中的测试过程，”该平台的文档写道，“从对系统中最小的契约点(即每个系统组件中的方法调用)运行单元测试开始。在成功执行单元测试之后，运行集成测试来验证作为在单个机器(例如，虚拟机或裸机)上运行的单个连贯软件系统的一部分的交互组件的行为。”</p>
<p class="translated">如果你用Cloud Foundry的主要贡献者喜欢的方式测试你的软件，你是在孤立地测试单个功能。或者，正如许多开发者商店发现的那样，他们<em>认为</em>他们是。或者，也许他们正在执行一系列的步骤，这些步骤看起来是第二天性，因此他们也可以被称为单元测试，所有人都知道。</p>
<p class="translated">在上个月的Cloud Foundry峰会期间，应用性能管理服务提供商<a href="http://www.dynatrace.com" class="ext-link" rel="external "> Dynatrace </a>宣布与Cloud Foundry的管家<a href="https://tanzu.vmware.com/" class="ext-link" rel="external "> Pivotal </a>合作。对象？打开PaaS平台性能指标的闸门。</p>
<h2 class="translated">那么什么是单位呢？</h2>
<p class="translated">单元测试是一种方法论，一些现代CI/CD框架的支持者甚至没有提及，尽管长期的支持者如<a href="http://martinfowler.com/bliki/UnitTest.html" class="ext-link" rel="external "> Martin Fowler认为它是一门科学</a>。它几乎就像它听起来的那样:彻底评估孤立的一小段代码的行为的过程，最好是以自动化的方式，以确保该过程的逻辑结果总是在预期的范围内。这些边界之间的空间就是单元测试人员所说的走廊。</p>
<p class="translated">理论上，单元测试将是新兴的<a href="/category/microservices/" target="_blank">微服务</a>架构的完美匹配。</p>
<p class="translated">正如<a href="http://martinfowler.com/articles/microservice-testing/#testing-unit-introduction" class="ext-link" rel="external "> Fowler在演讲</a>中所说的，当开发人员在为代码模块设计单元测试时遇到困难时，这个困难本身可能是一个积极的信号，表明模块太大了——它应该被分解成组成部分，不仅仅是为了单元测试，也是为了作为微服务的更高效率。“因此，除了作为一个有用的测试策略，单元测试也是一个强大的设计工具，”Fowler写道，“特别是当与测试驱动开发相结合时。”</p>
<p class="translated">虽然Cloud Foundry开发人员已经采用了微服务架构，但该平台本身可以说是为快速、有时甚至是肮脏的开发而设计的。性能并不总是一个需要考虑的因素，特别是在公共PaaS提供商的情况下，他们自己的管理员应该负责提供性能。那么，PaaS平台上的单元测试能有多有效呢？这些性能因素中有很多都被开发者有意或无意地掩盖了。</p>
<blockquote><p class="translated">单元测试制度不应该过于关注代码的单个元素，以至于忘记了这些元素是如何实现的。</p></blockquote>
<p class="translated">“当你开始谈论如何在构建环境中执行单元测试的性能因素时，”新安装的Dynatrace产品宣传员<a href="https://www.linkedin.com/in/mvilliger" class="ext-link" rel="external "> Mike Villiger </a>在接受新堆栈采访时说，“在‘默认’云铸造环境中，或者甚至是更传统的环境中的性能指标——是的，测试环境和生产环境之间的性能指标会有所不同。</p>
<p class="translated">“这就是为什么当您查看一些更简单、更传统的性能指标(如响应时间)时，您将构建一个响应时间走廊，以确定在该执行环境中什么是正常的。当你在那条走廊之外的时候，你将会寻找失败。在单元测试环境中，你不会有统计基础，就像在传统的性能测试中，你会有成千上万的数据点，在那里你可以准确地确定什么是90%的性能，什么是97%的性能，等等。所以毫秒级的统计显著性并不是你在单元测试中要寻找的。在单元测试中，你要寻找那些超过走廊的响应时间。”</p>
<h2 class="translated">内部工作</h2>
<p class="translated">在非常精细的层面上测试过代码的开发人员可能对<a href="http://junit.org/junit4/" class="ext-link" rel="external "> JUnit </a>很熟悉，这是一个用Java自动化可重复测试的单元测试框架。许多使用Jenkins作为CI/CD平台的开发公司都熟悉用JUnit自动化他们的单元测试。正如Dynatrace的Villiger告诉我们的，他的公司与Pivotal的新关系变得更加有趣，因为它与Jenkins的商业管家<a href="https://thenewstack.io/microservices-transforming-jenkins-cloud-platform/" class="local-link"> CloudBees </a>有着现有的关系。</p>
<p class="translated">“Pivotal已经与CloudBees Enterprise Jenkins建立了合作关系，以便能够在Cloud Foundry环境中独立完成您的单元测试和整个生命周期，”Villiger说，“这样，您就不会在管道中的任何一点离开您将在生产中运行的平台。”类似这样的协议可以将JUnit和单元测试框架引入一种无缝的自动化封装中——这是一种平台在代码生成时关注代码性能的方式。</p>
<p class="translated">在过去的两年中，Cloud Foundry为Java应用程序提供了一种基于容器的暂存机制。云铸造<a href="https://github.com/cloudfoundry-incubator/garden" class="ext-link" rel="external ">花园</a>项目为Linux容器提供了隔离，它们需要在PaaS平台上以分布式方式大规模运行。正如Villiger提醒我们的，在Diego orchestrator 的一个单元中运行的每个Garden容器都包含一个Tomcat实例作为其堆栈的一部分。</p>
<p class="translated">村民认为，在测试阶段运行应用程序，通过这种特殊的设置，应该与在生产中运行应用程序没有太大的不同。因此，他说，将Dynatrace注入CloudBees和Pivotal的生产阶段，也有将其引入测试的好处——这样一来，就可以在一个自包含的模型中将必要程度的Dynatrace性能指标集成到单元测试中。</p>
<h2 class="translated">n + 1问题</h2>
<p class="translated">包含比Cloud Foundry开发人员以前可获得的更多的性能指标，不会改变他们对性能走廊边界的看法吗？</p>
<p class="translated">“在我看来，有趣的事情之一是，我们有一个复制旧问题的新堆栈，”Dynatrace的Mike Villager回应道。“我们有了这种全新的架构，我们在谈论微服务，我们在谈论一种用于获取数据的微服务，我们在拆分不同的元素:你有Spring，你有<a href="http://projects.spring.io/spring-boot/" class="ext-link" rel="external "> Spring Boot </a>，你有<a href="http://projects.spring.io/spring-cloud/" class="ext-link" rel="external "> Spring Cloud </a>等等。最后会发生什么，你会遇到那个<em> n + 1 </em>问题。”</p>
<p class="translated"><a href="https://www.bookdepository.com/Extending-Visual-BASIC-for-Windows-D-F-Scott/9780672301001" class="ext-link" rel="external ">24年前我在一本关于Visual Basic的书里写过<em> n + 1 </em>问题</a>。当您将从数据库获取记录的工作委派给动态组成每个查询的组件时，可能会出现这种现象。如果一个数据表有1，000条记录，并且一个loop子句循环调用每次提取一条记录的查询，那么生成SQL查询的组件将该查询约束到每条特定记录，总共有1，001个查询(1个用于“悬崖”提取，表明没有表了)。早在20世纪90年代，我就认为这种方法是对SQL的误用；中间组件应该能够迭代“SELECT * FROM table”指令的结果。</p>
<p class="translated">Villiger指出，对于微服务，每当编排平台调度1001个服务来迭代1000条记录时，都会出现同样的问题。普通的单元测试将应用于获取单个记录的函数，使其获取速度更快。但是它不会提示测试人员这样一个事实，即集体处理记录会减少服务的重复，有效地提高应用程序的整体性能。</p>
<p class="translated">“在某种程度上，我们正在看着同样的老问题在新的堆栈中自我复制，”维利热说。“接下来将会发生的一些新事情将会是额外的架构回归，在这种情况下，开发人员可能会绕过数据服务，直接从数据库中附加一条记录，而他本应该迭代数据服务才能到达那里。”他解释说，在这种情况下，服务之间不一致，不遵循彼此的程序——一个服务跳过一两步。</p>
<p class="translated">他说，架构回归倾向于落在性能回归的边界之外——单元测试的典型焦点。"但是它们是回归，尽管如此，开发者应该关注."</p>
<p class="translated">他的观点是:单元测试制度不应该过于关注代码的单个元素，以至于忘记了这些元素是如何实现的更广泛的背景。Villiger和Dynatrace正在寻找机会将性能指标注入到Cloud Foundry开发空间中，但至少要在一个级别的上下文中定义性能走廊，而不是局限于单元。</p>
<p class="attribution translated">Cloud Foundry 和<a href="https://tanzu.vmware.com/" class="ext-link" rel="external "> Pivotal </a>是新堆栈的赞助商。</p>
<p class="attribution translated">专题图片:终极单元测试:5月29日，亚历山大·罗西刚刚在第100届印第安纳波利斯500比赛中穿过砖块。斯科特·富尔顿的照片。</p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
<title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>

</div>
</div>    
</body>
</html>