<html>
<head>
<title>MapR's Data Platform Provides a Persistent Storage Layer for Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MapR的数据平台为Kubernetes提供了一个持久存储层</h1>
<blockquote>原文：<a href="https://thenewstack.io/developers-like-maprs-persistent-storage-kubernetes/#0001-01-01">https://thenewstack.io/developers-like-maprs-persistent-storage-kubernetes/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">


<p class="translated">MapR最近在其<a href="https://mapr.com/solutions/data-fabric/kubernetes/" class="ext-link" rel="external ">融合数据平台</a>中增加了<a href="/category/kubernetes/" target="_blank"> Kubernetes </a>支持，这是值得注意的，但也是意料之中的，因为集装箱化和所有东西的Kubernetes都很受欢迎。但MapR发布的关键是大数据应用平台如何为使用开源容器编排引擎的开发人员提供持久存储。</p>
<p class="translated">这个想法是让开发人员担心他们最擅长什么:在Kubernetes上部署应用程序，而不必担心持久存储的数据访问。这是因为持久存储现在已经加载到了<a href="https://mapr.com/" class="ext-link" rel="external "> MapR </a>的平台上。</p>
<p class="translated">“对持久存储的直接、开箱即用和基于供应商的支持才是最重要的。当企业进行自我整合时，他们会承担整合的风险。考虑到每个活动部件都需要重新测试、潜在的编码、再次测试、首次展示等，还有很多维护工作要做。“<a href="https://www.constellationr.com/" class="ext-link" rel="external ">星座研究</a>的分析师道格·亨舍恩告诉我们。“当供应商从一开始就支持持久存储时，事情就简单多了。”</p>
<p class="translated"><img decoding="async" loading="lazy" class="alignnone wp-image-4383926 size-large" src="../Images/87a1a202f7142cdf3e07a09342ad5a07.png" alt="" data-original-src="https://storage.googleapis.com/cdn.thenewstack.io/media/2018/03/9c1fca2d-screen-shot-2018-03-18-at-9.56.33-pm-1024x487.png"/></p>
<p class="translated">鉴于容器的短暂性，在传统的庄严平台上开发有状态应用程序当然是一个开发挑战。与此同时，经常需要的持久存储只能为容器上的应用程序增加一个额外的开发障碍，否则当服务器关闭时，这些应用程序可能会被删除。MapR的解决方案旨在为那些更关心利用Kubernetes提供的灵活性和敏捷性的开发人员处理等式中的持久存储部分。</p>
<p class="translated"><a href="https://www.enterprisemanagement.com" class="ext-link" rel="external ">企业管理协会(EMA) </a>的分析师<a href="https://www.linkedin.com/in/johnlmyers/" class="ext-link" rel="external "> John L. Myers </a>告诉我们，“MapR是对那些说‘我们不想做持久存储的事情’的开发者社区的回应。“MapR的Kubernetes公告是关于为应用程序开发人员提供封装数据管理、存储和结构层上发生的一切的自动化功能。相反，他们希望专注于API，而数据结构是分布式和可扩展的，而不是成为瓶颈。”</p>
<p class="translated">事实上，MapR认为有必要将无状态添加到有状态中，以在分布式平台上部署生产应用程序，在这个平台上可以存储、处理和分析大量数据，<a href="https://www.linkedin.com/in/suzyvisvanathan/" class="ext-link" rel="external ">MapR</a>产品管理总监Suzy Visvanathan 告诉我们。“要使容器有状态，提供持久存储是关键，同时仍然保留容器的短暂状态。，”Visvanathan说。“如果没有持久存储，容器将是开发/测试/POC环境中使用的一种短暂趋势。借助持久存储，客户可以迁移/创建在生产环境中运行的容器化应用程序。”</p>
<p class="translated">对Kubernetes的支持是在去年MapR为有状态应用程序增加了持久存储之后。针对MapR数据结构支持，其卷驱动程序为数据库、文件和流提供持久存储卷。当然，这也延伸到了云、边缘和本地存储。还提供了位于MapR集群内外的多租户、容器化和非容器化应用程序的计划自动化。在生产用例的容器中部署有状态的应用程序也可以扩展到机器学习管道。跨数据访问支持包括NFS，S3，HDFS，ODBC。</p>
<p class="translated">作为一个涉及交易应用的潜在案例，MapR的<a href="https://mapr.com/solutions/data-fabric/kubernetes/" class="ext-link" rel="external ">融合数据平台</a>旨在无需不必要的数据复制即可将数据即时提供给存储层，以便实时访问海量数据池。例如，为信用检查、支付和订单执行而分别运行的多个容器可以有一个平台自带的公共存储层。</p>
<p class="translated">容器中的应用程序也实时访问存储层。否则，如果您将数据存储在每个容器中，就需要将数据复制扩展到所有这些组件。</p>
<p class="translated">“MapR真正获得了自己的地位，因为现在您可以让地理上分散的应用程序与Kubernetes上的分布式数据结构进行对话，并获得他们所需的响应速度。”迈尔斯说。“因此，应用程序开发人员不必为开发找借口或耍花招，因为MapR会处理所有这些事情。”</p>
<p class="attribution translated">由<a href="https://unsplash.com/photos/m2TJvN_GRbY?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" class="ext-link" rel="external "> MontyLov </a>在<a href="https://unsplash.com/search/photos/platform?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" class="ext-link" rel="external "> Unsplash </a>上拍摄的特征图像。</p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
<title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>

</div>
</div>    
</body>
</html>