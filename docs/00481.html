<html>
<head>
<title>Fossor Fuel: LinkedIn Open Sources New Tools for Automated Investigation of Application Issues</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Fossor Fuel: LinkedIn开源自动调查应用程序问题的新工具</h1>
<blockquote>原文：<a href="https://thenewstack.io/fossor-fuel-linkedin-open-sources-new-tools-automated-investigation-application-issues/#0001-01-01">https://thenewstack.io/fossor-fuel-linkedin-open-sources-new-tools-automated-investigation-application-issues/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">


<p class="translated">如今，我们很多人都害怕有一天自己的工作会被机器人取代。另一方面，史蒂文·卡利斯特正在积极努力将这一可怕的可能性变成现实。</p>
<p class="translated">作为实现这一目标的一步，Callister——T2 LinkedIn T3的高级网站可靠性工程师——创建了两个新的开源工具，旨在当服务器或应用程序出现故障时，自动识别和排除故障。<a href="https://github.com/linkedin/fossor" class="ext-link" rel="external "> Fossor </a>是一个面向插件的Python工具和库，旨在自动调查损坏的主机和服务。<a href="https://github.com/linkedin/asciietch" class="ext-link" rel="external "> Ascii Etch </a>是一个Python库，可以选择性地附加到Fossor插件上，通过使用Ascii字符将数字流渲染成图形来可视化地显示输出。</p>
<p class="translated">作为一名SRE，Callister的工作确实是尽可能地自动化工作。此外，撇开机器人霸主不谈，自动化有很多好处:通过接管重复或单调的工作流程任务，它可以节省大量时间。这使得忙碌的工程师可以专注于开发下一个很酷的东西，或者获得更多的睡眠。或者，正如卡利斯特解释的那样，</p>
<p class="translated">“一次特殊的经历真正让我开始为Fossor编写代码。一天晚上3:00，我在电话中收到了一个升级，这使我通过三个不同的服务跟踪一个问题，我发现自己在每个服务中键入了相同的命令，因为我越来越接近根本问题。我认为必须有一些方法来自动化这些步骤，以帮助加快调查速度，同时也帮助我下次获得更多的睡眠。”</p>
<p class="translated">对利用自动化的力量不仅自动化必要的调查步骤，而且并行执行它们感兴趣，Callister开始尝试构建自己的工具。他意识到，除了专门针对他当前的服务集执行检查之外，他还可以根据需要灵活地在将来添加新的检查。</p>
<h2 class="translated">你能理解吗？</h2>
<p class="translated">就这样，福瑟诞生了。Fossor来自拉丁语，意为“挖掘者”(另一个翻译是“掘墓人”，但我们还是用第一个吧)，Fossor的命名是为了帮助用户挖掘服务器或应用程序问题。为了避免在工具本身中引入性能或应用程序破坏错误，Fossor由两部分组成:引擎本身和插件库。</p>
<p class="translated">独立引擎负责收集必要的插件，然后在自己的进程中运行每个插件。通过将每个插件隔离在其自己的进程中，主引擎可以避免单个插件导致应用程序失败和崩溃。这种弹性是软件可靠性工程的关键原则，允许Fossor安全地管理来自许多贡献者的插件。</p>
<p class="translated">Callister写的第一个插件解决了他的团队最近面临的一个棘手的问题。这个问题被证明是内存碎片，起初很难识别，因为他们以前从未遇到过这个问题，团队花了很长时间才最终找到它。“一旦我们发现了问题所在，我们也不希望其他人不得不从头开始，”卡利斯特说。“如果不提醒其他人注意这种可能的问题，感觉就像是浪费宝贵的经验教训。因此，内存碎片插件成为我为Fossor编写的第一个插件。”</p>
<h2 class="translated">插入电源</h2>
<p class="translated">“插件方面实际上是他最喜欢的Fossor方面,”Callister继续说道。在这一点上，Fossor的插件库有能力检查数百个不同的网站问题，用户可以建立自己的检查菜单。</p>
<p class="translated">Callister说，Fossor的协作方面——任何人都可以贡献一个插件，尤其是现在该工具已经开源——也令人兴奋。“一旦一个插件被贡献出来，其他用户都会受益。总的来说，这个工具汇集了来自不同专业领域的人的知识，分享他们最好和最有用的检查。”</p>
<div>
<dl id="attachment_3714576">
<dt>
<p/><div class="wp-caption alignnone"><a href="https://thenewstack.io/?attachment_id=3714576" class="local-link"><img decoding="async" loading="lazy" src="../Images/77b97ad56a00b298900b69fb9bbf2bdc.png" alt="" data-original-src="https://storage.googleapis.com/cdn.thenewstack.io/media/2017/12/ce439d39-foddorpluginworkflow.jpg"/></a><p class="wp-caption-text translated">Fossor工作流。</p></div></dt>
<dd/>
</dl>
</div>
<p class="translated">“而且，因为Fossor充分利用了计算机并行运行检查的能力，所以没有理由让一个人必须选择先检查什么。您可以同时对多个问题进行检查，包括您自己可能没有想到的问题，”他补充道。</p>
<p class="translated">Fossor支持三种类型的插件:变量收集、检查和报告，由引擎按照下面的流程执行。插件本身是小类，都使用相同的基本结构，必须实现一个方法，run方法。如果run方法返回输出，这表明输出是“有趣的”,应该报告给用户。run方法接受一个参数，一个名为“variables”的Python字典，用于可选地向插件提供外部信息。</p>
<p/>
<p/>
<p class="translated">目前Fossor库中的一些通用插件调查高内存或磁盘使用率、网络错误、日志中的错误模式、高平均负载和最近的内核消息。更多细节和具体代码示例，请查看Callister的博客文章。</p>
<h2 class="translated">获取图形</h2>
<div>
<dl id="attachment_3714701">
<dt>
<p/><div class="wp-caption alignnone"><a href="https://thenewstack.io/?attachment_id=3714701" class="local-link"><img decoding="async" loading="lazy" src="../Images/32237d01dd7825cdb4dbdb58b4de41fd.png" alt="" data-original-src="https://storage.googleapis.com/cdn.thenewstack.io/media/2017/12/e23b0c54-asciietchgraph.jpg"/></a><p class="wp-caption-text translated">下游延迟插件显示轮询LinkedIn的服务指标，以检查每个下游服务的延迟。如果延迟出现异常，插件会使用Ascii蚀刻库向用户打印一个ASCII图形。</p></div></dt>
<dd/>
</dl>
</div>
<p class="translated">Callister预见到了并行服务自动化可能带来的一个问题:输出太多，关键数据很难从流中提取出来。Fossor的报告功能是特定于每个插件的，它只报告被认为重要的信息。这种有组织的输出使访问感兴趣的数据变得更加容易，但Callister意识到他还可以更进一步，创建一个实用程序来执行数据的图形翻译和输出。</p>
<p class="translated">因此，Callister为Fossor编写了一个名为Ascii Etch的伙伴，它创建了数据的图形输出，使报告更容易阅读。Ascii Etch最初的任务是在Fossor的命令行上向用户显示延迟图。Fossor的原始下游延迟插件显示平均、最小和最大延迟。虽然这些是有用的统计数据，但一个快速的图表可以更清楚地显示下游是否真的存在延迟，”他解释道。</p>
<h2 class="translated">开源未来</h2>
<p class="translated">自从推出以来，Fossor和Ascii Etch已经帮助LinkedIn缩短了事件响应时间。“通过并行执行我们的调查检查，然后只报告有用的信息，我们能够更快地确定应用程序问题的原因，通过一个命令简化调试过程，”Callister说。</p>
<p class="translated">Fossor基于插件的方法的优势在于，它可以通过创建不同的插件来实现难以置信的特定性，同时其贡献库也非常庞大。既然这些工具已经被开源，LinkedIn SRE团队期待看到它们会是什么样子。</p>
<p class="translated">“由于Fossor随着每个额外的插件变得更加有用，我们希望开源社区发现使用这个自动化工具的价值，并为其萌芽的调查检查库做出贡献，”Callister总结道。</p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
<title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>
</div>
</div>    
</body>
</html>