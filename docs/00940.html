<html>
<head>
<title>Meet FloydHub: The Heroku of Data Science</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">认识一下FloydHub:数据科学的英雄</h1>
<blockquote>原文：<a href="https://thenewstack.io/meet-floydhub-the-heroku-of-data-science/#0001-01-01">https://thenewstack.io/meet-floydhub-the-heroku-of-data-science/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">


<p class="translated">本文是我们探索基于云的机器学习服务系列的一部分。在介绍了<a href="/how-the-azure-ml-streamlines-cloud-based-machine-learning/" target="_blank"> Azure ML Services </a>、<a href="https://thenewstack.io/google-cloud-ml-engine-train-and-deploy-machine-learning-models/" target="_blank" class="local-link"> Google Cloud ML Engine </a>、<a href="https://thenewstack.io/train-deploy-machine-learning-models-with-amazon-sagemaker/" target="_blank" class="local-link"> Amazon SageMaker </a>、<a href="/build-machine-learning-models-with-ibm-watson-studio-cloud/" target="_blank"> IBM Watson Studio Cloud </a>和<a href="https://thenewstack.io/paperspace-gradient-a-modern-paas-for-machine-learning/" target="_blank" class="local-link"> Paperspace Gradient </a>之后，我们将进一步了解另一个流行的ML即服务平台FloydHub。</p>
<p class="translated">问任何数据科学团队什么最让他们沮丧，普遍的答案是环境配置和管理。</p>
<p class="translated"><a href="https://www.floydhub.com/" class="ext-link" rel="external "> <img decoding="async" loading="lazy" class="alignright wp-image-6080180 size-medium" src="../Images/33cd745f8785c797e78a1ab7748e66ae.png" alt="" data-id="6080180" data-original-src="https://cdn.thenewstack.io/media/2018/11/a0853b78-floydhub-300x208.png"/> </a></p>
<p class="translated">关于数据科学和机器学习领域最好的事情是工具、框架和库是100%开源的。虽然这对社区来说很好，但另一面是分裂。开发人员和数据科学家经常被工具的选择弄得不知所措。加上依赖关系，GPU和高端CPU，以及工具每个版本可能的冲突，很快就变成了配置噩梦。</p>
<p class="translated">与一般的认知相反，处理机器学习和人工智能不仅仅是选择和优化最复杂的算法。有趣的是，这仅占成功实现所需总工作量的20%。剩下的80%处理数据工程、数据准备、基础设施供应、配置管理、环境管理、工件版本控制、模型部署和生命周期管理。</p>
<p class="translated">为了成功实施机器学习项目，组织应该雇用数据工程师、DevOps专业人员、数据科学家和开发人员。他们的合作对组织的长期成功至关重要。</p>
<blockquote><p class="translated">与一般的认知相反，处理机器学习和人工智能不仅仅是选择和优化最复杂的算法。</p></blockquote>
<p class="translated">不是每个公司都有能力投资这些团队。可能只有几个数据科学家和传统开发人员来处理机器学习模型的整个生命周期。新型ML PaaS产品通过展示预配置和可定制的环境、自动化模型训练和可扩展模型托管，精确地解决了这一差距。他们让团队专注于核心业务问题，而不是迷失在工具和框架的无数选择中。</p>
<p class="translated">来自湾区的年轻初创公司FloydHub 致力于解决数据科学家面临的问题和挑战。创始人将该平台称为数据科学的Heroku，这当然是一个恰当的描述。</p>
<p class="translated">该平台是在Amazon EC2实例上运行的Docker容器的抽象，它公开了一个简单的API来执行开发机器学习模型所涉及的大多数任务。与Heroku类似，开发人员上传代码，剩下的交给PaaS，FloydHub希望用户上传数据集、用于训练模型的代码以及用于展示训练好的模型以进行推理的代码。</p>
<p class="translated">用户可以使用预定义的配置设置快速启动培训工作，或者选择提供带有自定义配置的YAML文件。FloydHub将接管创建定制环境并在其中运行代码的职责。</p>
<p class="translated">让我们看看FloydHub的核心组件:</p>
<h2 class="translated">项目</h2>
<p class="translated">FloydHub项目充当属于特定项目的所有资产的边界。它将保存代码、版本化实验、输出文件、日志和作业的完整历史。它还可能包含在工作区创建的Jupyter笔记本。</p>
<p class="translated"><img decoding="async" loading="lazy" class="aligncenter wp-image-6079427 size-large" src="../Images/775ef0819815d84fe3d6502eca60baab.png" alt="" data-original-src="https://cdn.thenewstack.io/media/2018/11/95ed1e61-fh-0-1024x458.jpg"/></p>
<p class="translated">使用FloydHub的第一步是创建项目。</p>
<h2 class="translated">资料组</h2>
<p class="translated">FloydHub在数据和代码之间提供了强大的隔离。由于数据集在多个项目中重复使用，因此将它们保存在一个独立但可集中访问的位置是有意义的。任何项目都可以访问上传到其帐户的数据集。有一些公共数据集，如MNIST和VOC，用于常见的ML实验。</p>
<p class="translated">FloydHub中数据集的最大优点是它们被版本化了。这在数据准备和数据工程阶段非常有用，在这两个阶段，原始数据集要经过多次转换。开发人员可以通过参考版本轻松访问历史数据集。</p>
<p class="translated"><img decoding="async" loading="lazy" class="aligncenter wp-image-6079440 size-large" src="../Images/78296d3f670b627a79706376e7d0ffd6.png" alt="" data-original-src="https://cdn.thenewstack.io/media/2018/11/fb454ba5-fh-1-1024x375.jpg"/> <br/> FloydHub CLI可用于从本地工作站上传数据集。我找不到批量上传的工具，也找不到直接从公共场所导入数据集的能力，比如S3桶。</p>
<h2 class="translated">乔布斯</h2>
<p class="translated">一旦创建了项目并上传了数据集，很明显下一步就是开始培训工作。FloydHub有一个简单直观的工作流程来启动培训工作。</p>
<p class="translated">这份工作是一项艰巨的任务。开发人员应该在创建作业之前在本地机器上编写和测试Python代码。当需要大规模运行培训工作时，他们只需选择一个预定义的环境，如TensorFlow、Caffe和PyTorch，以及一个基于CPU或GPU的实例类型。它们还可以指向已经上传的数据集的位置。</p>
<p class="translated">FloydHub上传代码，将其注入到预先配置的容器映像中，并在目标环境中启动容器。基于GPU的作业被打包为NVIDIA-DOCKER容器，可以利用NVIDIA K80或P100 GPU。可以通过本地CLI或web界面发出的流日志来监控作业。作业一完成，FloydHub就自动终止容器并停止作业。作业生成的文件可以从门户网站下载。</p>
<p class="translated"><img decoding="async" loading="lazy" class="aligncenter size-large wp-image-6079455" src="../Images/49c020c1300f06352b0e2472352ba1ea.png" alt="" data-original-src="https://cdn.thenewstack.io/media/2018/11/0e9beb62-fh-2-1024x917.jpg"/></p>
<p class="translated">如果作业需要定制包和依赖项，可以将它们添加到一个名为floyd_requirements.txt的文件中，该文件遵循与Python的requirements.txt相同的格式。这使用户能够精确定义作业所需的版本和框架。</p>
<p class="translated">一份工作可以有两种不同的生活方式，即培训和服务。默认模式是训练模式，但也可以是服务模式，它可以承载用于推理的训练模型。FloydHub希望您包含一个名为app.py的文件，该文件包含反序列化模型的样板代码，并将其作为REST端点公开。当使用切换模式服务器启动作业时，它将持续运行，直到被手动终止。</p>
<p class="translated">下面的屏幕截图显示了在服务模式下启动一个作业并访问它进行推理是多么简单。我看到的唯一差距是REST端点不安全。FloydHub应该至少包含一个可用于HTTP基本身份验证的API密钥。</p>
<p class="translated">我非常喜欢FloydHub CLI运行作业的简单性。它有足够的开关来定义您期望运行的作业。</p>
<h2 class="translated">工作区</h2>
<p class="translated">随着Jupyter笔记本成为数据科学IDE的黄金标准，FloydHub通过工作区增加了对它们的支持。除了运行笔记本之外，工作区几乎就像一个虚拟机，用户可以在其中访问shell。</p>
<p class="translated">现有的数据集位置可以挂载为目录，对笔记本可见。本地机器上的文件可以直接上传到工作区，以便从Jupyter笔记本上访问。</p>
<p class="translated"><img decoding="async" loading="lazy" class="aligncenter wp-image-6079485 size-large" src="../Images/2b523a2f73066acfee5e8eb2be2bcba5.png" alt="" data-original-src="https://cdn.thenewstack.io/media/2018/11/235244e0-fh-4-1024x557.jpg"/></p>
<p class="translated">在我的评估中，我发现工作空间并没有完全融入工作。例如，作业和工作区不共享公共存储，这使得移动和重用模型工件(如检查点文件)变得困难。</p>
<p class="translated">理想情况下，工作空间应该成为工作的替代输入。用户应该通过CLI从本地计算机启动作业，或者单击工作区UI中的按钮。无论工作地点在哪里，都应该一视同仁。这种整合将带来更顺畅的工作流程和一致的体验。</p>
<p class="translated">FloydHub因其处理ML实验和模型管理的极简和简单方法而获得高分。这是一个强大的PaaS，用于运行基于Scikit-learn的简单、经典的ML模型或基于TensorFlow或Caffe的复杂深度学习模型。</p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
<title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>
</div>
</div>    
</body>
</html>