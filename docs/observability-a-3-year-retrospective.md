# 可观察性——3 年回顾

> 原文：<https://thenewstack.io/observability-a-3-year-retrospective/>

可观察性、发展方法或“运动”已经有三年的历史了，该领域的早期先驱之一 Charity Majors 决定后退一步，向外“观察”它已经走了多远。在这篇文章中，她通过引用一些重要的贡献者，深入探讨了为什么它会形成以及为什么其他的方法和途径会失败。她解释了采用可观测性对于任何工程团队构建和维护复杂的分布式系统的重要性。

[](https://twitter.com/mipsytipsy)

[Charity Majors](https://twitter.com/mipsytipsy)

[Charity Majors 是 Honeycomb.io 的联合创始人兼 CTO，为工程和 DevOps 团队更快、更智能地调试生产系统提供工具。之前，Charity 在 Parse 负责基础设施，在脸书担任工程经理，负责大规模开发下一代分布式系统。离开脸书后，Charity 和她的联合创始人创建了 Honeycomb，以帮助工程团队更快、更安全地传输代码，使用为这个混乱、短暂、松散耦合的分布式系统的新时代而设计的可观察性工具。查里蒂是《数据库可靠性工程》(O'Reilly)的合著者，致力于创造一个每个工程师都随叫随到、没有人认为随叫随到很糟糕的世界。](https://twitter.com/mipsytipsy)

[](https://twitter.com/mipsytipsy)[](https://twitter.com/mipsytipsy)

像软件工程中的许多其他术语一样，“可观察性”是从一个更古老的物理学科借用的术语:在这里是控制系统工程。可观测性是可控性的数学对偶。

不太正式地说，这意味着人们可以从系统的输出中确定整个系统的行为。如果一个系统是不可观测的，这意味着它的一些状态变量的当前值不能通过输出 [*传感器*](https://en.wikipedia.org/wiki/Sensors) *来确定。”*

在我们理解为什么可观察性是一个有意义的技术术语，而不仅仅是一个产品营销术语之前，我们需要理解一些关于监控、度量、事件的事情，以及我们如何试图理解我们的系统的简史。我们需要了解世界是如何变化的，以理解为什么会这样，为什么是现在。

自从有了终端和高级计算机语言，就有了日志:输出到人类可读设备的字符串，以帮助人类理解正在发生的事情。接下来是早期基于文本的系统包 sysstat、sar、iostat、netstat、mpstat 等。这仍然是了解单节点性能的最佳方式。然后在 1988 年，SNMPv1 诞生了——第一个基于度量的遥测系统(据我所知)。

> 度量不等于可观察性。

自 80 年代以来，度量标准一直占据主导地位:snmp、rrdtool、cacti、Ganglia、 [Etsy 极具影响力的](https://codeascraft.com/2011/02/15/measure-anything-measure-everything/) statsd。他们的现代继任者包括 SignalFX、DataDog、Wavefront 等。用户体验已经走过了漫长的道路，但是所有这些工具都是建立在作为工作单元的指标*之上的:一个单独的数字，附加了标签，这样你就可以分割、分组和定位各种指标及其来源。*

在您的代码中，一个请求在完成之前可能会发出几十个甚至几百个指标——度量、计数器和其他表示 CPU 负载、常驻内存大小、I/O 统计等细节的数字。并用诸如构建 ID、AWS 区域等信息进行标记。指标通常在写入时聚合，并随着老化而失去粒度，这使得收集和存储它们非常有效。度量仍然是理解您的基础设施系统作为一个整体如何运行的主要方式，并且可能永远都是这样。但是不要错过上面关于“失去粒度”的注释——记住这一点很重要，因为我们将会回到这个问题上；度量不等于可观察性。

## 21 世纪催生了一个新的供应商品种:APM

大约 10 年前，APM(应用性能管理)旗下出现了一批新的提供商。NewRelic、AppDynamics 和其他被宣传为理解应用程序代码的更好方法。不使用代理，您可以在您的代码中安装它们的库，然后跟踪请求并报告语言内部以及请求细节。它们可以有效地生成大量的前 10 个列表，这样您就可以了解性能问题的来源——按端点、按查询等等。

这些工具向前迈进了一大步。它们仍然主要是基于度量的，但是从第三方观察者到第一人称观察者的视角转变允许对你的软件及其行为进行更多的反思。

工具已经走过了漫长的道路。然而，就在短短五年前，当我在 Parse(后来被脸书收购)努力应对一个不断宕机并遭受不可预测的共租问题的平台时，我尝试了所有这些工具，但没有一个能帮助解决系统性能和可靠性问题。让我重复一遍:他们都没有做他们声称要做的事。这并不是因为他们撒谎或歪曲自己，而是因为*我们正在构建的系统种类与那些工具被开发来理解的系统根本不同*。Parse 是许多仍然相对前沿的趋势的早期采用者，越来越多的人现在正经历着我在那段时间所经历的惊愕和沮丧。这些旧工具曾经是革命性的，但现在已经不再适用于我们当前的系统了。

## 基数及其与复杂分布式系统的关系

要完全理解“为什么”——首先你需要理解我们今天正在构建的系统是如何不同的(以及为什么)，核心是理解所谓的基数。

基数是指集合中唯一项目的数量。任何唯一的 ID 总是可能的最高基数，单个值总是可能的最低基数。如果您有一个一亿条用户记录的集合，您可以自信地猜测社会保险号将具有最高的基数；名和姓将是高基数，虽然较低(因为有些名字重复)；性别将是相当低的基数，而“物种:人类”可能是最低的基数，如果你真的费心去记录的话。

## 如果不能访问高基数数据，祝调试好运

为什么这很重要？因为*高基数信息是调试*或理解系统最有用的数据(想想用户 ID、购物车 ID、请求 ID……基本上任何 ID 以及实例、容器、构建号、span ID 等)。唯一的 id 将总是在给定的干草堆中识别单个针的最佳工作。

然而，基于度量的工具系统只能处理*规模的低基数维度*。如果你只有几百台主机，你就不能把主机名作为一个识别标签，否则你会耗尽你的基数键空间。同样，对于您想用基于度量的工具问的每个问题，您必须决定提前问它，以便可以在编写时写出答案。这意味着 a)如果你想在事后问任何新的问题，你不能，b)成本随着你想问的问题的数量而线性上升。).

> 当我们把这个庞然大物分解成许多服务时，我们失去了用调试器单步调试代码的能力:它现在在网络上跳跃。我们的工具仍在努力应对这一翻天覆地的变化。

在很长一段时间里，这并不重要，因为高基数维度非常罕见。对于典型的整体式系统，您只有一个应用程序层和一个数据库。所有有趣的逻辑都隐藏在应用程序代码中，您可以使用像 gdb 这样的调试器来单步调试它。当遇到问题需要进行故障诊断时，您可以查看您的仪表盘，立即直觉地判断出三个、四个或五个整体组件中的哪一个出现了故障。

这越来越不真实。看看过去五年多来所有的基础设施/架构趋势。容器、调度器、微服务、多语言持久性、网状路由、短暂自动缩放实例、无服务器、lambda 函数。一个请求可能会在你的边界后跳 20-30 次——如果算上数据库查询的话，可能会多跳两次。突然间，调试系统最困难的事情不再是理解代码如何运行，而是找到系统中有问题的代码。你通常不能只看一个控制面板或服务图，就知道哪个节点、服务或组件慢，因为它会循环回自身，当任何东西变慢时，所有东西都会变慢。今天的现代云原生环境本质上是一个平台，这意味着“内部”的代码和查询甚至可能不在单个团队的控制之下。

当我们把这个庞然大物分解成许多服务时，我们失去了用调试器单步调试代码的能力:它现在在网络上跳跃。我们的工具仍在努力应对这一翻天覆地的变化。

回到 Parse，用户可能会抱怨:“Parse 停机了！”我们的监控工具将清楚地显示 Parse 没有关闭。那么用户在抱怨什么呢？嗯，我们会派人去调查，但还不完全清楚；开发人员能够上传他们自己的代码和查询，我们必须让他们在与成千上万的其他邻近应用程序共享的硬件上工作。因此，问题可能是 a)他们的代码更改或查询，b)我们的代码更改或查询，c)两者的一些交集，d)与投诉用户共享资源的用户的一些代码更改或查询，e)我们做的一些代码更改或查询影响了与他们共享资源的用户，f)以上的任何交集。哦，我们有超过 100 万个应用程序，我们不断发布影响所有应用程序的代码，每个应用程序都有自己完整的用户生态系统，发布自己的代码，不断影响自己的用户。

美好时光。

监控工具对于具有稳定的已知-未知集合和相对较少的未知-未知的系统是有效的。对于一个以未知为主的系统来说，监控工具几乎毫无用处。我们不得不费力而缓慢地手工调试它们。通常要花一天或更多的时间来追踪用户的投诉，或者决定它是否真的在“他们”一边。最终救了我们的解决方案是脸书的水肺，我们在收购 Parse 后开始使用它。我们开始将数据集输入到 Scuba 中，并能够按照特定的维度对数据进行分割——按照用户 ID、端点、查询等等。这使得我们发现问题的时间从一天或更长时间减少到…秒，通常是几分钟。

这一经历给我留下了深刻的印象，尽管当时我无法用语言来形容。直到我偶然发现了“可观察性”这个术语，并查找了它的起源，我才意识到它对我们构建可理解的软件系统有多大的启发。

## 实践中的可观察性是什么样的

带着那次回忆之旅，让我们重温一下定义:

**可观测性是一种度量，它衡量一个* [*系统*](https://en.wikipedia.org/wiki/System) *的内部状态可以从其外部输出的知识中推断出来的程度。**

 **不太正式地说，这意味着人们可以从系统的输出中确定整个系统的行为。如果一个系统是不可观测的，这意味着它的一些状态变量的当前值不能通过输出* [*传感器*](https://en.wikipedia.org/wiki/Sensors) *来确定。*

当你翻阅一堆仪表盘试图找出正在发生的事情时，你没有检查正在发生的事情并进行推理，或者跟踪有意义的线索。你直接跳到了结尾——一个猜测。这就好像整个系统仍然是一个大黑匣子，你没有任何信息来推断发生了什么。你的思维过程可能是这样的:

今天下午 2 点，我看到了一个巨大的错误峰值。这是意料之外的，而且可能很糟糕。看起来它与这个特定数据库集群的错误峰值相关。上一次发生这种情况，是因为有人运行了一个错误的长时间运行的写查询，该查询持有一个有争议的锁，然后将相同的写操作复制到跟随者。我将检查一个长时间运行的查询和这段时间内不断增长的队列长度，以验证我的假设。酷，我找到了一个——证实了我的理论。

注意它是多么依赖直觉的跳跃和你过去停机的记忆库。理想的情况是，你不要立即跳到可能的解决方案，而是以开放的心态从顶部开始——“发生了什么？”并且系统地沿着数据驱动的面包屑找到可验证的解决方案，不管它是什么。像这样:

今天下午 2 点，我看到了一个巨大的错误峰值。我们来探索一下。我将按副本集(或端点、或用户、或字面上的任何东西，但现在姑且称之为副本集)进行分解。好的，副本集 1 有一个巨大的错误峰值，另外两个副本集 4 和 5 有一个小得多的错误峰值。有意思。队列长度似乎在副本集 1 的峰值长度内稳步攀升，在副本集 4 的持续时间内上下波动，在副本集 5 只有一个短暂的峰值。rs1 上有一个长时间运行的查询，而其他两个没有。我想知道这是否是 EBS/IOPS 的暂时问题，因此我将按副本集节点和可用性区域进行细分，这表明它们位于不同的 az 上。很好，排除了这个可能性。是迁移吗？不，build_id 没有改变。让我总结持有锁的时间，并按 user_id 进行分类，以查看谁持有锁以及哪个查询持有锁——啊！这是来自 cron 的后台过期作业！它在 RS1 上持续的时间比 RS4/5 长，因为那里有更多的旧数据。让我们重做它，这样它就不必以这种方式争用锁了。

我正在解释这个漫长、痛苦、手工的逐步缩小你的假设的方法。以这种方式调试涉及许多小的、可验证的假设，一个接一个，就像面包屑一样。它只在*有效*，因为我可以按每个维度分解，包括基数非常高的维度。它只在有效，因为我在将记录写入磁盘之前没有进行预聚合，事实上，我发出的每个查询都会在读取时聚合以回答我的问题。它只工作*因为我已经在正确的抽象层次上收集了数据，围绕着请求和它的工作单元——因为请求是映射到用户真实生活体验的东西。*

基数限制也不是基于度量的系统的唯一问题。指标是一个附加了标签的数字。一个请求在执行时可能会触发十几个或一百个指标…但是这些指标都是彼此断开的，并且永远无法重新连接，不像任意宽的事件那样将该请求的所有细节和上下文编织在一起。大量的调试工作包括查看异常尖峰或其他形状，然后找出这些错误共有的特征或异常值。如果你已经剥离了事件的结缔组织，你就不能这样做；那你能做的就是猜测。那不是调试，那是魔术。

相反，通过使用事件并传递完整的上下文，我可以询问我的系统的任何问题并检查其内部状态，因此我可以了解我的系统已经进入的任何状态——即使我以前从未见过它，以前从未想到过它！我可以理解我的系统内部正在发生的任何事情，它可能处于的任何状态——而不必发布新的代码来处理状态。这是关键。这就是可观察性。

你总是能理解你预测和检查的事情。但是如果你检查了某样东西，这意味着你知道要期待它，这就产生了一个第 22 条军规。监控工作如此长久的原因是，我们可以预测我们的系统将进入的大多数状态。连接会填满，CPU 会超载，你需要增加更多的应用程序容量或调整你的数据库，等等。你可以预测其中的大部分，你会发现其余的困难。系统相对稳定，唯一不可预测的问题是由您自己的团队部署代码引发的问题，这就是为什么这么多团队如此害怕部署。

系统是可观察的，在某种程度上，你可以理解新的内部系统状态，而不必猜测、模式匹配或发送新的代码来理解该状态。对我来说，这是将控制理论概念扩展到软件工程的最有用的方法。对大多数人来说，已知-未知系统状态与未知-未知系统状态的比率正在下降。未知-未知现在很快超过了监控仪表板向负责连续正常运行时间、可靠性和可接受性能的人员解释它们的能力。

这是一个值得保留的技术区别，并与单纯的遥测技术相区别，因为理解未知状态的能力是许多团队目前所缺乏的，这种缺乏每天都在严重伤害他们。随着现代分布式系统和服务的平台化，在你的余生中，你将不得不面对很多未知的事情。擅长解释它们是值得的。为这些解决方案保留一个技术词汇是值得的

### 可观测性及其前身

在过去的三年里，毫无疑问“可观察性”迅速发展起来，部分原因是由于其他人也加入了这场“运动”,尽管有相当多的人试图淡化这个术语并迷惑从业者。让我们走出去，按照时间顺序看看整个市场发生了什么。

我不是第一个在软件环境中提到可观察性的人。我第一次听到这个术语是在我遇到 Twitter 的监控团队时，当时这个团队被命名为“可观察性工程”。据我所知，他们把可观测性作为遥测术的同义词。

我第二次听到这个术语是在科里·沃森的文章中，“在 Stripe 创造一种可观察的文化。”科里是推特团队的经理。在 Honeycomb 开始采用、推广它并为此构建软件解决方案之前，我只知道这一点。

与此同时，包括谷歌在内的科技巨头们也在开发他们自己的可观察性平台，但按照 T2 的说法，他们并不称之为“可观察性”。这些工具，如 Dapper、Monarch 和 Dremel，根本没有外化，最初是为谷歌内部使用而构建的，直到谷歌云平台出现，这时他们需要一个外部市场驱动的名称，哦，嘿，看，[可观察性](https://cloud.google.com/service-monitoring/)现在是一个东西了？有时需要几个大玩家才能让它成为一个运动。

Honeycomb 的主要开发倡导者 [Liz Fong-Jones](https://twitter.com/lizthegrey) ，以前在 Google shared，“我们称我们正在做的事情为[监控](https://landing.google.com/sre/sre-book/chapters/evolving-sre-engagement-model/#the-sre-engagement-model-kpsOTpo)，[有时为](https://landing.google.com/sre/sre-book/chapters/monitoring-distributed-systems/)，除了它已经远远超出了外界所认为的“监控”(Nagios、Splunk 等)。).但我们也开始在 2016 年 3 月出版的《SRE》一书中平行使用“可观察性”、“观察”、“观察”。到 2017 年 11 月，谷歌工程师贾安娜·b·多安[使用了](https://medium.com/observability/googles-approach-to-observability-frameworks-c89fc1f0e058)“可观察性”，但指的是聚合的系统数据，因为这是在那个规模上对我们有用的。

蜂巢成立于 2016 年 1 月 1 日。我们花了第一年的时间构建存储引擎和查询规划器，为 Honeycomb 的产品奠定了坚实的基础，该产品可以在不影响基数限制的情况下进行扩展。2016 年过了一半，我陷入了困境，试图找出如何描述我们正在做的事情，以及这对经历过我在 Parse/脸书亲眼目睹的痛苦的软件工程团队将产生的影响。早期的“系统的商业智能”和“分布式系统的 strace”并没有得到我想要的效果，而且当时看起来有点太狭隘了。根据我的聊天记录，我在 2016 年 7 月查阅了可观测性的定义，并在那之后开始不停地谈论它。

作为即将到来的风暴的先兆，在 2016 年 6 月的 Monitorama 上发表了题为“监控已死”的演讲，讲述了人们试图使用当时最先进的技术运行生产系统的斗争

2017 年 5 月，我在 Monitorama 做了一个名为“监控:事后分析”的演讲，我谈到了监控模型的基数限制和其他固有问题，并在最后一张幻灯片上欢迎大家明年回到“可观察性-orama”。正如你所料，这让 Twitter 上的一些人变得暴躁。

2017 年 9 月，工程师辛迪·斯里德哈兰(Cindy Sridharan)写了一篇关于可观测性的有影响力的文章，其中她主要采用了我们的框架，并更多地揭示了已知-未知和未知-未知之间的差异。这证实了我们开始意识到的事实，即人们对监控、APM 和日志工具越来越不满意——它们不再能满足人们的需求。工程师们非常容易接受我们描述监控软件问题的方式，并准备、愿意和渴望听到下一步是什么，以及它将如何解决每天面临的日益增多的问题。

2017 年，Peter Bourgon 也发表文章称，可观测性有三大支柱。虽然供应商急切地抓住这个替代定义，但我会让 Lightstep 的本·西格曼在这里最彻底地驳斥这个。

2018 年，QCon 大会在其大会中增加了“可观测性”的赛道。Serverlessconf 系列也是可观测性的早期热情采用者——这非常有意义，因为无服务器的一些特征与新模型完全一致:完全通过仪器的镜头来观察世界，不记录到磁盘，根据请求密集地聚集大量信息，等等。

微服务社区和 Kubernetes 的采纳者也很早很快接受了可观察性。因为一旦你炸掉(或分解)了整块石头，你的大多数“传统”调试工具就不再工作了。您必须回到基本原则，再次做出所有这些决定，请求 ID 的聚合变得至关重要；最困难的部分是找出分布式系统中的问题所在，而不是调试代码本身。

在 2017 年至 2018 年期间，监控、APM 和日志管理细分市场中的几乎每个供应商都在其内容、网站和营销语言中添加了“可观察性”一词。这就把我们带到了下一节，关于有多少人滥用可观察性和误导他人。

### 可观察性的目的和价值是如何被曲解的

2018 年初，我注意到供应商已经将“分布式跟踪、指标和日志”作为“可观察性的三大支柱”本·西格曼[巧妙地揭穿了这一点，他说:*这毫无意义，因为那只是三种数据类型。你可以通过这三种方式实现[可观察性],或者一种都不实现——重要的是你如何处理数据，而不是数据本身。*](https://lightstep.com/blog/three-pillars-zero-answers-towards-new-scorecard-observability/)

如果你今天参加一个行业会议，你可能会听到发言者坚持准确的定义——可观察性是你如何解释未知-未知，它是关于探索和调试，而不是仪表板和模式匹配或访问某些数据类型。令我印象深刻和高兴的是，从业者对如此多的工具供应商向用户推广“三大支柱”定义所做的一揽子营销基本上无动于衷，然而我想知道他们还能坚持多久，以发布更多软件和增加支出为目标的数百万美元的广告支出。我满怀希望，但我不确定这是否只是“精英”的问题，或者更专业的定义是否最终会渗透到普通大众——但在过去的 6 个月里，我确实看到了这方面的早期迹象。

我有时被批评使用可观察性作为我自己的产品营销术语，并监管其定义。人们指责我将可观测性定义为“构成蜂巢的一组特征”很公正的批评！但是他们颠倒了因果关系。我们没有将可观测性定义为“蜂巢做什么”，而是首先定义了可观测性。我花了几年的时间来解决这些问题，花了几个月的时间来思考可观测性的定义和副作用，以及可观测性解决方案的含义。例如，如果没有以下条件，可观测性是不可能的:

*   原始事件
*   高基数维度
*   没有预聚合，没有预索引(这会使您陷入询问预定义问题的困境)
*   读取时间聚合
*   任意宽的事件
*   无图式性
*   结构数据
*   围绕请求的生命周期
*   批量上下文
*   不是基于指标的
*   静态仪表板不起作用，它必须是探索性的
*   等等。

然后我们精确地按照规格建造了蜂巢。

当然，我会在一定程度上监督人们如何使用它——我非常希望它是一个真正有意义的技术术语。我们需要特定的技术语言来解决我们作为软件工程团队所面临的问题。我们不需要遥测术的另一个同义词；我们已经有很多了。

如果我们不恰当地用“可观察性”来表示已知的未知和未知的未知之间，被动监控和探索性调试之间的差异，就不清楚还有什么其他术语可供我们使用(也不清楚同样的命运是否会降临到他们身上)。我相信，如果我们不能清楚地阐明监控和可观察性之间的(实质性)技术差异，这将使该行业倒退数年。但是这将取决于该领域的工程师，他们是唯一有能力让供应商对他们的语言负责的人——或者不负责。

### 可观测性的未来

在这短短的三年里，我思考了这个问题。*下一步是什么，这场运动将把我们带向何方*？我相信，在未来大约 3 年内，所有这三个类别— APM、监控/指标、日志以及可能的其他类别—都可能不复存在。只会有一类:可观察性。它将包含您理解系统可能进入的任何状态所需的所有洞察力。

毕竟，度量、日志和跟踪可以从任意宽度的结构化事件中轻易获得；反之则不然。

用户将开始意识到，他们需要多次支付存储单个数据集的费用，而他们只需要存储一次。没有理由向单独的监控供应商、日志供应商、跟踪供应商或 APM 供应商投资预算。如果您在任意宽度的结构化事件中收集数据，您可以从中推断出度量，如果您自动附加一些简单的 span 标识符，您可以使用这些相同的事件来跟踪视图。您不仅可以将支出减少 3-4 倍，而且如果您可以使用单一工具，在大图(“有一个峰值”)和深入到有错误的确切原始事件之间流畅地来回切换，效果会更好。接下来，计算它们有哪些共同的异常值，追踪其中一个异常值，定位问题所在的轨迹，并找出受特定异常行为影响的其他人。所有工作都在一个解决方案中进行，所有团队都获得相同级别的可见性。

现在这要么是 a)不可能的，要么是 b)人类必须将一个 ID 从一个系统复制粘贴到另一个系统。这是浪费的、缓慢的、麻烦的，并且对于在试图解决问题时不得不这样做的团队来说是极其令人沮丧的。工具造成了孤岛，而孤岛团队花费了太多时间争论现实的本质，而不是手头的问题。

## 与你的代码进行持续的对话

我们让软件工程师随叫随到，让他们能够在生产中真正理解自己的代码。我们使工程师能够在产品中进行测试，试验混沌工程、特征标志和其他现代实践。

三年前，这是业内一个活跃的争论。这些战斗已经结束；现在我们知道构建高质量服务的唯一方法是授权软件工程师在生产过程中拥有他们的代码。剩下的就是实施了，这一过程正在进行中，并将在未来十年左右继续进行，因为我们的行业将继续推动提供商大规模提供服务。

## 对于工程师…但也包括工程相邻的团队

我还认为，在为构建、改进和维护它的工程部门掌握了这一点之后——在获得了“验证我运送的东西按照我预期的方式运行，没有其他东西看起来奇怪”的紧密、良性的反馈循环之后，以及在成功地让开发人员待命之后——下一个前沿是向工程部门的团队展示真正的生产见解。支持人员、客户服务人员、产品经理，甚至这些系统的业务所有者，都会从对业务关键型应用程序的深入了解中获益。工具会产生孤岛——如果你的团队使用一种工具，而另一个团队使用不同的工具，你们对现实的看法就不一样了。在解决真正的问题之前，你会花很多时间在你认为现实的事情上产生分歧。

我们可以授权其他团队进行大量的调试和解决问题，甚至不需要工程师的参与。想象一个模板化的问题集，在开罚单和升级到工程师之前，让支持团队插入一个用户 ID，并检查投诉是否与已知的 bug 匹配或已经被修复，或者投诉是否真实。想象一下，你花了多少时间在 prod 里随叫随到，为别人解答问题。现在想象一下你什么都不用做。

越了解生产，每个人都是赢家。

## TLDR……这仍然是人的问题。

谁能提供最佳的最终用户体验，谁就能赢得这场战斗。正如 Mike Julian 在他的 Monitoring and Observability 2019 预测中所说，历史、社交分享以及不同团队之间的相互学习对于使分布式系统变得可理解和易处理是必要的。

AI 和 ML 是强大的(甚至可能是危险的)工具，但是太多的组织冒着本末倒置的风险。任何机器都可以检测到尖峰信号，但只有人类才能告诉你这个尖峰信号是坏的、好的、期望的、预期的还是可怕的。只有人类才能从数字中获得意义。

我们相信 Allspaw 的声明，即*调试必须永远是以人为中心的过程*。我们的目标应该是使这个过程尽可能愉快和协作。

<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 68 31" version="1.1"><title>Group</title> <desc>Created with Sketch.</desc></svg>*