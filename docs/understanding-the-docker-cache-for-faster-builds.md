# 了解 Docker 缓存以加快构建速度

> 原文：<https://thenewstack.io/understanding-the-docker-cache-for-faster-builds/>

关于 Docker 本身，每天使用它已经产生了一些关于缓存的见解，其他人可能会觉得有帮助。Docker 将缓存 docker 文件第一次构建的结果，允许后续的构建超快。这不是秘密，而且有据可查。但是成功地使用缓存需要工程师理解它是如何工作的。

在 Docker 文件中每次出现 RUN 命令时，Docker 都会创建一个新层并提交给映像，这只是一组紧密耦合的目录，其中充满了构成 Docker 映像的各种文件结构。在默认安装中，它们位于/var/lib/docker 中。

在新的构建过程中，所有这些文件结构都必须被创建并写入磁盘——这是 Docker 存储基本映像的地方。一旦创建，容器(以及随后的新容器)将存储在同一区域的文件夹中。

缓存的重要性体现在哪里？如果 Docker 将要生成的文件系统上的对象在两次构建之间保持不变，那么在主机上重用前一次构建的缓存可以节省大量时间。这使得建造一个新的容器非常非常快。这一次不必创建这些文件结构并将其写入磁盘——对它们的引用足以定位和重用以前构建的结构。

这比全新构建快一个数量级。如果您正在构建许多容器，这种缩短的构建时间意味着将容器投入生产的成本更低，以计算时间来衡量。

然而，这种缓存被大量使用，当您希望将运行命令的更新输出放入新容器时，可能会导致问题。按照现在的情况，除非 RUN 命令*本身*发生变化(从而使 Docker 的主机上缓存失效)，否则 Docker 将重用缓存中以前的结果。当 RUN 命令是源代码签出时，这显然是不利的，例如作为项目构建的初始步骤运行的 git 克隆。

幸运的是，有一些方法可以解决这个问题。

工程师可以使用'–no-cache '选项运行 Docker 构建，该选项完全忽略所有缓存，从而使每次构建花费的时间与第一次一样多。

这种方法显然是二元的——使用或不使用缓存。当'–no-cache '选项被传递给' Docker build…'时，该构建将总是从头开始，即使 Docker 文件中没有任何更改，也会向文件系统写入新的映像。这保证了不会重用陈旧的结果，但将总是花费最大的时间。

为了在利用缓存的同时获得新的克隆，工程师可以将源代码控制操作放在 docker 文件中列出的最后一次运行中。

但是为了使这成为一个唯一的命令，从而确保它每次都能运行，工程师可以将 Docker 构建包在另一个脚本中，该脚本为克隆操作生成一个唯一编号的迷你脚本。

这一步会将该脚本的调用插入到在构建之前即时生成的 docker 文件中，这样对于每次都必须运行的操作(克隆)来说，它的 run 语句确实是唯一的，即

RUN /bin/sh /foo-1234567abc.sh

其中“foo-1234567abc”是为每个构建唯一生成的(后续执行会创建类似“foo-26190def.sh”的内容)，并且包含克隆操作，即

cd /some/dir && /usr/bin/git 克隆 http://some.git.server/your-repo.git

其本身可能很少改变，或者从不改变。

这保证了 Docker 将在每次构建期间运行克隆，同时具有完全自动化的优势，并确保缓存一直使用到最后一次唯一运行。

使用这些方法，工程师可以充分利用 Docker 的缓存来确保一致、快速和准确的构建结果。

[**约翰·明尼汉**](https://www.linkedin.com/in/jbminn) 是现代回购的联合创始人兼首席执行官。

<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 68 31" version="1.1"><title>Group</title> <desc>Created with Sketch.</desc></svg>