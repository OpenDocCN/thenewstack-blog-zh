<html>
<head>
<title>Varnish Now Offers Cache Persistence for Large Datasets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Varnish现在为大型数据集提供缓存持久性</h1>
<blockquote>原文：<a href="https://thenewstack.io/varnish-overhauls-storage-engine-faster-video/#0001-01-01">https://thenewstack.io/varnish-overhauls-storage-engine-faster-video/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">


<p class="translated">随着基于网络的视频和照片共享的爆炸性使用，公司已经发现扩展内存是低效的。考虑到这一点，<a href="http://www.varnish-software.com/" class="ext-link" rel="external "> Varnish软件</a>最近推出了Varnish <a href="https://www.varnish-software.com/plus/massive-storage-engine" class="ext-link" rel="external ">海量存储引擎(MSE) 2.0 </a>。</p>
<p class="translated">Varnish是一个用于大型Web站点的开源HTTP加速器，新的MSE模块提供了一种缓存大量数据的方法，如果系统崩溃，可以快速重新加载。</p>
<p class="translated">“视频会消耗内存，”Varnish软件的创始人兼首席技术官帕斯·帕尔在最近于三藩市举行的<a href="https://www.varnish-software.com/events" class="ext-link" rel="external "> Varnish峰会</a>上解释道。此外，当系统移动到TB或petrabytes存储时，为千兆字节工作负载设计的内存分配在高压下是不可靠的。</p>
<p class="translated">帕尔认为，市场发生了巨大的变化。Varnish客户和市场中的其他人现在正从内容分发网络管理公司(cdn)转向管理他们自己的内容分发。</p>
<p class="translated">清漆正在帮助他们实现这一转变。例如，提供海量视频分发的Twitch正在内部分发视频。特斯拉和Pinterest都出席了峰会，它们运营着自己的cdn。</p>
<p class="translated">Varnish既适用于传统的CDN，也适用于进入这个领域的公司。“如果有一场CDN战争，你不想参战，你想成为武器供应商，”帕尔解释说。</p>
<p class="translated">基于<a href="https://thenewstack.io/varnish-api-engine-focuses-on-performance-amid-heavy-traffic/" class="local-link"> Varnish API </a>，Varnish工程师发现传统文件和malloc后端的伸缩问题导致了严重的性能下降。进入MSE，它关注三个基本领域:</p>
<ul>
<li class="translated">防碎片分配算法</li>
<li class="translated">由于LRU(最近最少使用)被LFU(最少使用)取代，缓存命中率更高</li>
<li class="translated">可选持久性数据存储</li>
</ul>
<p class="translated">基于文件的内存存在性能和碎片问题；它使用内存映射，使进程保持同步读取。帕尔称同步读取“完全是浪费”，因为它将处理时间限制在系统的读/写能力之内。</p>
<p class="translated">清漆创造了一个过程，称为孔扩张。“Varnish使用显式编写代码，然后在内核中使用水印系统进行分配，而不是使用内存映射进行隐式编写，”他解释道。这改变了限制因素I/O容量，而不是读/写容量，从而允许更快的响应时间。</p>
<p class="translated">“放在应用服务器前面，非常简单，因此速度也快了200–1000倍。因此，每次你将数据从缓存层移动到应用服务器，Varnish将在30-40微秒内提供数据，而典型的缓存需要10-20毫秒，”帕尔说。</p>
<p class="translated">每天数百万的视频或照片浏览量。</p>
<h2 class="translated">孔扩张是如何工作的</h2>
<div id="attachment_1133001" class="wp-caption aligncenter"><img aria-describedby="caption-attachment-1133001" decoding="async" loading="lazy" class="size-medium wp-image-1133001" src="../Images/f6ae548af50c8ff0655df27f63bdd874.png" alt="The algorithm combines the free space into a hole large enough for the new cache before inserting the new object." data-original-src="https://thenewstack.io/wp-content/uploads/2016/03/Screen-Shot-2016-03-21-at-12.22.07-PM-300x209.png"/><p id="caption-attachment-1133001" class="wp-caption-text translated">在插入新对象之前，该算法将空闲空间组合成一个足够大的洞，以容纳新的缓存。</p></div>
<p class="translated">Varnish工程师创建了一种算法来整合碎片化的空间，malloc虚拟化分配，然后依靠内核来完成这项工作。这为新对象创建了一个连续的空间，以便完整地插入，而不是分割新对象。</p>
<p class="translated">帕尔说，这使得使用Varnish的系统可以运行多年，而不会积累内存碎片。"支离破碎的空间会减慢速度."</p>
<p class="translated">为了实现性能的圣杯，Varnish不使用SendFile，而SendFile被认为是缩放方面的行业标准，这在不久前给他们带来了一些严厉的批评。帕尔对批评不屑一顾。Varnish不使用SendFile，因为这是不必要的，因为一切都已经映射到内存中。使用SendFile会复制现有功能，并显著降低系统速度。</p>
<h2 class="translated">LRU对LFU</h2>
<p class="translated">传统的内存缓存使用LRU而不是LFU。</p>
<p class="translated"><img decoding="async" loading="lazy" class="size-medium wp-image-1133002 aligncenter" src="../Images/14cb02098e4f6046638087583341354f.png" alt="Screen Shot 2016-03-21 at 12.26.37 PM" data-original-src="https://thenewstack.io/wp-content/uploads/2016/03/Screen-Shot-2016-03-21-at-12.26.37-PM-300x148.png"/></p>
<p> </p>
<p class="translated">配备“最少使用/最近最少使用的混合”缓存回收算法，在缓存中提供更智能的选择标准，以便在需要空间时自动回收最少访问的对象。<img decoding="async" loading="lazy" class="size-medium wp-image-1133003 aligncenter" src="../Images/77eb03b82dc46a663cd20b37f9b21947.png" alt="Screen Shot 2016-03-21 at 12.20.01 PM" data-original-src="https://thenewstack.io/wp-content/uploads/2016/03/Screen-Shot-2016-03-21-at-12.20.01-PM-300x192.png"/></p>
<h2 class="translated">坚持</h2>
<p class="translated"><a href="http://info.varnish-software.com/blog/varnish-mse-persistence" class="ext-link" rel="external ">MSE 2.0的新增功能</a>是使用持久性的选项。帕尔说，这几乎没有增加开销，但在崩溃恢复时间的好处是令人印象深刻的。</p>
<p class="translated">“如果服务器崩溃，在内存中重建内容会花费大量时间。帕尔说:“虽然内容越来越多，但性能却受到了影响。“我们在Varnish Massive Store Engine 2.0中添加了持久性，以确保我们的用户能够尽快修复和维护他们的网站。”</p>
<p class="translated">请注意，这不是一个放之四海而皆准的解决方案。帕尔说，这只对中型和大型客户有意义。“这就像一个本地的面包店，”他说，“如果你不管理万亿字节的数据，你就不需要那么多软件。”</p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
<title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>

</div>
</div>    
</body>
</html>