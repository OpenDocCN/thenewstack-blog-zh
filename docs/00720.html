<html>
<head>
<title>For Cloud Native, Application Security Starts with Identity Management</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对于云原生应用，应用安全性始于身份管理</h1>
<blockquote>原文：<a href="https://thenewstack.io/for-cloud-native-application-security-starts-with-identity-management/#0001-01-01">https://thenewstack.io/for-cloud-native-application-security-starts-with-identity-management/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">


<p class="translated"><a href="https://www.protego.io/" class="clearfix infoBlock " target="_blank"> <div class="infoBlockTextBlock"> <p class="infoBlockTitle">希勒尔·索洛</p> <p class="infoBlockText">希勒尔·索洛是Protego的CTO和联合创始人。在此之前，他是思科物联网安全部门的首席技术官，负责为新技术市场开发创新的安全解决方案。</p> </div> </a></p><p class="translated">关于如何看待无服务器应用程序中的权限和角色，我最近有了一些顿悟。也许对你们中的一些人来说，这不会像对我来说那样是“Soylent Green is People”。如果是这样，恭喜你。如果没有，让我打开你的眼睛。</p>
<p class="translated">让我们从一些家务开始。IAM(身份和访问管理)的理念是，像云帐户这样的系统中的参与者拥有一组有限的权限，这限制了他们可以做什么。虽然它最初是一个定义你的<em>用户</em>能做什么的概念，但它很快被吸收到其他事物的能力范围。</p>
<p class="translated">例如，如果您在AWS云环境中启动一个EC2实例，那么您需要为该实例分配一个IAM角色。AWS将为您强制执行该角色，确保无论什么逻辑找到进入该实例的途径，它都无法绕过这些限制。ECS容器、Fargate容器和Lambda函数也是如此。每个人都有自己的角色，定义自己能做什么和不能做什么。</p>
<h2 class="translated">从前…</h2>
<p class="translated">从历史上看，IAM角色不是AppSec的事情。我的意思是，您并没有真正思考过“我该如何防止那些讨厌的OWASP A1注入攻击？我知道，我会配置一个IAM角色。”IAM角色是一种基础设施。它们被用来广泛地限制某些邪恶(或者它们不是)，但是它们与你的开发人员在代码中写的东西没有什么关系，除了它们最好不要碍事。想要证据吗？过了一段时间，云提供商才允许您为每个无服务器功能分配一个独特的角色。有的还是没有(没错，谷歌，我在看你)。这是因为，如果您想从工作负载IAM角色中获得的只是划分出您不想触及的领域，那么您可能会满意地在一个通用策略中为所有工作负载这样做。</p>
<h2 class="translated">让有功能…</h2>
<p class="translated">出于一些有趣的原因，向云原生开发的转变，也就是说，从第一天起就为云构建应用<em>的想法，也带来了对小微服务的新的亲和力。对于词源学证据，追踪与术语<em>纳米服务</em>相关的情感。两年前，这是一个向云转型失败的同义词，就像“小心不要走极端，以纳米服务告终”。今天，它是当今的设计选择。</em></p>
<p class="translated">向更细粒度的微服务转变的一个有趣的副作用是有机会为每个小功能分配一个单独的IAM角色。我以前写过这方面的文章。无服务器应用程序给你机会收缩包装你的权限。我甚至谈到了在Protego，我们如何使用应用程序代码和行为的自动分析来为您的应用程序的每一部分应用最小特权。</p>
<h2 class="translated"><em>新</em>新AppSec</h2>
<p class="translated">最近我明白了为什么这如此重要。这是因为当你在函数的粒度上做IAM的时候，<strong> IAM </strong> <strong>就变成了AppSec工具</strong>。推动这一需求的应该是您的AppSec人员，而不是您的云基础架构安全人员。如果您能够将应用程序中每个函数、容器、存储桶和表的角色和策略限制到最低限度，您就可以防止您所担心的一大类应用程序攻击。</p>
<p class="translated">发生这种转变有两个原因。让我试着通过重新想象Equifax违规来说明这一点。</p>
<p class="translated">你会记得，2017年，Equifax遭到黑客攻击，超过1.4亿人的社会安全号码和驾照信息等敏感数据被盗。Equifax在一系列虚拟机上运行易受攻击的Apache Struts版本，攻击者能够在这些服务器上轻松执行恶意代码。从那里，他们可以相对容易地访问相邻数据库中的敏感数据。在这个整体应用程序中，运行Struts的机器可能拥有对所有数据库表的完全访问权。</p>
<p class="translated">相反，假设您是Equifax团队的领导，刚刚在Amazon Web Services上以云原生方式重新构建了Equifax应用程序，利用了最新的技术和架构。这意味着你为云设计了它，并使用了云的原生资源，如S3、DynamoDb和Kinesis。这还意味着，基于Apache Struts的大型应用程序将被重新设计为大量小型的单一用途功能，通过API Gateway响应事件。</p>
<p class="translated">好吧，你在想，大地震在哪里？我告诉你。第一部分是，你可能有150个Lambda函数和12个Fargate容器映像，而不是5个VM映像来存放应用程序。您不必为这五个虚拟机中的每一个都创建一个大的高风险角色，而是能够设计162个不同的角色，其中每一个都可以缩小到单个功能或容器所需的最低限度。</p>
<p class="translated">第二块是你停止部署自己的数据库、文件系统和数据处理管道，并重构这些来使用云原生资源。IAM策略可以管理的云原生资源。</p>
<p class="translated">因此，想象一下2017年的那些攻击者从你的酷新应用中窃取SSN。一个很大的优势是，用Amazon管理的东西(如API Gateway)代替您需要管理的东西(如Apache Struts ),这意味着他们正在处理您可能会忘记的补丁。更强大的是，您现在可以使用IAM非常具体地说明每个函数可以做什么，并且IAM在阻止访问每个函数中您不需要接触的数据方面更加有效。即使攻击者找到了在您某个函数中执行恶意远程代码的方法，IAM也有可能阻止该函数访问大量不同数据库中的1.4亿条记录。</p>
<h2 class="translated">那又怎样？</h2>
<p class="translated">因此，在使用Lambda和Fargate之类的细粒度云原生应用程序中，为每个功能定制的精心制作的IAM角色将减轻您的攻击面，甚至在您让开发人员编写更好的代码之前。我们在这里看到的主要挑战是让组织拥有向定制的最小角色的转变。技术，就像我们平台的一些功能一样，可以在现实世界中实现这种变化，在现实世界中，我们没有成千上万的安全工程师来审查代码和API以确定最佳策略。</p>
<p class="translated">云原生应用可以是AppSec的一次巨大飞跃，不仅因为我们现在如何使用IAM，而且正确地使用它既是机遇也是挑战。</p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
<title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>
</div>
</div>    
</body>
</html>