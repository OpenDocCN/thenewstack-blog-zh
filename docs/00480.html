<html>
<head>
<title>CoreOS's Open Cloud Services Could Bring Cloud Portability to Container-Native Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CoreOS的开放云服务可以为容器原生应用带来云的可移植性</h1>
<blockquote>原文：<a href="https://thenewstack.io/coreos-open-cloud-services/#0001-01-01">https://thenewstack.io/coreos-open-cloud-services/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">


<p class="translated">随着structural 1.8的发布，<a href="https://coreos.com/" class="ext-link" rel="external "> CoreOS </a>提供了一种将容器原生应用作为服务轻松部署的方式，甚至可以跨越多个服务提供商和内部资源。</p>
<p class="translated">CoreOS首席技术官<a href="https://twitter.com/brandonphilips" class="ext-link" rel="external "> Brandon Philips </a>说:“我们采用开源API，使它们非常容易使用，并创建了一个在Kubernetes上运行的这些东西的目录，这样无论你去哪里，它们都是可携带的。</p>
<p class="translated">在上周于奥斯汀举行的<a href="https://www.cncf.io/" class="ext-link" rel="external ">云本地计算基金会</a>的Kubecon 2017活动上，<a href="https://coreos.com/blog/tectonic-18-with-open-cloud-services" class="ext-link" rel="external ">公司推出了<a href="https://coreos.com/tectonic/#get-started" class="ext-link" rel="external ">构造</a>的最新版本</a>，这是其<a href="/category/kubernetes/" target="_blank"> Kubernetes </a>开源容器编排引擎的商业发行版。</p>
<p class="translated">这个想法是应用程序目录服务，称为开放云服务，在整个应用程序生命周期中像持续集成和部署管道一样工作。“应用程序目录中的每个应用程序都有多个版本，”飞利浦说。这种分类将使监控、日志记录和其他跨应用程序问题的基础设施标准化变得更加容易。</p>
<p class="translated"><iframe loading="lazy" title="Vault Open Cloud Service" src="https://www.youtube.com/embed/nEzR8UVFXvA?feature=oembed" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="">视频</iframe></p>
<p class="translated">这些服务将通过Kubernetes的运营商模式处理，这是CoreOS在2016年带给K8s的<a href="https://thenewstack.io/coreos-contributes-operators-containers-configure-kubernetes/" class="local-link">。运营商在Kubernetes集群内的单一命名空间中管理软件。</a></p>
<p class="translated">一个组织可能有多个名称空间，每个名称空间专用于一个应用程序的部署，例如一个用于测试，一个用于开发，一个用于部署。飞利浦说:“我们本质上是让你能够使用容器本地API来消费软件，并在你的应用程序的每个部署的基础上这样做。”</p>
<p class="translated">最初，CoreOS被打包成服务支持工具，往往与大多数应用程序一起使用，如Prometheus monitoring toolkit和<a href="https://www.vaultproject.io/" class="ext-link" rel="external "> Vault security store </a>。这样，无论部署什么云提供商来运行云原生应用，无论是Azure还是Amazon Web服务，用户都可以在应用旁边运行相同的支持工具。</p>
<p class="translated">“当您迁移到云时，最大的应用锁定可能是身份管理，这些帐户您只能从云提供商那里获得。通过引入Vault，我们[提供了一种方式]针对Vault API进行编程，而这个API是你可以带到Azure、AWS或你自己的数据中心的东西，”飞利浦说。</p>
<p class="translated">CoreOS将在服务中添加更多的云原生应用，并从客户那里获得关于优先考虑哪些应用的反馈。飞利浦表示，日志服务、数据库和Kafka等流媒体服务是非常适合纳入的应用类型。</p>
<p class="translated">“人们希望在一个可控的环境中运行这些东西。他们不想成为专家，”飞利浦说。在即将发布的版本中，该公司还将为用户提供用他们自己的应用程序来扩展我们的服务的方法。</p>
<p class="translated">该服务的一个潜在卖点是它将负责升级过程。升级金库尤其是一项复杂的任务。“我们已经把它转化为代码，所以你只需要告诉保险库服务升级到一个新的版本，我们会为你完成所有的步骤，”飞利浦说。</p>
<p class="translated">由于支持多种环境非常容易，该服务可能会激发组织创建更多的环境来测试和部署应用程序。</p>
<p class="translated">“这就是我们在CoreOS的工作。每当我们将一些东西签入代码时，我们都有一个QA环境。我们可以看到最后一次提交或最后20次提交，”飞利浦说。或者，如果生产中正在进行某项操作，我可以进入目录，查看生产中正在运行的版本，并在新的命名空间中创建一个新拷贝，记录生产中正在进行的操作，这样我就可以尝试重现它</p>
<p class="translated">服务目录可以帮助促使容器操作更接近应用程序管理级别。</p>
<p class="translated">Kubernetes拥有丰富的支持工具，如<a href="https://github.com/kubernetes/helm" class="ext-link" rel="external "> Helm </a>和<a href="https://github.com/ksonnet" class="ext-link" rel="external "> ksonnet </a>，但很少有人提供任何方式来理解应用程序级别正在发生的事情，飞利浦解释道。“它们改善了Kubernetes中容器的工作流程，但不能让你一键查看你想了解的关于应用程序的所有信息，”他说。</p>
<p class="translated">Philips看好Kubernetes API将成为未来几年云原生可移植性的基础。</p>
<p class="translated">“我们一直大力提倡扩展Kubernetes API来做更多的事情，”Philips说。Kubernetes命令行,<a href="https://kubernetes.io/docs/reference/kubectl/overview/" class="ext-link" rel="external "> kubectl </a>可能是从开发人员到网络工程师的每个人的中心访问点。“它给了人们自助的控制权，”他说。</p>
<p class="attribution translated">structural 1.8基于上个月发布的Kubernetes 1.8。</p>
<p class="attribution translated"><a href="https://coreos.com/" class="ext-link" rel="external "> CoreOS </a>是新堆栈的赞助商。</p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
<title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>

</div>
</div>    
</body>
</html>