<html>
<head>
<title>InfluxDB Moves to Cloud-Native Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">InfluxDB迁移到云原生架构</h1>
<blockquote>原文：<a href="https://thenewstack.io/influxdb-moves-to-cloud-native-architecture/#0001-01-01">https://thenewstack.io/influxdb-moves-to-cloud-native-architecture/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">


<p class="translated">InfluxData是一家提供InfluxDB时序数据库的公司，该公司专注于将其TICK堆栈(Telegraf、InfluxDB、Chronograf和Kapacitor)引入云原生架构，即运行在临时容器上的架构。</p>
<p class="translated">首席技术官和联合创始人<a href="https://www.linkedin.com/in/pauldix/" class="ext-link" rel="external ">保罗·迪克斯</a>、<a href="https://www.influxdata.com/" class="ext-link" rel="external "> InfluxData </a>说，他们的客户使用TICK作为服务，这种变化是必要的。这就产生了对多租户系统的需求，在这种系统中，工作负载可以从一个用户隔离到另一个用户。设置利用率限制和内存利用率限制的能力允许跨多个租户隔离工作负载。</p>
<p class="translated">“集装箱化的架构非常非常适合这种模式，”迪克斯在电话采访中说。</p>
<p class="translated">他说，InfluxDB的1.x版本看起来像一个整体系统，实际上几乎所有数据库都是这样实现的。但是设计团队2.0从底层开始被容器化，使用Kubernetes作为基础设施。</p>
<p class="translated">迪克斯说，栈运行在亚马逊网络服务上。Kubernetes是基础层，etcd存储元数据，Kafka用来写数据。其他一切都是Kubernetes内部创建的不同微服务。所有的特性都将是开源的，除了高可用性和扩展集群的代码，它们将在商业上可用。</p>
<h2 class="translated">什么是扁虱？</h2>
<p class="translated">InfluxDB创建于2012年，是一个用于实时指标和监控的SaaS应用程序。但是用户对基础设施更感兴趣，所以该公司开源了代码库，并随着时间的推移将其他组件构建到堆栈中。</p>
<p class="translated">Dix说，数据库系统是TICK Stack的一个组件，TICK Stack是一个处理时间序列数据的平台，旨在解决一些常见的数据问题。命名，收集，存储和查询，处理和监控，可视化。</p>
<p class="translated">这些组件是:</p>
<blockquote><p class="translated">T= <a href="https://www.influxdata.com/time-series-platform/telegraf/" class="ext-link" rel="external "> Telegraf </a>一个时间序列数据收集器代理，用于收集和报告指标和数据。这是一个运行在所有服务器上的二进制程序。</p>
<p class="translated">I= InfluxDB，时间序列数据库片段。</p>
<p class="translated">C = <a href="https://www.influxdata.com/time-series-platform/chronograf/" class="ext-link" rel="external "> Chronograf </a>是用于监控和仪表板的可视化部件。它包含处理堆栈组件的部分，包括监控和警报规则。</p>
<p class="translated">K = <a href="https://www.influxdata.com/time-series-platform/kapacitor/" class="ext-link" rel="external "> Kapacitor </a>是实时流数据处理引擎。它提供基本的ETL、异常检测、监控和警报。它适用于流和批处理模式监控，并向大约20个不同的系统发送警报，包括Slack和PagerDuty。</p></blockquote>
<h2 class="translated">去耦合是关键</h2>
<p class="translated">Dix <a href="https://thenewstack.io/the-technical-architecture-behind-tick-a-time-series-analysis-platform-using-influxdb/" class="local-link">在去年的一次播客中告诉TNS </a>,架构中的组件解耦是关键。设计团队为堆栈的不同部分创建了不同的服务，并将写入管道从索引管道、查询处理管道和监控管道中分离出来，从而允许每一个管道独立扩展。用户界面需要高速度，bug搜索不需要那么多。</p>
<p class="translated">InfluxDB的广泛用途带来了相应的各种工作负载需求。例如，查询处理。他们的许多用户在工作时都有实时仪表盘，但是一天下来会发生什么呢？停机时启动服务器是一种浪费。“将处理层与数据存储层分离意味着你可以拥有廉价的数据存储和非常灵活的短暂处理，”他解释道。</p>
<h2 class="translated">两种数据</h2>
<p class="translated">迪克斯解释说，有两种时间序列数据。常规数据发生在固定的时间点，如传感器数据、服务器监控数据或CPU读数。不规则数据是事件驱动的，例如对股票市场中的API交易的单个请求。“我们希望我们的堆栈能够很好地处理常规和非常规数据，”Dix说。</p>
<p class="translated">还有另一个维度需要考虑:冷热数据。热数据是在内存中和快速但昂贵的固态硬盘上易于查询的数据。另一方面，冷数据不太可能被访问，因此可以存储在较便宜的介质上，如亚马逊网络服务S3对象存储。</p>
<p class="translated">InfluxDB API的工作原理是跨热数据和冷数据无缝提取数据。迪克斯说，如果你从冷存储中提取数据，可能需要更长的时间，但你不必编写代码来获取数据。</p>
<h2 class="translated">Flux:新的查询语言</h2>
<p class="translated">传统的数据库平台并不是InfluxData重新思考的唯一问题。Dix花了一年时间编写Flux，这是一种与InfluxDB配合使用的新查询语言。“我不认为处理数据的最佳语言是在70年代发明的，也不认为除了SQL之外还有什么更好的语言，”迪克斯说。</p>
<p class="translated">他承认，学习一门新语言需要时间，但代价是开发人员的生产率。他专门编写了Flux来管理时序数据。SQL因返回最简单的时间驱动数据所需的代码量而臭名昭著。</p>
<p class="translated">“我们可以在语言中做一些事情，实际上使它变得更优雅，更容易使用，如果你试图编写一堆SQL查询的话，”迪克斯说。</p>
<p class="translated">他说，Flux的结构使得开发者很容易向语言中添加新的功能。</p>
<p class="translated">他希望看到更多的查询工作负载在数据库本身中完成。例如，对于数据科学家来说，从数据库中查询数据，将其拉回本地机器，对其进行一些处理，然后将数据加载回来是很常见的。拥有一种真正的脚本语言是简化这一过程的一个步骤。</p>
<p class="attribution translated">InfluxData 是新堆栈的赞助商。</p>
<p class="attribution translated">由<a href="https://unsplash.com/photos/w1g2o4J_4Dg?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" class="ext-link" rel="external ">科林·卡特</a>在<a href="https://unsplash.com/search/photos/influx?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" class="ext-link" rel="external "> Unsplash </a>上拍摄的特写图片。</p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
<title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>

</div>
</div>    
</body>
</html>