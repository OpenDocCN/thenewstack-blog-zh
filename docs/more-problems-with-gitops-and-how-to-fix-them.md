# GitOps 的更多问题——以及如何修复它们

> 原文：<https://thenewstack.io/more-problems-with-gitops-and-how-to-fix-them/>

Codefresh 赞助了这篇文章。

 [维克多·法西奇

Viktor Farcic 是 Codefresh 的首席 DevOps 架构师，Google 开发者专家和 Docker Captains 组的成员，也是一名出版作家。](https://www.linkedin.com/in/viktorfarcic/) 

GitOps 是一种新兴的管理系统实际状态的方法，它通过存储在 git 中的期望状态的定义，由 Kubernetes 执行。但是，尽管 GitOps 作为一个想法很棒，我们甚至还没有接近让这个想法在实际意义上有用。还有很多工作要做。

在之前的一篇[文章](https://thenewstack.io/the-problems-with-gitops-and-how-to-fix-them/)中，我探讨了许多关于 GitOps 实践的初始问题——即它被误解了，它经常被认为只是管理 Kubernetes 部署的一种方式，以及 GitOps 工具没有促进 GitOps 实践。

现在，我们来看看一些额外的问题:GitOps 原则通常甚至不能应用于 GitOps 工具，我们没有反映 Git 中集群内部发生的变化的工具，可观察性仍然不成熟。

让我们跳进兔子洞…

## **我们甚至经常无法在 GitOps 工具上应用 GitOps 原则**

这是一个鸡和蛋的问题。我们需要一只鸡来下蛋，但是我们不能有一只没有蛋的鸡。GitOps 也是如此。我们需要能够帮助我们应用 GitOps 的工具，但是我们如何在 GitOps 工具上应用 GitOps 原则呢？例如，如果我们选择 Argo CD 来管理基于 GitOps 原则的应用程序，我们必须问我们将如何管理 Argo CD 本身？我们被告知不应该手动执行类似`kubectl apply`的命令，但是我们必须部署 Argo CD 本身。即使我们忽略这一部分，说初始安装是一个例外，我们应该如何管理 Argo 光盘的升级和维护？现在，如果你仔细阅读文档，你会发现模糊的指令来手动安装它，将集群内部运行的资源导出到 YAML 文件中，存储在 Git 中，并告诉 Argo CD 将它们用作另一个应用程序。那可能允许 Argo CD 管理它自己，但是…来吧！我不需要告诉你在集群中部署一些东西并开始在 YAML 文件中探索这些东西是多么愚蠢。

然而，Argo CD 的情况是较好的情况之一。如果我们查看大多数其他工具的说明，问题只会变得更糟。

现在我们开始讨论可能会破坏 GitOps 并使其使用更加危险的部分。

## **我们没有反映 Git 中集群内部变化的工具**

我们的系统是动态的。他们一直在改变期望的状态，而我们**还没有工具来反映 Git** 中集群内部发生的变化。迷茫？让我给你举一两个例子。

让我们看看另外两个流行的例子: [Flagger](https://flagger.app/) 和 [Argo Rollouts](https://argoproj.github.io/argo-rollouts/) 。两者都提供了进行渐进式交付的方法。

Flagger 允许我们在几行 YAML 中定义(几乎)我们需要的所有东西，这些东西可以存储在 Git repo 中，通过 Flux 或 Argo CD 进行部署和管理。每当我们向 Git 推送更改时，这些工具将确保实际状态发生变化。到目前为止，一切顺利。

Flagger 最大的好处之一就是它会为我们创造大量的资源。它将创建部署、服务和其他“核心”Kubernetes 资源。例如，如果我们正在使用 Istio，它还将创建我们的应用程序正常工作所需的 VirtualServices 和其他组件。这很好，因为它简化了我们的许多工作。不用写几百行 YAML，我们可以用一个最小的定义——通常用几十行来衡量。然而，实际状态并没有收敛到期望的状态。Git 不是事实的唯一来源，因为在集群中运行的东西与被定义为 Flagger 资源的东西非常不同。然而，我们可以跳过这一点，说我们确实在定义期望的状态，但只是以一种不同的和更紧凑的格式。真正的问题是不同的。

Flagger 将向一小部分用户推出我们的应用程序，开始监控指标，并决定是向前还是向后滚动。如果一切按计划进行，它最终将向所有用户推出一个新版本。如果某个东西被关闭，它将回滚。太好了。它给了我们安全感。这就是为什么我们喜欢金丝雀部署。然而，这产生了不可调和的漂移。

当自动回滚发生时，Git 中的期望状态仍然是新版本应该在集群中运行，而实际状态是以前的版本。如果 Flagger 应用 GitOps 原则，它不会自动回滚。它会对 Git 存储库进行修改。这种变化会将应用程序定义的标签更改为推出新版本之前的标签。这将由 Flux、Argo CD 或另一个类似的工具来选择，该工具将通过有效地向前滚动来启动回滚的过程，但是到先前的版本。也许它应该恢复定义必须回滚的新状态的提交。或者，也许它不应该做这些事情，而是通知一些公共接口，以便其他工具可以做这些事情。这个设计是有争议的，但是这个过程是有争议的——至少对 GitOps 来说是这样的。

GitOps 迫使我们在一些自动化过程将实际状态汇聚成新的期望之前定义期望的状态。改变实际状态而不首先将其定义为期望的状态并将改变存储在 g it 中是一大禁忌。无论它在做什么方面有多伟大，也绝不是应用 GitOps。

这并不意味着 Flagger 不是一个好工具。太神奇了。然而，它把自己推销成一个 GitOps 工具，却没有真正应用它所提倡的原则。

## **Argo Rollouts 遇到了与 Flagger 类似的问题**

如果我们使用 Istio，Argo Rollouts 要求我们定义所有的资源。它不会为我们创造它们。我们仍然需要在典型的 Kubernetes 资源之上定义 Istio VirtualService 和其他服务。从编写和管理这些定义的人的角度来看，它比 Flagger 更复杂。另一方面，它对 GitOps 更友好。“魔法”变少了，导致我们更能控制自己的欲望。Argo CD 很少出现将实际状态收敛到期望状态的问题。

尽管如此，Argo Rollouts 确实在运行时修改了权重，因此不可避免地会出现无法调和的偏差。然而，这种漂移是暂时的。这是两种状态之间的暂时差异。虽然几乎可以肯定的是，对实际状态的一些更改(例如水平缩放)可能永远不会反映在期望的状态中，但想象工具进行渐进式交付也不是不可思议的——将权重的更改反馈给 Git，并让负责部署的工具应用它们。此类可能的操作会引发一些问题，尤其是在性能方面。尽管如此，如果不把他们完全改造成 GitOps，我们无疑可以走一条中间道路。

如果我们转到更重要的回滚问题，Argo 的推出和 Flagger 的推出一样复杂。当回滚发生时，它是自动的，存储在 Git 中的期望状态不会改变。根据 Git 的说法，从那时起，当集群中有旧版本时，我们正在运行一个新版本。如果我们更新应用程序定义的任何方面，除了 release 标签之外，系统将尝试推出回滚的同一个版本。我们会陷入不可预知结果的混乱。

所以，这两个工具都无法应用 GitOps 原则，除非 Argo Rollouts 意识到了这一点(有意或无意)，并且至少正在尝试改进。此外，由于它没有那么“神奇”，它更接近于 GitOps 友好——因为它迫使我们更加明确。尽管如此，这些都是灰色阴影，而不是真正的差异。

主要区别在于，在 Argo Rollouts 文档中，您不会发现它是一个 GitOps 工具。Argo CD 到处都有 GitOps，但 Argo Rollouts 没有。另一方面，Flagger 在其文档的主屏幕上有这样一句话:“您可以使用 Flagger 和 FluxCD 为 canary 部署构建完全自动化的 GitOps 管道。”

因此，如果双方都未能遵守 GitOps 原则，其中一方至少没有声称自己遵守了。

让我们进入可观察性。

## **可观察性不成熟**

这可能是 GitOps 的主要痛点之一:可观察性是不成熟的。

像 Argo CD 这样的工具确实向我们展示了当前的状态以及与之前的状态相比有什么不同。他们可能会向启动实际状态更改的提交添加一个链接，差不多就是这样。**用于创建实际状态的拉请求在哪里？问题在哪里(JIRA，GitHub 等。)让我们一开始就改变了状态？我们可能需要的其他信息在哪里？**

现在，你可能会说我们不需要所有这些东西都在一个地方。我们可以从一个工具到另一个工具，找到我们需要的所有数据。这是真的，但我不是考古学家(我是，但那是另一回事)。我不想花几个小时来确定是什么导致了实际状态的变化，以及谁做了什么和为什么。

更复杂的是，实际状态的可观察性甚至不是主要问题。理想的状态是一切都分崩离析。

首先，Git 不是为提供这种类型的可观察性而设计的。如果我想看到以前的期望状态，我可能需要经历许多拉请求和提交。当然，当查看单个 pull 请求时，其中只有在新版本部署中使用的图像标记发生了变化，事情看起来简单明了。但这不是真实的世界。大系统是复杂的。理想的状态一直在变化。一分钟前，一个团队可能表示希望将应用程序添加到预览环境中，另一个团队可能希望发布一个新版本，几分钟后，其他人可能希望再发布一个预览应用程序，而(同时)期望的生产状态可能正在发生变化。

当一切都像瑞士钟表一样运转时，这一切都很棒。但是当出现故障时——我向您保证它一定会出现——通过查看拉取请求和提交来找出谁想要什么绝非易事。尝试从一个 repo 跳到另一个 repo，切换分支，挖掘拉请求和提交，并在一个更大的组织中完成所有这些工作，该组织中有数百甚至数千名工程师不断地改变期望的状态，并间接地改变实际状态。我只能说，它既不漂亮也没有效率。

因此，我们需要一种方法来**可视化实际的和期望的状态，以穿越时间的能力为后盾，看看现在是什么和过去是什么。**

是的，我们需要一个好的方法来可视化实际和期望的状态。但是还有更多。我们需要把它们结合起来。我们需要能够看到应该是什么(理想状态)，是什么(实际状态)，包括现在和过去。我们需要所有这些，以及所有相关信息，如拉取请求、问题等。然而，即使所有这些也是不够的。

GitOps 是一组原则——就像所有被定义为代码的东西一样，代码存储在 Git 中，Git 保存期望的状态，机器将实际状态汇聚成期望的状态，等等。但是，它没有单独的机会。它是“更大的机器”的一部分，我们现在称之为连续交付(CD)。

我将在下一篇文章中讨论与 CD 相关的 GitOps 问题。重要的是，来自 CD 管道的信息也必须包含在 GitOps 可观测性中。我们需要知道哪些管道构建促成了当前或过去的状态。

在下一篇也是最后一篇帖子中，我将描述一些与 GitOps 相关的其他问题，包括:

*   没有既定的模式。
*   持续交付和 GitOps 之间的联系还没有很好地建立起来。
*   大规模运行 GitOps 极具挑战性。
*   管理秘密是一个大问题。

通过 Pixabay 的特征图像。

<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 68 31" version="1.1"><title>Group</title> <desc>Created with Sketch.</desc></svg>