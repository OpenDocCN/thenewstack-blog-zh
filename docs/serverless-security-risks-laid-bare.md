# 无服务器安全风险暴露无遗

> 原文：<https://thenewstack.io/serverless-security-risks-laid-bare/>

Twistlock 赞助了这个故事。

 [文斯·鲍尔

Vince 是 Twistlock 的客座博主，他专注于云的采用和使用基于开源技术的技术实现。他在核心计算和网络(IaaS)、身份和访问管理(IAM)、应用平台(PaaS)和持续交付方面拥有丰富的经验。](https://www.paloaltonetworks.com/prisma/cloud) 

我们可以说，无服务器平台有助于提高工作负载的安全性。作为部署小组件的一种选择，这些小组件可以执行特定的功能，并被链接在一起以形成全功能的服务，具有安全意识的开发人员获得了一种有用的新工具。

通过这种方式，[无服务器](https://www.twistlock.com/2018/02/22/decide-use-serverless/)可以用于从基础设施中抽象出另一层，使 DevOps 团队不必再担心保持他们语言的编译器和运行时最新，并修补所有已知的安全漏洞。从安全角度来看，这很好。

你可以这样总结无服务器的[安全优势](https://thenewstack.io/category/security/):容器确保操作系统和硬件层可以分别维护和保护，无服务器在应用程序和 web 服务器层提供了同样的优势。

然而，从安全角度来看，无服务器并不是灵丹妙药。无服务器环境的设计和管理仍然需要时刻考虑安全性。

为此，本文讨论了与无服务器计算相关的典型安全风险以及解决这些风险的技巧。

## 无服务器仍然需要输入验证

与任何构建和部署的应用程序一样，无服务器应用程序处理和传输数据。该数据可以作为启动处理的事件的一部分到达，也可以作为应用程序功能的一部分从数据源中检索。

正确的输入验证不仅仅是确保区号格式正确。输入验证阻止了应用程序面临的一些最常见的攻击类型。在无服务器应用程序的情况下，最常见的注入攻击类型是 SQL 注入(SQLi)。

SQL 注入攻击涉及将代码插入到请求中，该请求旨在返回过多数据或破坏数据。

输入验证的一个实际例子是，如果您的函数希望将一个电话号码作为有效负载的一部分传入，那么它将返回该电话号码的所有订单。

下面是一个很好的 SQLi 注入攻击的例子:

返回的数据太多了…

使用简单的正则表达式进行输入验证:

更多类型的注入攻击在 [Acunetix](https://www.acunetix.com/blog/articles/injection-attacks/) 发布的一篇文章中有详细描述。

## 秘密还是需要保密

当利用应用程序开发组件(如 API 网关)和云服务(如 AWS 上的 SQS)时，在身份验证和授权领域有一种向密钥和证书发展的趋势。由于这些不是传统的用户名和密码，它们经常会被忽略，并被登记到源存储库系统中。通过利用不同云平台中的 vaults，将它们作为环境变量呈现给各个功能，可以避免这个问题。

如果你想知道你是否在你的代码中签入了任何[秘密](https://www.twistlock.com/2017/09/12/manage-secrets-container-based-applications/)，有像[松露猪](https://github.com/dxa4481/truffleHog)这样的工具可以帮助你在 GitHub 上搜索你的历史。

在 Lambda 中设置环境变量是环境变量部分的一个选项。Azure 和谷歌云平台的功能有类似的配置。

例如，在 Python 中，您可以通过加载 OS 包来读取环境变量，然后像使用其他变量一样使用它。

在 JavaScript 中，它使用 process.env 对象。

## 过多的访问(和过少的访问控制)

在无服务器环境中，有两个与[访问控制](https://www.twistlock.com/2017/08/31/container-image-security-best-practices/)相关的明显风险。第一个问题集中在客户端对无服务器应用程序的访问权限，以及无服务器应用程序对与之交互的系统的访问权限。

关于客户端拥有太多访问权限的风险，人们倾向于只设置最低标准来使其按需执行，无服务器应用程序是一种单一功能就强调了这一点。实际上，该函数需要能够区分调用它的客户端和只过滤数据的客户端，因此它只允许与请求者相关的数据进行交互。无论是在 SQL 查询中自动追加 WHERE 子句，还是在向下游发送的消息中包含请求者信息，如果有人发现他们可以要求比默认返回更多的数据，数据泄漏都会导致严重的公共关系问题。

第二个访问控制风险发生在开发人员采取简单的方法，授予正在开发的特定应用程序比它需要工作的其他功能和服务更多的访问权限时。这种做法在开发层中很常见，因为目标只是让它发挥作用，但是在当今的持续集成和持续交付(CI/CD)模型中，将过度的安全性传播到生产系统中太容易了。一个简单的例子是，在开发中，应用程序被授予对数据存储的完全访问权，但是它只需要选择和插入的能力。拥有对数据存储进行更新或删除的额外访问权限可能看起来无害，直到有一天错误的脚本在错误的环境中运行，您丢失了宝贵的客户数据(如订单)。

将来，最佳实践是从开发中的最低层开始，只授予所需的访问权限，并为每个无服务器功能分配单独的用户，以使可追溯性和数据完整性更容易保证。

## 第三方图书馆老化不良

与任何平台上的开发一样，使用第三方库是加速业务功能开发和交付的一种非常常见和有用的方式。甚至上面的输入验证示例也使用一个库来检查电话号码。

一旦您部署了新的无服务器应用程序，并继续下一项工作，您刚刚部署的应用程序就开始老化了。这种老化很大一部分是因为第三方库仍在更新新功能和潜在的安全漏洞。如果您没有不断更新您的应用程序以确保每个库的最新版本，您很容易就会发现自己处于类似于 2016 年 Capital One 的境地，当时一个过时的第三方库允许暴露数百万客户的私人数据。

减轻这个陈旧的应用程序问题的最简单的方法是扫描您的代码并构建工件库来识别有风险的库，而不必经常更新您的所有应用程序。依靠扫描工具，您可以更好地利用您的时间和资源，并能够确定哪些应用程序和库需要更新，哪些应该更新。

## 结论

无服务器应用程序之所以伟大，是因为它们消除了维护和更新操作系统以及已部署应用程序的运行时层的需求。然而，不幸的是，serverless 并不是解决内部代码和第三方库问题的灵丹妙药。按照设计，无服务器应用程序是小型的、单一用途的，而且，如上所述，从设计和部署的角度来看，它们是很棒的。然而，从安全角度来看，需要采取整体方法来确保部署的大量无服务器功能保持最新。

通过 Pixabay 的特征图像。

<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 68 31" version="1.1"><title>Group</title> <desc>Created with Sketch.</desc></svg>