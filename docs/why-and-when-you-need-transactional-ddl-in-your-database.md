# 为什么以及何时需要在数据库中使用事务性 DDL

> 原文：<https://thenewstack.io/why-and-when-you-need-transactional-ddl-in-your-database/>

我们通常在数据操作语言(DML)的上下文中谈论事务，但是当我们谈论数据定义语言(DDL)时，同样的原则也适用。随着数据库越来越多地包含事务性 DDL，我们应该停下来想想事务性 DDL 的历史。事务性 DDL 允许您在一次操作中执行多次修改，从而简化软件升级，有助于提高应用程序的可用性。您不太可能发现自己在处理一个部分升级的系统，这个系统需要您的数据库管理员(DBA)去手工修复所有东西，浪费了他们几个小时的时间，并且减慢了您的软件交付速度。

## 你为什么在乎？

 [马丁·凯塞尔

自 2015 年以来，Martin Kysel 一直是 NuoDB 的一部分，担任 C++工程师、scrum master 和技术主管。他在平台和 SQL 之间的交叉领域的工作给了他充分的机会，不仅可以理解 NuoDB 的战略优势，还可以理解它与老牌公司的共性。Martin 对技术充满热情，并通过演讲、文章和聚会分享他的知识。他 10 多年的经验涵盖了从数据库/网络管理到高性能分布式软件工程的各种角色。](https://www.linkedin.com/in/martinkysel/) 

如果您对应用程序代码进行了更改，但有些地方不工作，您可能不想处理复杂的恢复工作。您希望数据库能够自动回滚，以便快速返回到工作状态。今天，人们经常不为数据库写代码，他们有框架来做(例如 Hibernate)。这使得软件工程师不可能正确地编写代码，或者回滚代码，因为他们不在那个层次上工作。当您使用滚动应用程序升级进行更改时，会更简单，更不容易失败，并且当您遇到失败时该做什么也更明显。

有了事务性 DDL，您就不太可能必须处理部分升级的系统，这种系统基本上会使您的应用程序停止运行。像这样的部分升级可能需要您的数据库管理员(DBA)去手工修复一切，浪费了他们的时间，并减缓了您的软件交付。使用事务性 DDL，您可以回滚到最后一次工作升级并快速解决问题，而无需使您的软件交付系统或应用程序离线。

### DML 和 DDL 的简短说明

本质上，DML 语句是我们用来操作数据的结构化查询语言(SQL)语句——您可能已经猜到了。具体来说，DML 类包括 INSERT、UPDATE 和 DELETE SQL 语句。有时，我们将这三个语句称为 WRITE DML，将 SELECT 语句称为 READ DML。该标准没有区分读和写，但是对于本文来说，这是一个重要的区别。

另一方面，DDL 是一系列 SQL 语言元素，用于定义数据库结构，尤其是数据库模式。CREATE、ALTER 和 DROP 命令是 DDL SQL 语句的常见示例，但 DDL 语言元素可能包括对数据库、表、列、索引、视图、存储过程和约束的操作。

接下来，让我们首先将事务定义为收集到单个逻辑单元中的一系列命令，然后事务作为单个步骤执行。根据这个定义，如果事务的执行被中断，则该事务不会被执行。因为事务必须是 ACID——原子的、一致的、隔离的和持久的，这意味着当事务执行几个语句(其中一些是 DDL)时，它将它们视为可以回滚或提交的单个操作。这意味着您永远不会让数据库处于临时的、不一致的状态。历史上，数据库没有提供事务性 DDL 语句的功能，但即使在今天，也不是所有的数据库都提供真正的事务性 DDL 的功能。在大多数情况下，这种功能是有限制的。

那么，真正的“事务 DDL”是什么意思呢？这意味着所有语句都应该是 ACID，不管它们是 DML 还是 DDL 语句。实际上，对于大多数数据库，DDL 语句会破坏封闭事务的事务性，并导致异常。

### DDL 简史

最初，数据定义语言的概念是作为 Codasyl 数据库模型的一部分引入的。CODASYL 是数据系统语言会议/委员会，于 1959 年作为一个联盟成立，以指导标准编程语言的开发，这导致了 COBOL 和许多技术标准。CODASYL 还致力于标准化数据库接口，这是其成员促进更有效的数据系统分析、设计和实现的目标的一部分。

1969 年，CODASYL 的数据库任务组(DBTG)为他们的数据模型发布了第一个语言规范:一个用于定义数据库模式的数据定义语言，另一个用于定义数据库的应用程序视图的 DDL，以及(你猜对了)一个定义请求和更新数据库中数据的动词的数据操作语言。后来，DDL 用于引用 SQL 的子集来声明表、列、数据类型和约束，SQL-92 引入了模式操作语言和模式信息表来查询模式。在 SQL:2003 中，这些信息表被指定为 SQL/Schemata。

然而，DDL 的事务性不是 ANSI SQL 标准的一部分。[ANSI SQL 2016](https://webstore.ansi.org/Standards/ISO/ISOIEC90752016-1646101?source=blog)(<start transaction 语句>)的 17.1 节只规定了语法和支持的隔离级别。它没有指定事务应该如何表现或“事务性”的含义。

### 为什么事务性 DDL 没有被普遍提供？

DDL 语句没有理由不应该是事务性的，但是在过去，数据库没有提供这种功能。在某种程度上，这是因为事务性 DDL 意味着 DDL 必须与同时发生的其他事务隔离开来。这意味着修改后的表的元数据必须进行版本控制。为了正确处理元数据更改，我们需要能够回滚由于事务回滚而中止的 DDL 更改。这并不容易——事实上，这是一项复杂的算法任务，需要数据库支持元数据增量(diff ),这对应于每个数据库连接的当前事务中的 DDL 更改。这个增量在事务关闭之前就存在，因此它可以作为单个事务回滚，或者在支持多级事务或保存点的 RDBMSs 中部分回滚。本质上，它不是普遍提供的，因为很难做到正确。

> 对于迁移到微服务、开发运维以及 CI/CD 的组织来说，他们有一个基本的新需求，即支持在线事务 DDL 的数据库。

让我们回到写 DML(更新、删除、插入)和读 DML 的概念上来。您可能会问自己，在一个支持多个并发事务并且一个 DDL 事务正在进行的系统中，这些语句是如何发生冲突的？理想情况下，冲突的事务集尽可能小。SELECT 语句不会与 INSERT 语句冲突。在 DDL 的上下文中没有理由会有任何不同。DDL 语句 ALTER TABLE 不应阻止 SELECT 语句并发执行。这是数据库设计中的一种常见模式。

为了使 DDL 成为事务性的，您需要同时支持多个版本。类似于多版本并发控制(MVCC)，读者不会阻止作者，作者也不会阻止读者。没有 MVCC，很难有事务性 DDL。传统上，数据库是从锁定系统而不是 MVCC 开始的。这种实现不适合事务性 DDL，这就是为什么在 2005 年左右出现了向 MVCC 的重大转变——提供对数据库的并发访问，并在编程语言中实现事务性内存。

MVCC 提供了我们自然想要的语义。当冲突的写入(写入 DML 和 DDL)同时执行时，读取 DML 可以继续进行。

### 在实时系统中编写 DML 和 DDL

我们已经确定，不管系统中还有什么正在并发执行，Read DML (SELECT)都可以顺利进行。不允许在被 DDL 同时修改的表上执行 Write DML (INSERT、UPDATE、DELETE)。基于所有并发事务的隔离级别解释冲突预期行为的语义超出了本文的范围。

为了简化讨论，我们声明如果在相同的资源上执行，写 DML 和 DDL 是互斥的。这导致操作相互阻塞。如果您有一个长时间运行的 DDL 事务，例如应用程序的滚动升级，那么将在很长一段时间内禁止写入 DML。

因此，即使 DDL 是事务性的，它仍然会导致数据库停机和维护窗口。是吗？

### 始终在线，随时可用

数据库行业正朝着永远在线、永远可用的模式发展。早期的数据库会显示一条消息，提示某些内容不可用——这基本上是因为您长时间地锁定了一个数据库。在始终在线、始终可用的模式中，这不是一个选项。

客户和组织都要求应用程序始终在线且可用。这意味着事务性 DDL 对于新的世界是强制性的，而不仅仅是应用程序按照客户要求的方式运行。对于采用开发运维、持续集成和持续交付模型(CI/CD)的组织来说，这也是强制性的。具体来说，这是因为如果没有事务性 DDL，应用程序开发人员就不能安全、方便地在线更改数据库模式(以及他们的应用程序更改)。这意味着，对于迁移到微服务、开发运维以及 CI/CD 的组织来说，他们有一个基本的新需求，即支持在线事务 DDL 的数据库。

我个人认为“在线”这个词容易让人误解。当数据库持有资源锁时，它没有脱机。更恰当的说法应该是无锁 DDL。也就是说，元数据修改可以在不锁定并发 DML 的情况下发生。

### 可用性与简单性的权衡

我们说过写 DML 不能与 DDL 同时发生，以避免 ACID 冲突。现在，一个必须一直运行并需要执行长时间运行的 DDL 语句的系统会怎么样呢？幸运的是，大多数 DDL 语句并不需要很长时间。无论表有多长，在表中添加或删除列都需要一定的时间。如果更改集足够小，可以在短时间内锁定 DML。

但是有些 DDL 语句需要处理表中的每一行，因此处理大型表需要很长时间。CREATE INDEX 是长时间运行语句的一个典型例子。鉴于索引创建可能需要几个小时，对于始终在线、始终可用的应用程序来说，这不是一个可接受的选项。

具体来说，对于索引创建，NuoDB 和其他数据库实现了一个在线或并发版本(我更愿意称之为无锁版本)。这个版本允许 DBA 在不锁定表或不需要维护窗口的情况下创建索引，这在 24×7 可用性世界中是一个极其重要的功能。然而，这些能力不是免费的。常见 DDL 语句的在线版本往往比它们的锁定版本稍慢，具有复杂的故障模式，并且难以理解 ACID 语义。它们也不能是更大的多语句 DDL 事务的一部分。

有趣的是，有时执行的速度并不是首要考虑的问题。在这种情况下，您可能不想使用在线版本。您可能有一个需要对数据库模式进行复杂更改的应用程序，对于更简单的升级过程来说，一些锁定是一个可行的折衷方案。

ACID 的四个保证之一原子性声明:*“每个事务都被视为一个‘单元’，要么完全成功，要么完全失败。”*

如果我们把事务看作许多 DDL 语句的集合，这将成为一个非常理想的特性。一个例子是:改变一个表；创建一个具有相似名称的日志表；在其他表格中插入几行。我们已经知道，如果不对 DDL 进行事务处理，您可能会在其他表中得到新行，但是 CREATE 和 ALTER 都不会成功。或者您可能最终只有创建而没有更改。

因此，如果您有一个应用程序，它假设如果有一个日志表(CREATE ),它也可以假设更改已经发生，如果升级没有完全完成，您可能会在生产中遇到微妙的错误。事务性 DDL 使数据库管理员能够在一次操作中执行多次修改(例如上面的例子)。

对于开发人员来说，事务性 DDL 的强大隔离保证使得应用程序的开发更加容易。应用程序只能观察状态 A(升级前)或状态 B(升级后)的数据库，永远不会看到部分结果。这减少了所需的测试矩阵，并增加了对滚动升级过程的信心。这很容易编码。

自从 InterBase 将 MVCC 引入商业市场以来，业界已经知道在锁定的滚动升级的简单性和非事务性的始终可用、始终在线之间的权衡。

### 选择事务性 DDL

自 1959 年以来，数据库发生了很大的变化，从那时起，客户对用户体验和应用程序可用性的期望也发生了很多变化。事务性 DDL 帮助您避免应用程序不再可用的情况，并让您的 DBA 高枕无忧，因为他们知道他们不必费力地修复数据库来使您的软件交付恢复速度。今天，许多数据库提供了事务性 DDL，它将通过回滚到最后一次工作升级来帮助您快速解决眼前的问题。为了满足当今始终可用的需求，请选择提供事务性 DDL 的数据库。但是请记住，现代的始终可用、始终在线的应用程序需要一个不仅能简化升级场景，还能限制由于长时间运行元数据修改而导致的停机时间的数据库。

<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 68 31" version="1.1"><title>Group</title> <desc>Created with Sketch.</desc></svg>