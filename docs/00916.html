<html>
<head>
<title>Google’s Cloud Code Plug-Ins Take the YAML out of Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">谷歌的云代码插件将YAML从Kubernetes中移除</h1>
<blockquote>原文：<a href="https://thenewstack.io/googles-cloud-code-plug-ins-take-the-yaml-out-of-kubernetes/#0001-01-01">https://thenewstack.io/googles-cloud-code-plug-ins-take-the-yaml-out-of-kubernetes/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">


<p class="translated">随着Kubernetes变得越来越受欢迎，人们也认识到开发人员的体验并不理想，需要开发人员获得大量的运营专业知识才能变得高效。谷歌产品和设计副总裁Pali Bhat告诉新的堆栈，云代码是谷歌计划的一部分，<a href="https://thenewstack.io/how-google-cloud-run-combines-serverless-and-on-demand-kubernetes/" target="_blank" class="local-link">与云构建和云运行</a>一起，使Kubernetes更容易为开发者所用。</p>
<p class="translated">“有很多开发团队从来没有考虑过传统意义上的服务器，现在有了Kubernetes，他们开始考虑这个问题。过去的情况是，开发人员开发他们的应用程序，然后将它扔到墙外，系统管理员团队会尝试部署它。那是坏的，”巴特解释道。“我们用Kubernetes解决了这个问题——只是现在开发者突然不得不考虑Kubernetes。云代码的起源来自与客户的对话，他们告诉我们‘我有所有这些业务应用程序开发团队，我希望他们专注于业务逻辑，但不幸的是，他们现在不得不弄清楚如何使用容器和进行云原生开发。"</p>
<p class="translated">Bhat建议说，Kubernetes提供了可编程的基础设施，但这并不是开发者真正想要的。“开发团队根本不想考虑基础设施。”</p>
<p class="translated">“如果我们可以使用云代码和云运行之类的东西来简化过程，简化云原生应用的开发，那么开发人员就可以回到只考虑自己的代码和应用，但他们仍然可以获得好处:灵活性、抽象性、更好地利用他们的服务器和可扩展性，”他说。</p>
<h2 class="translated">应用程序代码，不是YAML</h2>
<p class="translated">云代码旨在与云构建、云运行和Knative一起工作，Bhat建议将其视为“Kubernetes和Istio之上的伟大开发人员体验”。Google显然希望公司使用从CI/CD和使用Cloud Build的自动部署到Cloud Run的自动伸缩和服务的整个链，但是您可以使用云代码在任何Kubernetes集群上部署和调试。</p>
<p class="translated">“它不仅可以构建本地集群，还可以从IDE中自动构建远程集群。他们可以设置断点，可以进行全面的调试，并且可以在现有的开发环境中完成所有这些工作，这是您的开发人员和appdev团队所熟悉的。这看起来像完全本地应用程序开发，但它是针对一个动态集群。使用Skaffold、Jib和kubectl等工具，我们可以近乎实时地对其进行监控，因此您可以查看集群并获得关于整个体验的实时反馈。它在您的IDE中为您提供了端到端的开发生命周期。”</p>
<p class="translated">云代码包括一组<a href="https://github.com/GoogleCloudPlatform/cloud-code-samples" target="_blank" rel="noopener noreferrer external " class="ext-link">样本</a>，这些样本被预设为发布到谷歌Kubernetes引擎(GKE)和云运行，但管理员和开发经理可以定制这些样本，以部署到他们自己的Kubernetes环境中(该环境使用了<a href="https://kubernetes.io/blog/2018/05/29/introducing-kustomize-template-free-configuration-customization-for-kubernetes/" target="_blank" rel="noopener noreferrer external " class="ext-link">谷歌的Kustomize项目</a>)。“我们让你连线你的目标集群，它可以是任何Kubernetes，”Bhat证实。</p>
<p class="translated">开发人员仍然可以在他们的IDE中查看和定制YAML文件，如果需要的话，一个有用的选项可以让您区分源代码控制中的YAML文件和部署在集群上的YAML。可扩展的YAML林挺给出任何语法错误的即时反馈，同样可以为您的策略定制。</p>
<p class="translated">最初，该插件支持Visual Studio代码和IntelliJ，并支持Java、Python和Ruby，但谷歌正在考虑客户正在使用的其他开发环境，以及更多的语言；。NET核心支持已经在开发中，但还没有发布，NodeJS和Go也即将推出。这是一个支持开发人员已经在使用的工具的务实决定。</p>
<p class="translated">这两种ide的特性列表略有不同。借助云代码，IntelliJ可以与Google云存储和应用程序引擎进行更好的集成，而Visual Studio代码插件允许开发人员浏览Kubernetes资源，将秘密放在卷和环境变量中，监控和配置本地Minikube集群，或者在GKE、EKS和AKS创建集群，而无需离开IDE。</p>
<p class="translated">Bhat说，未来云代码还将与其他Kubernetes和DevOps工具集成。“随着时间的推移，我们将扩大这一产品组合，并为您的定制CI/CD渠道构建定制能力。没有两个组织拥有完全相同的CI/CD流程；每个客户都有自己定制和调整的东西，因为应用程序开发是定义产品和服务的核心部分。我们的目标是使我们的工具链能够跨越云代码和云构建，以适应这种体验。”</p>
<p class="translated">IntelliJ中的云代码使用Stackdriver在GKE上进行基于快照的生产调试，计划是从Stackdriver中带回更多信息，以便开发人员在编写代码时可以在他们的开发环境中看到这些信息。Bhat说:“我们想做的是最终开始获得运营指标，并将它们带回你的IDE中。</p>
<p class="translated">这种信息对于像<a href="https://code.visualstudio.com/blogs/2017/02/12/code-lens-roundup" target="_blank" rel="noopener noreferrer external " class="ext-link"> Visual Studio Code的CodeLens </a>这样的东西特别有用，它给你上下文信息；在生产中查看一段代码的响应时间可以更容易地改进代码库。Bhat希望该工具能为客户提供这样的开发效率。</p>
<p class="translated">“他们转向云计算的原因是，他们希望变得更加敏捷，而支持这种敏捷的方式就是去掉所有无聊的部分，并实现这些部分的自动化，让开发人员专注于构建令人惊叹的应用。”</p>
<p class="translated"><a href="https://cdn.thenewstack.io/media/2019/04/13a014a7-google-plugin-01.jpg" class="local-link">T3</a>T5<img decoding="async" loading="lazy" class="aligncenter wp-image-7241299 size-full" src="../Images/ba74bd9496bfe71594a6e11510eb260c.png" alt="" data-id="7241299" data-original-src="https://cdn.thenewstack.io/media/2019/04/350743a4-google-plugin-02.jpg"/>T7】</p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
<title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>
</div>
</div>    
</body>
</html>