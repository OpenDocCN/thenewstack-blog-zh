# 如何在生产环境中运行容器

> 原文：<https://thenewstack.io/containers/considerations-containers-production/>

如果只在开发和测试环境的范围内采用面向[容器的开发](https://thenewstack.io/containers/)和部署工作流，那么采用面向容器的开发和部署工作流的好处就不会完全实现。不愿意在生产中运行容器源于对安全和隔离的关注，以及在生产环境中管理容器的操作专业知识的普遍缺乏。

在处于采用容器的某个阶段的组织中，将容器转移到生产环境中的决策是一个主要的考虑因素。在为一个全新的服务或应用程序采用容器时，最好是容器原生的，这样做比较容易。

容器原生意味着什么？容器原生应用程序是围绕容器的生命周期设计和构建的应用程序，它将容器视为其存在的头等公民。对于已经改进为使用容器的应用程序来说，转向生产的决定通常更加困难。这指的是遗留应用程序，这些应用程序易于进行大量的重构，以采用面向容器的开发和部署。

理解对组织的生产环境中的现有工作流和过程的影响是在生产中操作容器的一个重要方面。以下是一些可能受容器影响的生产工作流和流程:

*   将变更或特性集从开发阶段转移到生产阶段。
*   允许最终用户访问产品中部署的变更或特性集。
*   调试生产中报告的问题。
*   监控生产中的应用。
*   在生产中更新应用程序版本。
*   备份生成的数据。
*   灾难恢复和业务连续性。
*   生产能力计划。
*   设置主机，尤其是网络和安全配置。

## 容量规划

在采用容器的过程中，在没有容器的情况下运行生产环境是大多数组织的标准。在这样的组织中，虚拟机可能优先作为部署单元，满足应用程序组件的隔离和管理需求。最有可能的情况是，这些单独的组件分布在一组虚拟机上，这些虚拟机以冗余配置运行在多个主机上，从而实现高可用性。如果生产环境与其他应用程序共享，那么虚拟机就成为这种隔离的重要工具。

运营团队控制虚拟机管理和生命周期，通常通过某种形式的自动化和工作流将应用程序代码复制到虚拟机上。虚拟机很少因新部署而被销毁，而是被重用，因为新部署的代码版本不断出现。偶尔，这些虚拟机也会发生变化，理想情况下是通过使用新版本的黄金映像来重建虚拟机本身。

或者，一些组织在发布对生产环境中的应用程序或基础架构的更改时，通过丢弃旧的虚拟机来重新配置新的虚拟机集。网飞的 Aminator 以及围绕它的实践，成为了基于虚拟机的生产环境管理如何仍能使用不变性和可处置性原则的潮流引领者。

容器的支持者越来越支持在裸机上运行容器化的工作负载。这有助于避免因在裸机和操作系统之间使用虚拟机管理程序而导致的性能和上下文切换损失。如果我们运行不打算共享其他不可信租户的资源的单租户系统，这种争论会更加明显。

处于容器采用早期阶段的组织可以尝试使用一种混合策略来处理这种情况:将容器化的应用程序组合在作为虚拟机的机器上运行，一些在裸机上运行。通过分析一段时间内的管理和性能指标，可以对这种组合进行微调。当操作容器达到一定的成熟度时，一些采用者选择只使用裸机来运行他们的容器。

当在共享的生产基础设施上运行多个应用程序时，在裸机上运行容器的决定应该基于以前的经验。更安全的选择是将这些多个租户包装在虚拟机周围，让容器成为这些虚拟机内服务的运行时部署。每个 VM 可以托管属于同一个租户的容器，提供与其他租户的隔离。

图 1:在低成熟度阶段，租户不共享生产基础设施。这种隔离可以是虚拟机或物理主机。在高成熟度时，每个租户应用程序的组件都分布在共享的基础设施中。当考虑容器时，高成熟度代表一个共享的 VM 或裸机基础设施，其中每个租户应用程序的组件都是分散的。

## 在生产中发布应用程序

容器的短暂特性允许通过在每个新的容器实例中启动代码更改来进行更新，而不是更新现有的实例。当一个特定的变更被标记为投入生产时，使用新版本的容器映像创建一组新的容器，由一个新的标签标识。理想情况下，新标签是在持续集成(CI)过程中生成的。生成的图像和标记存储在容器图像注册表中，生产环境可以访问该注册表。

虽然可以在所有环境(包括开发、测试和生产)之间共享容器注册中心，但在某些情况下，单独的容器映像注册中心专门用于生产环境。这个专用于生产的容器映像注册表不与其他环境共享。在这种情况下，需要有一个提升过程，将“候选”容器映像从标记为开发和测试的注册表中提升到标记为生产的注册表中。可以使用一个中间系统从开发/测试注册表中提取候选映像，并重新标记和推送候选容器映像到标记为生产的注册表中。使用这种方法，非生产环境和生产环境之间的映像注册表中存储的映像和可用的映像有明确的隔离。

容器的瞬态方面对使用静态端口绑定和部署应用程序的主机的 IP 地址的现有实践施加了约束。这有助于网络防火墙和交换机的配置。发布生产变更的最佳实践是采用滚动升级。这需要生产环境中的额外基础设施来修改现有的负载平衡器和代理配置，同时在现有版本上启动一组新的容器实例。

[cyclone slider id = " ebook-3-赞助商"]

为了在部署容器时保持一定程度的弹性，明智的做法是围绕编排工具利用容器运行时和平台的产品。如果您只使用容器运行时，而没有任何编排工具，那么利用像“–restart”策略这样的运行时配置是非常重要的。建议的重启策略是在“出现故障时”和“除非停止”配置之间切换，或者选择一个对您的环境有意义的配置。

## 为生产中的容器设置主机环境

为运行容器准备生产基础设施的一个重要方面是承认容器映像的“密封”性质。容器映像需要一个标准化的基础设施，在开发、测试和生产环境中保持相似的配置。这种标准化对于在生产中运行容器时获得可预测的体验至关重要。以下是一些需要考虑的因素:

*   内核的选择。
*   容器运行时版本和选择。
*   网络访问和防火墙配置。
*   安全强化解决方案的选择。
*   系统访问权限。

人们可能会倾向于放弃跨环境标准化所有这些因素；然而，任何异常都会导致不可预测的结果，可能需要进行调查。解决这个问题最简单的方法是确保每个环境，从开发到测试再到生产，都是用相同的拓扑结构构建的。这在开始时可能很难实现，但是可以把它看作是采用容器的目标。所有环境都使用相同的 Linux 内核；它们使用相同的主机配置、文件系统拓扑、网络配置和用户角色。标准化所有因素有助于确保在集成中构建和测试的容器映像在生产中保持不变。

容器实例的运行时行为的某些方面会有所不同，比如访问其他相关服务的 URL，或者日志级别。使用各种选项将这些运行时配置传递给容器。一种选择是通过环境变量将运行时配置注入容器实例。环境变量可以指向服务注册中心，然后服务注册中心指向正确的依赖服务。像动物园管理员和 T2 顾问这样的工具有助于实现这种范式。

如果使用现有的配置管理和配置工具(如 Chef、Puppet 和 Ansible)对主机进行配置，那么应该尽可能为所有环境提供单一配置。对于横向扩展基础架构，考虑到可用性和性能要求，不同环境之间存在的有限差异是需要调配的实例数量。

主机还必须偶尔用最新的内核补丁、容器运行时版本等进行更新。，它不能密封在容器图像内部。这种主机配置的变化可以遵循滚动升级，滚动升级允许分阶段更新，而不是采取大爆炸的方法。

最后，与主机一样，需要类似的配置和拓扑来支持基础架构，例如所有环境的日志聚合、监控、指标、服务路由和发现。这允许容器映像具有一定程度的一致性，不仅与主机一致，而且与各自环境中的所有参与服务一致。

## 生产中容器的服务发现

标准化服务发现机制是容器化应用程序的一个重要考虑因素。很少会像在虚拟机上运行应用程序那样运行容器化的应用程序:在同一台主机上运行不止一个容器。在这种罕见的情况下，如果您使用桥接网络模式，您可能需要为每个容器分配一个静态端口。这意味着您预先选择主机上容器公开的端口，并使用它来配置负载平衡器和代理。

如果只是有限地需要向主机添加更多容器，则可能不需要重新配置负载平衡器和代理。然而，在大多数情况下，通过使用不可变的部署或伸缩实践，基于负载来添加或移除容器。在这种情况下，很难保持一组静态的预先分配的端口号，而这正是服务发现系统的优势所在。

## 生产支持:日志聚合和监控

生产中的集装箱所需的支持服务与非集装箱化的环境相同。这包括从容器实例中捕获日志并将它们发送到一个集中式日志管理系统的方法。Docker 守护进程中已经有了内置的日志后端支持，定制的解决方案可以解决这个问题。

管理由 [Docker](https://www.mirantis.com/software/docker/kubernetes/) 容器产生的日志数据有许多选项。Docker 的默认设置将未压缩的日志写入磁盘，并通过可选的保留设置来限制存储使用。在生产环境中，Docker 引擎附带了许多日志记录驱动程序，并为管理日志数据提供了灵活的选项，这些选项对于生成日志数据的应用程序来说是透明的。如果您已经有了一个集中的日志记录解决方案，那么可能有一个 Docker 日志记录驱动程序，它可以被配置为向它提供容器日志数据。各种已建立的协议都有日志记录驱动程序，如 [Syslog](https://docs.docker.com/engine/admin/logging/overview/) ，可用于许多摄取系统以及特定于云或 SaaS 的选项。

容器的短暂状态是容器日志记录和监控中需要注意的一个关键行为。在生产中进行部署时，新容器会替换旧容器。这打破了假设有状态和长期运行的计算单元的传统惯例。集装箱船队的轮换给传统的记录和监控思维带来了新的问题。容器可以在一个小时之内轮换，而不是让计算实例闲置几天或几个月。

容器的短暂状态是容器日志记录和监控中需要注意的一个关键行为。

如果您练习连续交付(CD)，这个窗口可能会更短。以主机为中心的日志记录和监控解决方案无法适应容器的复杂性。相反，由于它们的生命周期很短，所以需要一种声明式的方法来监控它们。而且最好是把它们作为一个群体来监控，而不是监控船队中的每一个集装箱。

关联组内容器的一种方法是使用适当的元数据，如标签。标签是指将在生产环境中运行的“图像标签”。建议在实现时避免对 Docker 容器使用被误解的“最新”标签。

例如，假设您部署了应用程序“product-api”的映像，映像标签为“25”，环境变量设置为“production”。这意味着这是构建系统识别的第 25 个映像，并且容器运行在生产环境中。在任何给定的时间点，您都可以在容器基础设施中运行多个这样的实例。标签将随着每个新的部署而改变，但是环境变量配置将保持设置为“生产”

让一个监视系统监视当前在环境变量设置为“production”的情况下运行的容器映像，会给人一种长期运行的生产服务的印象，与部署新版本时所做的连续更改相隔离。如果您正在使用编排工具，那么您可以使用更丰富的标记词汇表来对容器实例进行分组。

[cyclone slider id = " ebook-3-赞助商"]

对生产环境中的容器进行适当的监控和日志记录策略是一种非侵入性的解决方案，它可以脱离正在运行的容器，理想情况下作为“侧车”容器服务运行。容器监控工具需要知道容器，甚至知道容器平台。这种意识将有助于监控工具在报告故障时避免混淆，例如当容器在一个主机上停止并被容器平台移动到另一个主机时。容器覆盖区将导致监控和日志记录系统收集过多的数据，从而需要额外的数据管理。

集装箱监控是一个飞速发展的领域，我们将在今年晚些时候出版的第五本电子书中对此进行介绍。同时，有各种软件即服务(SaaS)和内部工具可以帮助您做出决策。

## 管理容器数据的方法

对于管理容器数据，普遍接受的建议是让无状态容器在生产环境中运行，这些容器自身不存储数据，纯粹是事务性的。无状态容器将处理过的数据存储在容器空间之外的外部，最好是存储到由可靠且可用的持久性后端支持的专用存储服务中。对于托管存储服务(如数据库、队列和缓存)的容器实例来说，这种安全性问题更加突出。对于这些有状态容器，公认的模式是使用数据容器。这些有状态服务的运行时引擎在运行时与数据容器链接。实际上，这意味着拥有一个在容器上运行的数据库引擎，但是使用一个“数据容器”作为卷来存储状态。

如果您正在运行一个使用编排平台的集群托管环境，那么拥有一个分布式存储解决方案就很重要，比如 [Gluster](https://www.gluster.org/) 和 [Ceph](http://ceph.com/ceph-storage/) ，以提供共享挂载点。如果容器实例根据可用性在集群中移动，这将非常有用。

## 容器安全和密钥管理

安全性通常是一个主要问题，尤其是在运行多个容器实例时，每个容器实例在一台共享机器上用于一个不同的租户。这种担心源于对容器技术将提供正确的隔离缺乏信任和信心，而这正是基于 VM 的实现所期望的。然而，将容器视为虚拟机的替代品无助于解决这一问题。容器实现，比如 Docker，为应用程序提供了一个安全毯。容器运行时抽象了在不同名称空间(如用户、网络和进程)上配置细粒度权限的复杂性。

如果考虑在共享基础设施上进行容器的多租户部署，则利用虚拟机来分隔每个租户，并将容器用作租户应用程序组件之间的隔离媒介。随着社区中的用户越来越多地部署容器，有必要避免虚拟机墙，让所有租户共享相同的基础设施。

运行不可变容器实例的另一个方面是避免烘焙任何需要保密的密钥或凭证。有多种方法可以解决这个问题，从通过环境变量传递秘密，到使用作为卷挂载的加密数据容器来保护它们。然而，在使用这些技术、[方面有](https://github.com/docker/docker/pull/9176#issuecomment-99542089)[的批评，并且容器运行时提供者没有](https://github.com/docker/docker/pull/9176#issuecomment-99542089)可用的标准。

## 集装箱生产的未来之路

在生产中成功采用容器的一个重要因素是拥有一个消息灵通、受过教育的社区。工具和实践将发展到运行容器成为大多数组织的标准的状态。在此之前，使这种采用发生的未完成的战斗存在于组织内部。让每个利益相关者，尤其是操作和安全团队，深刻理解他们对容器的需求是一项需要大量工作的任务。在生产中采用容器的途径将不同于虚拟机，除了资源利用的好处之外，还将优先考虑开发人员体验和操作简化。

<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 68 31" version="1.1"><title>Group</title> <desc>Created with Sketch.</desc></svg>