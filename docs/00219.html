<html>
<head>
<title>Iron.io Brings AWS Lambda In-House, Settles into Microcontainers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Iron.io将AWS Lambda引入内部，并融入微容器</h1>
<blockquote>原文：<a href="https://thenewstack.io/iron-io-brings-aws-lambda-compatibilities/#0001-01-01">https://thenewstack.io/iron-io-brings-aws-lambda-compatibilities/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">


<p class="translated"><img decoding="async" loading="lazy" class="alignright size-medium wp-image-1057159" src="../Images/54715fed2db10bc8159ad4d157ab92fe.png" alt="500x500_Iron_white_logo" data-id="1057159" data-original-src="https://thenewstack.io/wp-content/uploads/2016/02/500x500_Iron_white_logo-300x300.png"/></p>
<p class="translated">很少有技术像<a href="https://aws.amazon.com" class="ext-link" rel="external "> AWS Lambda </a>一样吸引了开发者社区的注意，因为越来越多的公司考虑为自己的服务提供无服务器架构的好处，也称为<a href="https://thenewstack.io/year-ahead-stateless-computing/" class="local-link">无状态计算</a>。</p>
<p class="translated"><a href="https://www.iron.io/" class="ext-link" rel="external "> Iron.io </a>的首席执行官查德·阿里穆拉(Chad Arimura)说:“Lambda帮助启动了对话，它在地上插了一根桩，并说‘这是我们看到的世界在架构和开发环境方面的发展方向’。”iron . io自2009年以来一直在运营一个事件驱动的无服务器基础，尽管该公司直到2011年才正式成立。</p>
<p class="translated">一段时间以来，Iron.io的客户一直要求能够在Iron.io上运行Lambda代码。现在，这个愿望将会实现。在接下来的几周里，Iron.io将发布更多关于一项名为IronLambda的新服务的信息，该服务将提供Lambda代码在任何地方运行的能力——甚至在AWS上。</p>
<p class="translated">Arimura指出，Iron.io的Lambda产品将采用一种扩展策略来实现协议、容器化功能、运行Lambda功能、导入到Iron.io中，并将在任何基础设施上运行，具有超过源代码的灵活性。</p>
<h2 class="translated">Iron.io和AWS Lambda</h2>
<p class="translated">最初，Iron.io吸引了一些企业对其架构的兴趣，这些企业希望拥抱无服务器计算，并将他们的整体应用程序分解为基于微服务的方法。正在考虑无服务器架构的企业希望能够控制他们的数据。虽然基于云的PaaS和SaaS平台通常被誉为数据存储的未来，但对于存储敏感私人信息的公司来说，拥有公共云或异地存储解决方案是不可行的。Iron.io打包了许多好处，以适应许多部署模型。</p>
<div id="attachment_1057156" class="wp-caption aligncenter"><a href="https://thenewstack.io/wp-content/uploads/2016/02/SpotBatchArchitectureAutomated.png" rel="attachment wp-att-1057156" class="local-link"><img aria-describedby="caption-attachment-1057156" decoding="async" loading="lazy" class="size-full wp-image-1057156" src="../Images/0a515d3e7802e312939ab8d04427e799.png" alt="AWS Lambda Automated Batch Architecture" data-original-src="https://thenewstack.io/wp-content/uploads/2016/02/SpotBatchArchitectureAutomated.png"/></a><p id="caption-attachment-1057156" class="wp-caption-text translated">自动批处理架构</p></div>
<p> </p>
<p class="translated">Iron.io Lambda的初始测试版将只支持异步Lambda调用。同步Lambda调用允许开发人员设置一个块，直到客户端在发起直接调用后收到来自服务的最终响应，而<a href="https://aws.amazon.com/articles/5496117154196801" class="ext-link" rel="external ">异步函数</a>会在请求发出后将控制传递回源代码。</p>
<p class="translated">“任何API网关或API的web应用程序都可以在Iron.io Lambda平台上启动异步调用。未来，我们将添加同步支持和路由器，在Iron.io堆栈上构建开箱即用的完整微服务，”Arimura说。</p>
<p> </p>
<div id="attachment_1057152" class="wp-caption aligncenter"><a href="https://thenewstack.io/wp-content/uploads/2016/02/Platform_Diagram_V5.png" rel="attachment wp-att-1057152" class="local-link"><img aria-describedby="caption-attachment-1057152" decoding="async" loading="lazy" class="size-large wp-image-1057152" src="../Images/c39148ab43ce878b37f1fef1869722d5.png" alt="Iron.io Platform Diagram" data-original-src="https://thenewstack.io/wp-content/uploads/2016/02/Platform_Diagram_V5-1024x718.png"/></a><p id="caption-attachment-1057152" class="wp-caption-text translated">Iron.io平台图</p></div>
<p class="translated">当处理各种用例时，一旦大规模部署服务，管理一个人的微服务基础架构很快就会变成一个复杂的网络。Iron.io试图通过在Iron.io平台上提供各种各样的<a href="https://www.iron.io/platform/ironmq/" class="ext-link" rel="external ">打包产品</a>来解决与拆分单一应用程序相关的常见痛点，该平台旨在解决在企业环境中运行服务时面临的诸多挑战。</p>
<p class="translated">除了即将发布的Iron.io Lambda之外，它还为客户提供了自己的<a href="https://www.iron.io/platform/ironworker/" class="ext-link" rel="external "> IronWorker </a>平台，为容器化应用程序和大规模部署应用程序提供简化的流程编排，具有高可用性、堆栈定制、服务隔离和跨多个API的webhooks，可支持各种应用程序。</p>
<div id="attachment_1057153" class="wp-caption aligncenter"><a href="https://thenewstack.io/wp-content/uploads/2016/02/img8026848776023278368.png" rel="attachment wp-att-1057153" class="local-link"><img aria-describedby="caption-attachment-1057153" decoding="async" loading="lazy" class="size-full wp-image-1057153" src="../Images/692fdeb076e4c9e6ad60577d59e84f42.png" alt="IronMQ Dashboard" data-original-src="https://thenewstack.io/wp-content/uploads/2016/02/img8026848776023278368.png"/></a><p id="caption-attachment-1057153" class="wp-caption-text translated">IronMQ仪表板</p></div>
<p class="translated">Arimura指出，许多企业都愿意转向基于微服务的架构，但他们并不总是知道如何将零碎的东西分割开来。“我们围绕数据和文件处理创建解决方案，如果企业在数据处理方面有特定的工作负载，我们可以创建它，或者提供实施合作伙伴来创建它，”他说。</p>
<p class="translated">Iron.io灵活的onboarding允许企业转向拥抱微服务，而不必面对开发完全容器化的应用解决方案的典型挑战。</p>
<p class="translated">几乎每个企业都有批处理过程。这些有相同的模式。我们通过为部署在Iron.io平台上的微服务架构提供支持，提供了一个固有的解决方案。与拥有引擎的其他组织不同，Iron.io还会给你汽车，这样你就可以开始驾驶了，”Arimura说。</p>
<p class="translated">Iron.io产品包括企业级仪表板、个人作业控制、表面分析、从容器监控分析的能力等等。用户可以一次启动大量的作业或容器化的服务，能够了解有多少作业失败、它们的内存消耗和整体CPU使用情况。</p>
<h2 class="translated">微容器的兴起</h2>
<p class="translated">对于面临将整体数据库耦合到基于微服务的设计的开发人员来说，提取数据可能是一项艰巨的任务。组织选择如何处理、提取和加载数据会对其总体运营成本产生重大影响。Iron.io通过使用<a href="https://docs.oracle.com/cd/E41507_01/epm91pbr3/eng/epm/penw/concept_UnderstandingETLinEPM-99113c.html" class="ext-link" rel="external "> ETL </a>(提取、转换、加载)连接器简化了这一过程。</p>
<p class="translated">众所周知，Iron.io一直在推动新兴的<a href="https://thenewstack.io/microcontainers-iron-ios-new-hack-shrink-docker-containers/" class="local-link">微容器</a>趋势，因为开发人员继续接受让他们基于容器的服务占用更少空间的概念。“Iron.io在2015年推出了超过10亿个容器。我们发现，对于非常大的容器，在服务器之间移动东西是低效的。大多数都塞满了微服务用不到的东西。你不需要巨大的容器，所以很多都在缩小，”有村说。</p>
<div id="attachment_1057154" class="wp-caption aligncenter"><a href="https://thenewstack.io/wp-content/uploads/2016/02/step5.png" rel="attachment wp-att-1057154" class="local-link"><img aria-describedby="caption-attachment-1057154" decoding="async" loading="lazy" class="size-full wp-image-1057154" src="../Images/2c93c904cb01f1c9d1954a2b0b073540.png" alt="Task Scheduler in Iron.io" data-original-src="https://thenewstack.io/wp-content/uploads/2016/02/step5.png"/></a><p id="caption-attachment-1057154" class="wp-caption-text translated">Iron.io中的任务调度器</p></div>
<p class="translated">开始时，开发人员通常用一种通用的方法来处理容器。其中一个有一套标准的Docker容器，通常被迫以特定的语言运行它们的堆栈，然后将它们的源代码放在上面。最终，这个解决方案变得臃肿不堪。Arimura注意到，使用容器的“标准”方式不是很精简，在许多情况下，根本不再是微容器解决方案。</p>
<p class="translated">因此，Arimura和Iron.io的团队开始了一个新的方向，允许他们的客户独立包含他们的员工。由于接受了这一新方向，Iron.io开发了微容器的概念，为用户提供了一套个性化的构建模块，允许他们构建自定义容器来支持自己的堆栈，而不管它在什么平台上运行。Arimura指出，这一概念的自然发展已经看到客户使用最初特定于Iron.io的容器进行项目，使用他们自己的容器来构建微服务。</p>
<p class="translated">Iron.io的目标是，如果一个团队可以打包一个项目，就可以在Iron.io平台上运行。因此，它们不仅仅是一个运行Docker容器甚至编排微服务的平台。他们希望为随时随地在全球范围内大规模部署容器做好准备。</p>
<p class="translated">专题图片:<a href="https://www.flickr.com/photos/nlireland/16618218853/" class="ext-link" rel="external ">机车场</a>，爱尔兰巴利纳莫尔，1959年，来自爱尔兰国家图书馆。</p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
<title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>
</div>
</div>    
</body>
</html>