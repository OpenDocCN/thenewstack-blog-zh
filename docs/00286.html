<html>
<head>
<title>CoreOS Offers Self-Hosting Kubernetes with New Tectonic Release</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CoreOS提供自托管Kubernetes与新的构造释放</h1>
<blockquote>原文：<a href="https://thenewstack.io/coreos-offers-self-hosting-kubernetes-new-tectonic-release/#0001-01-01">https://thenewstack.io/coreos-offers-self-hosting-kubernetes-new-tectonic-release/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">


<p class="translated">利用Kubernetes固有的管理容器化应用程序的能力，CoreOS已经更新了其商业Kubernetes发行版，称为“构造”,能够在不停机的情况下进行自我更新。</p>
<p class="translated">CoreOS首席技术官Brandon Philips在本周举行的公司<a href="https://tectonic.com/summit/" class="ext-link" rel="external ">构造峰会</a>的主题演讲中表示:“我们能够使用与监控我们的应用程序完全相同的API和功能来监控Kubernetes。”。"我们把这一切都连接到构造控制台，所以你有一个点击按钮部署."</p>
<p class="translated">飞利浦在随后的采访中说，迄今为止，与大地构造和Kubernetes的安装过程“非常痛苦”。"本质上，人们不得不对分布式系统进行手动升级."</p>
<p class="translated">安装通常包括进入多个节点，手动修改文件，或者至少编写一个执行这些任务的脚本，所有这些都需要一套不同于管理Kubernetes本身的应用程序的技能。</p>
<p class="translated">“理想情况下，掌握<strong> kubectl </strong>和其他工具来操作Kubernetes应该首先转化为安装Kubernetes的诀窍，并随着时间的推移保持其运行，”CoreOS关于自托管能力的博客文章指出。</p>
<p class="translated">“这就是为什么我们如此努力地向上游发展，以使这种自宿主技术成为可能，”飞利浦说。</p>
<p class="translated">飞利浦将这种自托管能力比作Linus Torvalds现在如何使用Linux来编译新版Linux。对于Linux的第一个版本，Torvalds必须使用<a href="http://minix.com.hk/" class="ext-link" rel="external "> minix </a>作为构建平台。但是在Linux稳定之后，他将他的编译器移植到Linux本身，以便从本质上直接在Linux上构建Linux。</p>
<p class="translated">Kubernetes本身可以确保，如果它管理的一个pod发生故障，它可以启动一个替换pod。在这个新的构造版本中，推出的是新版本的Kubernetes，它现在包装在一套豆荚中。structural利用了一个新的Kubernetes安装工具，名为<a href="http://kubernetes.io/docs/getting-started-guides/kubeadm/" class="ext-link" rel="external "> <strong> kubeadm </strong> </a>。</p>
<p class="translated">在典型的Kubernetes设置中，所有的控制节点都被设置为来自工作节点的一个想法。对于构造更新，在控制节点上留出一些额外的空间来设置构造的更新版本。一旦新版本开始运行，工作就会从每个组件切换到更新的组件，直到更新完成。Kubernetes本身<a href="https://coreos.com/blog/self-hosted-kubernetes.html" class="ext-link" rel="external ">管理</a>这个更新过程:</p>
<p class="translated"><iframe loading="lazy" title="Self-Hosted Kubernetes" src="https://www.youtube.com/embed/tXyV3IQ8-0k?feature=oembed" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="">视频</iframe></p>
<p> </p>
<p class="translated">该方法类似于CoreOS用于更新其Linux发行版的方法(<a href="https://thenewstack.io/self-driving-infrastructure-makes-internet-secure/" class="local-link">最近被重命名为Container Linux </a>)。因为structural是一个分布式应用程序，所以组件是按照特定的顺序更新的，通常是按照API服务器、调度器、代理，最后是kubelet的顺序。</p>
<p class="translated">CoreOS本身通过容器交付更新，通过管理控制台管理。</p>
<p class="translated">对于企业来说，CoreOS将在更新上线前为企业测试提供alpha和beta通道。如果更新引起混乱，有几种不同的方法可以回滚更新。Kubernetes数据存储，etcd，可以存储备份信息，可以恢复到以前的版本。该公司也有如何从各种故障状态中恢复的指南，例如当调度失败时。</p>
<p class="translated">Philips说，自动更新应该可以很好地适应大多数企业部署，因为大多数用户都是在constructive的基础上构建的，而不是修改constructive本身。</p>
<p class="translated">飞利浦表示，CoreOS不会是唯一一家提供自主Kubernetes的公司。飞利浦说，这项技术将包含在软件的未来版本中，因此其他发行版无疑也会使用这项技术。</p>
<p class="translated">CoreOS还宣布了<a href="https://github.com/coreos/dex" class="ext-link" rel="external "> Dex </a>的2.0版本，这是一个基于<a href="http://openid.net/connect/" class="ext-link" rel="external "> OpenID Connect </a>的认证提供商，OpenID Connect是一个广泛使用的认证协议，可用于通过加密令牌管理Kubernetes上的用户，将用户帐户链接回企业的轻量级目录访问协议(LDAP)目录。第二版允许Kubernetes用户在没有外部数据库的情况下运行Dex。Dex使用Kubernetes APIs来持久化标识数据。以前的版本需要外部数据库。</p>
<p class="translated">“我真的认为自动驾驶是未来的发展方向。这是我们都应该去的地方，”数字海洋工程经理约纳斯·贝吉乌斯在“大地构造峰会”上介绍新发布的“大地构造”时说。</p>
<p class="translated"><a href="https://tectonic.com/?_ga=1.162053372.1955225110.1481644180" class="ext-link" rel="external ">构造</a>现在最多10个节点免费。</p>
<p class="attribution translated">CoreOS是新堆栈的赞助商。</p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
<title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>

</div>
</div>    
</body>
</html>