<html>
<head>
<title>AI Programming: So Much Uncertainty</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">人工智能编程:如此多的不确定性</h1>
<blockquote>原文：<a href="https://thenewstack.io/ai-programming-much-uncertainty/#0001-01-01">https://thenewstack.io/ai-programming-much-uncertainty/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">


<p class="translated">谷歌研究总监彼得·诺维格上周在T2·奥莱利人工智能会议上发言时指出，要将人工智能整合到软件工程工作流程中，还需要做大量的工作和许多工具。</p>
<p class="translated">Norvig说，从根本上讲，人工智能软件与其他形式的广泛使用的软件有着本质的不同，他也是该领域最受欢迎的编程指导书籍<a href="https://www.amazon.com/gp/product/0136042597/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;tag=the0757-20&amp;camp=1789&amp;creative=9325&amp;linkCode=as2&amp;creativeASIN=0136042597&amp;linkId=148235cab82582e325d554f3041f4682" class="ext-link" rel="external ">的合著者【人工智能:现代方法</a>。</p>
<p class="translated">“看待传统编程模式的一种方式是将程序员视为微观管理者，他确切地告诉计算机如何一步一步地做某事，”他说。有了AI，我们应该更多的把程序员当做老师来看待，而不是微观管理者。</p>
<p class="translated">这将需要在编程方式上有很大的改变，并且需要容易编程的工具。从根本上说，人工智能编程主要是关于建模，而不是代码本身。</p>
<p class="translated">“我们花了40年时间开发工具来构建这些程序，以一种良好的方式处理文本，”他说，指的是代码编辑器中的颜色编码、智能感知、调试器和其他功能。“但现在我们正在创建模型，而不是文本，我们只是没有工具来处理这一点。我们需要重组这个行业。”</p>
<p class="translated">就像我们需要改变工具一样，我们也需要修改编程过程。然而，典型的调试方法可能不适用于人工智能。“当你遇到问题时，你给它更多的训练数据，它就开始收敛到更好的答案。但是病毒并没有消失。它只是被隐藏起来了，它可能会回来，”他说。“我们无法像传统调试一样，通过机器学习来消除错误。”</p>
<p class="translated">软件发布周期可能会改变。模型可以随时更新和改变。</p>
<h2 class="translated">你不能处理(概率)事实</h2>
<p class="translated">他解释说，对程序员来说，人工智能最重要的区别是，有许多围绕不确定性的问题。</p>
<p class="translated">“人工智能系统从根本上处理不确定性，而传统软件从根本上试图隐藏不确定性，”Norvig说。</p>
<p class="translated">传统的编程从根本上讲是关于二元选择的，真或假。你从你的支票账户中取出100美元，银行有数学上的确凿证据证明少了你100美元。但是人工智能驱动的程序可能更不符合事实。以一个检测银行欺诈的程序为例。</p>
<p class="translated">“这是一个根本不同的过程。你不能肯定地说‘这是欺诈’和‘这不是’。“我们只能从概率上说，”诺维格说。这是我们需要去发现的，而不是我们被给予的。"</p>
<p class="translated">或者举一个自动驾驶汽车的例子。基于ML的方法将通过在一定程度上应用刹车来减慢车辆。但是我们永远不知道人工智能程序的踏板会有多重。路况、刹车磨损和无数其他因素增加了一组不断变化的变量，这反过来又会在每次停车时稍微改变程序的响应。</p>
<p class="translated">“在人工智能系统中，我们希望不确定性通过模型传播，而在传统软件中，我们不希望如此，”Norvig说。</p>
<p class="translated">常规软件具有很强的组合性，然而所有的功能在一个和谐的整体中一起工作。人工智能编程不会传递单个不可变的变量，而是传递整个概率分布。</p>
<p class="translated">“我们可以做一个小小的改变——把这个语音识别模块换成另一个——这不再局限于程序文本中的那个组件。这是现在所有地方的控制流程，贯穿整个翻译过程，”他说。</p>
<p class="translated">“我们不习惯处理这种情况。我们没有表达这一点的工具，”他说。</p>
<h2 class="translated">可能是真的</h2>
<p class="translated">我们有选择，谷歌研究主管指出。</p>
<p class="translated">一个选择是云。亚马逊网络服务、<a href="https://console.bluemix.net/catalog/services/ibm-watson-machine-learning?env_id=ibm:yp:us-south" class="ext-link" rel="external ">、IBM </a>、<a href="https://azure.microsoft.com/en-us/services/machine-learning/" class="ext-link" rel="external ">、微软</a>、<a href="https://cloud.google.com/products/machine-learning/" class="ext-link" rel="external ">谷歌、</a>等等，提供人工智能驱动的服务，可以很容易地从应用程序中调用。例如，图像扫描服务可以接收你通过API发送的图像，并返回一系列可能的特征(位置、照片中每个人表现出的快乐程度等)。)在JSON里。结果可以很容易地被非人工智能程序的其余部分处理。</p>
<p class="translated">Norvig说，更棘手的是那些需要“通过其他步骤传播不确定性”的用例。在这里，您可能希望使用AI本身来充当看门人，以确定应该使用哪些组件。诺维格称之为“整体方法”</p>
<p class="translated">我们还可以开始考虑将大规模数据分析(也称为“大数据”)应用于编程本身。就像谷歌搜索可以对拼写错误的查询返回“你是指”提醒一样——使用过去的搜索来了解可能性——当开发人员编写了一行错误的代码时，人工智能驱动的程序员工具可以返回一系列建议。</p>
<p class="translated">最终，尽管我们也需要“用这种概率和不确定性的语言交谈”的编程语言，而不是用明确的布尔逻辑。这种概率语言将处理随机变量而不是固定变量，可以从其他值中推断出值。</p>
<p class="translated">“传统的程序只从输入流向输出，”他说。相比之下，使用概率编程，您可以要求程序根据接收到的输出来推断输入。</p>
<p class="translated">在某种程度上，一些问题最好通过让机器学习系统端到端地完成整个工作来解决。他指出，这已经在机器翻译中发生了。传统上，机器翻译系统由一系列概率统计模型组成。但现在“该领域已经认识到，通过端到端训练的神经网络，你可以在机器翻译系统中获得很大的改进，”Norvig说，</p>
<p class="translated">“我们会看到一些地方的答案是扔掉遗留的传统软件，而不是维护、包装或整合它，”他说。“不同的用例会有不同的解决方案，”他说。</p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
<title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>

</div>
</div>    
</body>
</html>