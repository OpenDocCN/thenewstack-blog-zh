<html>
<head>
<title>Microservices: It's All About the Events</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微服务:一切都与事件有关</h1>
<blockquote>原文：<a href="https://thenewstack.io/microservices-its-all-about-the-events/#0001-01-01">https://thenewstack.io/microservices-its-all-about-the-events/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">


<p class="translated">微服务似乎是今年在纽约举行的<a href="https://conferences.oreilly.com/software-architecture/" class="ext-link" rel="external ">O ' Reilly Software Architecture</a>大会的主要讨论话题，与会的开发人员和系统设计人员对如何将他们的整体遗留系统转变为更加灵活的微服务驱动系统感到好奇。</p>
<p class="translated">在周二的开幕主题演讲中，许多演讲者解释了微服务驱动的架构与我们之前认为的IT系统架构有何不同。关键外卖？都是关于事件的。</p>
<p class="translated">最初的Cloud Foundry软件的创建者<a href="https://twitter.com/crichardson" class="ext-link" rel="external "> Chris Richardson </a>解释道:“事件在架构的每一个层面都扮演着重要的角色。”<a href="http://chrisrichardson.net/learnmicroservices.html" class="ext-link" rel="external ">软件架构主题的著名作者</a>。</p>
<p class="translated"><a href="/category/microservices/" target="_blank">微服务</a>的想法是将大型的整体应用程序分解成更小的协调服务集，这样每个服务都可以被替换或扩展，而不需要改变整个整体。</p>
<p class="translated">他说，甚至当前的企业系统也是围绕事件驱动的。一家航空公司延误了航班，一家药店开了药方。已经安排了送货。有些事件是基于时间的:发票没有按时支付。事件允许独立的应用程序进行协作:事实上，一个应用程序中的任何状态变化都可以是一个事件，一个可以被另一个应用程序使用的事件。监控服务可以分析从另一个应用程序发出的事件流，检查以确保事件模式是正常的。</p>
<p class="translated">Richardson解释说，事件驱动设计是一种不用修改应用程序就能扩展它们的方法。</p>
<p class="translated">可以通过某种消息传递软件将事件从一个应用程序传递到另一个应用程序。理查森说，对于内部沟通，像Apache Kafka这样的企业消息代理可以完成这项工作。对于外部通信，需要一种基于HTTP的传输形式，比如<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API" class="ext-link" rel="external "> WebSockets </a>、<a href="https://thenewstack.io/wonderful-world-webhooks/" class="local-link"> Webhooks </a>，或者一种发布/订阅机制。</p>
<p class="translated">Pivotal高级技术总监、即将出版的新书<a href="https://www.manning.com/books/cloud-native" class="ext-link" rel="external "> Cloud Native </a>的作者Cornelia Davis 在她的主题演讲中指出，虽然最初，迁移到基于事件的架构听起来很容易，但它确实需要架构思维的某种转变。戴维斯说，微服务就其本质而言，是分布式计算的一种极端形式。</p>
<p class="translated">她指出，用于计算的传统服务器请求/响应模型来自命令式编程模型，尽管基于事件的模型实际上更像是函数式编程模型。“函数式编程模型对分布式系统非常非常有效，”她说。</p>
<p class="translated">传统的系统可能依赖于“重试”的概念，如果它最初没有从其他服务获得所有需要的材料。web服务器可能不会返回所请求的网页，直到所有不同的元素都就位，最慢的服务会阻碍最终的交付。然而，在本质上不可靠的分布式系统环境中，<a href="http://dist-prog-book.com/chapter/2/futures.html" class="ext-link" rel="external ">承诺</a>的抽象可能比重试更合适。各种组件生成它们自己的事件，这些事件通过事件或更改的序列化流填充Web服务器的物化视图。“你可以把承诺想象成事件处理者，”戴维斯说。她说，事件处理程序将“在我需要时”完成一个步骤。</p>
<p class="translated">“分布式系统的一个关键是，你有一大堆独立的控制回路负责它们自己的处理，”她说。这个领域中最受欢迎的概念之一是<a href="https://martinfowler.com/bliki/CQRS.html" class="ext-link" rel="external ">命令查询责任分离</a> (CQRS)，它将向数据存储中插入数据的通道与查询该数据的通道分开，因此一个通道的性能不依赖于另一个通道。</p>
<p class="translated">“事件可以触发功能，这是实现功能即服务的一种非常自然的方式，”她说。</p>
<p class="translated">这个观点在会议的其他地方得到了响应。<a href="https://twitter.com/ironfish" class="ext-link" rel="external "> Duncan DeVore </a>，<a href="https://twitter.com/Joab_Jackson/status/968608968179412992" class="ext-link" rel="external "> Lightbend </a>，<a href="https://twitter.com/Joab_Jackson/status/968608968179412992" class="ext-link" rel="external ">的软件工程师指出</a>有两种类型的系统交互:承诺和义务。“你想要承诺，而不是义务。义务转向不可预测的结果；承诺汇聚成明确的结果，”他说。</p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
<title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>

</div>
</div>    
</body>
</html>