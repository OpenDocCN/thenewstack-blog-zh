# 为什么调试不需要如此复杂或过时

> 原文：<https://thenewstack.io/why-debugging-doesnt-need-to-be-so-complex-or-outdated/>

[VMware](https://www.vmware.com/company.html) 赞助了这篇文章。

 [乔希·朗

Josh 是 VMWare 的 Spring 开发者倡导者，也是关于当前调试状态的 Java 拥护者。](https://twitter.com/starbuxman) 

在 Java 中，调试的状态相当糟糕。异步编程使得整个过程更加复杂。我们是 [Spring](https://spring.io/) 社区中反应式编程的大力支持者，因为它支持流量控制和尽可能快地将工作从线程上移走。编程模型不是 Node.JS 早期的嵌套回调。现在，语言提供了一种以命令式风格描述异步计算的语法。这是两个世界中最好的:资源高效的代码，带有命令式的简单性。有些语言，像 JavaScript、C#、Rust 和 Python，支持两个关键字:`async`和`await`。Kotlin 在这里值得特别一提，因为它通过一个单独的语法元素:`suspend`函数来支持协程。无论是反应式编程还是协同程序，结果都可能是复杂的执行图。

在这种环境下，开发者不再能够只见树木不见森林。我最常听到的是，“我怎样才能更好地支持调试？”开发者被好处说服了，却想不出怎么下手。调试工作流程不清晰。当然，您仍然可以在管道中放置断点，但是会更复杂一些。

如果你明白在引擎盖下发生了什么，调试就是第二天性。但是如果你已经远离了框架的深度(现在大多数软件开发人员都是这样)，调试就变得相当棘手。大多数人都很难将他们的心理模型与调试器显示给他们的内容对应起来。

在反应式世界中，你不抛出异常——你返回一个反应式类型并以那种方式处理事情。问题是，“这个异常最多包含一个异常线程:我如何在所有不同的线程中获得程序集跟踪”？我们可以做到这一点，但是(从运行时的角度来看)保存所有这些数据是很昂贵的。这是一个汇编跟踪，类似于堆栈跟踪，但跨越所有管道。

Spring 已经有 19 年的历史，并且在过去的三年里发布了最初的反应式支持——以 Spring Webflux 和其他地方的集成支持的形式。我希望每个人都在反应式编程中开始他们的新项目。

## **项目织机**

Project Loom 笼罩着我们，向我们承诺轻量级的 Java“绿色线程”——有点像 Go 中的 Goroutines。成千上万的线程通过时间片被调度到一个“真正的”线程中，而不会让你的计算机崩溃:太棒了！

然而，反应式编程和 Project Loom 之间存在矛盾。反应式编程要求您改变编写代码的方式，将函数调用链接在一起。作为交换，您的代码有更多的机会将正在使用的线程交还给运行时。这反过来意味着您可以在同一台计算机上处理更多的请求，从而获得更好的可伸缩性。在 Java 中，这需要对代码进行显式修改。在 Kotlin 中，通过它的协程支持，您可以获得一个非常好的语法来表达异步计算，同时仍然编写看起来像同步的代码。

日程表里有什么？相当多。能够切换一个布尔值，现在我的 web 服务器可以处理数万个线程？太棒了。但是它没有解决控制流问题。

我们正走向一个世界，在那里你可以进行反应式编程(coroutines & Kotlin)，或者 Project Loom 和 green threads，或者——希望——两者都有！

当然，旧的又是新的。Java 的第一个版本有自己的调度程序——它有绿色线程——但是它引入了相当大的复杂性，并且扼杀了移植到不同操作系统的能力。程序员说:“去它的，摩尔定律还是个东西。与此同时，我们可以增加更多的内存和 CPU。”

现在，20 多年后，我们又回到了这里。Java 正在回归绿色线程。

在 Go 中，你会得到这些超级便宜、轻量级的绿色线程。折衷的办法是，如果你想从中受益，你有一个并发范例:Go 例程。如果你愿意用这些 API 来表达你的算法，那么你可以免费得到成千上万的线程。

Java 线程是一个不透明的盒子，如果你只是在里面放些东西，你就可以运行系统，并且可以假装你的新线程给了你一台属于你自己的计算机。它不会强迫开发人员改变他们编写代码的方式。

JVM 开发人员采取了不同的方法:如果我们引入一个绿色调度程序会怎么样？然后重写所有输入输出的东西来提供钩子，看看我们什么时候阻塞了？目标是维护合同。当然，这只适用于 JDK 团队更新的代码。你做一个阻塞读，它会让给另一个线程。它将以异步读取结束。

## **未来**

如果你知道有新的东西即将出现，为什么你今天还要全力以赴去开发 GraalVM(Java JIT 的替代品和超前的编译器)？事实上，GraalVM 已经存在。Twitter 正在使用 GraalVM 作为 JIT，但不是原生映像编译。

这并不是说有替代方案，因为替代方案就是现状。随着我们进入这个容器化的世界，将更多的微服务装入容器，GraalVM 是一件大事。希望将 GraalVM 的想法融入标准 JDK 的雷登项目也是一笔大交易。

另一个令人兴奋的事情可能来自甲骨文:巴拿马计划，与织机同时宣布。像 JNI，但更好。想象一下 GraalVM 原生映像与内核对话，并拥有数万个原生线程。现在，我们开始消除原生代码的一些好处，同时仍然为 JVM 编写代码。

## **把线拉在一起**

为了应对这个日益复杂的世界，我们构建了 Spring 元素来提前编译。我们有一个本地图像功能。GraalVM 需要被预先警告任何“有趣的事情”——任何东西的任何动态加载——任何动态代理、任何 URL 资源加载、任何折射等等。所有这些都是编译器需要提前了解的。

您需要为本机映像编译器捕获所有这些信息；这项工作不适合胆小的人。

在线程的回归和开发人员从支撑这些线程的框架中的指数级抽象之间，Java 中的调试过程只会变得更加复杂。因此，我预测我们将会看到更多的公司开始采用提供实时[软件故障回放](https://undo.io/solutions/products/software-failure-replay/#:~:text=Software%20Failure%20Replay%20(SFR)%20is,diagnose%20and%20resolve%20software%20failures.)技术的解决方案。这个世界没有慢下来——它只是在加速——世界上根本没有足够多的超人开发者来跟上。如果不能看到开发和生产中的整个执行过程，软件故障或正在发生的故障只会越积越多。

通过 Pixabay 的特征图像。

<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 68 31" version="1.1"><title>Group</title> <desc>Created with Sketch.</desc></svg>