# GraphQL 优化:不止 N+1

> 原文：<https://thenewstack.io/graphql-optimization-its-more-than-n1/>

GraphQL 的引入是为了方便前端开发人员访问后端数据。它为前端开发人员提供了简化应用程序数据规范所需的范例。在 GraphQL 中，开发人员声明性地指定他们想要什么数据，而不是如何获得它。作为数据库领域的专家，随着关系数据库的兴起和对象关系扩展的出现，我们 StepZen 疯狂地专注于将从我们的遗产中学到的经验带到现代世界。

## 为什么要优化？

 [鲍比·科克伦

Bobbie 是一位经验丰富的高级研究科学家，拥有在信息技术和服务行业工作的丰富经验。她是一名优秀的研究专家，精通区块链、可伸缩性、IBM DB2、云、计算机科学和企业软件。](https://www.linkedin.com/in/bobbiecochrane/) 

除了数据访问的优化是我们 DNA 的核心之外，GraphQL 的优化对于打开快速前端开发的窗口也很重要。对于 GraphQL 操作来说，最明显的优化机会是最大限度地减少对后端数据源的访问，无论它们是数据库、REST APIs 还是其他 GraphQL APIs。

虽然 GraphQL 使开发人员更容易指定他们想要的数据，并在一定程度上给予他们来自后端所有者的自主权，但这些后端很可能在另一个开发人员、DBA 和/或组织的控制之下，他们会关心将被引入他们后端的任何外来负载。

减少后端流量还可以:

*   通过减少对按调用计费的后端系统的调用次数来降低成本。
*   避免后端的费率限制。
*   通过减少 GraphQL 端点的延迟来提高应用程序性能。

后端垃圾邮件通常被称为 N+1 问题，当应用程序发出 N 个请求而不是 1 个请求来检索对象的细节或其子实体时。

正如我们将要解释的，GraphQL 模式为高性能的 GraphQL 服务器提供了避免垃圾邮件所需的上下文，但它也提供了许多其他机会来减少后端系统请求的数量，因此它大于 N+1。

## N+1 问题

 [丹·德布鲁纳

Dan 是 StepZen 的一名软件工程师，也是 IBM 数据管理部门的高级技术人员(STSM)和 Cloudscape 数据库引擎的架构师。Dan 带领 Cloudscape 从一家初创公司发展到部署在 IBM 的产品和中间件中，最终 IBM 在 2004 年将 Cloudscape 代码作为 Derby 贡献给 Apache。](https://www.linkedin.com/in/dan-debrunner-1025287/) 

前端应用程序通常会导致对单个后端的一系列独立请求，该后端反复检索应用程序数据。例如，一个应用程序可以在一个 REST API 请求中接收一个作者列表，但也可以独立地、反复地发出进一步的请求，有时是对同一个端点，有时是对不同的端点，以检索显示作者姓名、地址和评级所需的信息。

这是由对象/关系映射器引入的著名的 N+1 数据库性能反模式的变体。在为开发人员简化数据访问的同时，O/R mappers 也鼓励了一种用大量零碎的请求向数据库发送垃圾邮件的模式。天真的实现会在程序员调用时对后端执行查询，但幸运的是，O/R 映射引擎提出了几种策略来减轻这种模式。

对于 web APIs，这个问题变得更加模糊，因为原始端点不会在一次调用中返回应用程序需要的信息，并且应用程序的不同部分可能需要不同的数据片。随着性能问题的出现，开发人员可能能够分析他们的数据访问并整合后端调用，但他们可能还需要请求不同的端点来这样做，然后说服后端开发人员来提供它。GraphQL 缓解了前端和后端开发人员之间的紧张关系，允许开发人员从单个端点请求他们需要的所有数据。然后，GraphQL 服务器的工作就是识别模式并避免后端垃圾邮件。

## 多于 N+1

而大多数 N+1 解决方案的中心是减少对给定实体填写详细数据(作者姓名、评级等)的多次请求。)，或者检索给定实体的所有子对象(比如一个作者所有书籍的书籍细节)，提出一个请求而不是许多请求的一般原则可以应用得更广泛。

GraphQL 操作(对 GraphQL 端点的请求)表达了前端开发人员需要什么，而不是如何获得它，并被表达为字段的**选择集**，通常带有子选择。

选择集可以任意深和任意宽，这允许前端开发人员从 GraphQL 端点的单个请求中获取所需的数据类型。

深度是返回对象的嵌套深度。例如，考虑下面的模式:

```
type  Author  {
 id:  ID!
 name:  String
 genre:  String
 publisher:  String
 rating:  Float
 books:  [Book]
}

type  Book  {
 id:ID!
 title:  String
 auth_id:  ID
}
type  Query  {
 author(id:  ID!):  Author
}

```

以下选择集的深度为三:

```
{author(id:1)  {  name  books  {  title}}

```

有时深度会受到模式的限制，我们当前的模式就是这种情况。

然而，GraphQL 模式仍然可以非常深入，并且经常是递归的。考虑关于作者的数据可能包括相似作者的列表。这可以通过如下扩展我们上面的模式来实现:

```
extend  type  Author  {
 similar:  [Author]
}

```

这样的模式会导致任意深度的选择集。从这个模式中可以看到的优化机会是，当在数据的遍历中已经检索到一个相似的作者时，要进行识别。以这种方式进行优化还有助于识别数据中的循环，并避免不必要的深度嵌套遍历。

宽度是在选择树中给定深度选择的字段数量。宽度不受模式限制，但由于别名的原因，可能会出现在选择中。在这个简单的例子中，名称级别的宽度是三，同一个字段使用别名选择了三次:

```
{  author(id:1)  {  n1:name n2:name n3:name}}

```

顶层的宽度是实现前端开发人员发出一个请求来获取所需数据的目标的一个关键特性，它导致任意宽的操作。例如，考虑显示一个页面的数据，该页面除了当前最畅销书籍的促销和本地书籍签名之外，还包含用户最喜欢的作者的信息:

```
{
 a1:  author(id:1)  {  name birthplace email}
 a2:  author(id:2)  {  name birthplace email}
 topSellingBooks  {  title  }
 authorsOnTour(zip:”94118”)  {  name birthplace email}
}

```

在此选择中可以看到一些优化机会:

*   获取作者信息是对后端的单个请求还是多个请求？
*   如果 authorsOnTour 返回 authors one 和/或 two，那么对于 a1 或 a2 的执行是否可以重用 authorsOnTour 的作品？

对于通常可能由独立代码模块生成的请求，应用程序可以发出具有重复或近似重复项目的请求。例如，在选择 20 多个顶级字段的操作中，可能会有类似的项目，例如:

```
{
<  other fields  >
<strong>  author_for_popup:  author(id:1)  {  name genre publisher  }</strong>
<  other fields  >
<strong>  main_author:  author(id:1)  {  name  books  {  title  }  }</strong>
<  other fields  >
}

```

graph QL 服务器能否发现这些问题，从而有效地执行对应于
的单个后端请求

```
author(id:1)  {  name  genre  publisher  books  {title  }}

```

选择集的深度和宽度是任意的，现在您可以看到，GraphQL 优化机会可以存在于操作中的整个选择树中，而不仅仅是填充下一级实体的详细信息，包括顶级字段(或任何级别的字段)。

前端开发人员不应该关心这些优化。他们请求他们需要的数据，以他们需要的形式，可能有副本，并期望正确的结果。

GraphQL 服务器可以以任何方式执行查询，只要它能产生正确的结果。就像早期的 SQL 一样，如果执行查询的运行时没有利用它所拥有的上下文来有效地运行查询，那么声明性查询的性能仍然会很差。

StepZen 的声明性方法提供了这种上下文，比如字段与后端的关系以及它们的类型(比如数据库或 GraphQL)和功能。

## 优化技术

使用声明性方法，GraphQL 服务器可以使用其对传入操作、操作变量、模式以及字段与后端的关系的了解来分析和优化请求，从而减少前端的操作延迟。

充分理解请求后，可以使用如下技术来减少操作的后端请求数量。与关系优化一样，这些技术可以组合使用，但每种技术都要单独描述。

## 重复数据删除

顾名思义，这种技术从 GraphQL 服务器层删除了对后端的重复请求。在这个简单的例子中，考虑下面的重复操作:

```
{
 a1:  author(id:1)  {  name  }
 a2:  author(id:2)  {  name  }
 a3:  author(id:1)  {  name  }
}

```

在这种情况下，我们可以消除对后端 a3 的请求，因为我们已经从对 a1 的请求中获得了该数据。虽然这通常不会发生在最顶层的选择层，但当查询从多个后端提取数据时，这种情况会经常发生。在这些情况下，来自一个后端的请求通常会产生形成对另一个后端的请求所需的参数。第一个请求的结果可能包含重复项，我们可以通过为每个惟一值发出一个请求来减少对第二个后端的调用，然后在结果中适当地分布结果。

考虑一个 GraphQL 服务器，它将来自 Postgres 数据库(图书后端)的图书信息与来自 REST API(作者后端)的作者详细信息以及下面的查询进行合并:

```
{
 books(topic:"cookbooks")  {title  author  {  name  }}
}

```

为了解决上述查询，GraphQL 服务器将首先向 books 后端发出请求，以获取所有 cookbooks 的标题和作者 auth_id。因为一本食谱的作者可能写了不止一本，所以他们的 ID 将从第一次请求开始出现多次。然后，引擎必须向作者后端发出后续请求，以获取作者的姓名。如果 100 本烹饪书只有 20 个作者，重复数据删除将向作者后端发出 20 个(每个唯一作者一个)而不是 100 个请求。

## 再用

重用通过重用以前的结果来避免后端请求。在这种情况下，我们没有预先知道的后端请求的集合，但是当我们发出请求时，我们可能会意识到我们已经有了所需的数据。

考虑下面的查询:

```
{
  huxley:  authors(name:"Huxley")
      {  books  {  title  }  similar  {name  books  {  title  }}
  orwell:  authors(name:"Orwell")
      {  books  {  title  }  similar  {name  books  {  title  }}
}

```

很可能`Huxley`和`Orwell`都在对方的`similar`列表中。如果我们已经从图书后端检索了赫胥黎的图书信息，那么当我们遇到作为奥威尔的`similar`列表的一部分再次检索该信息的请求时，我们可以重用我们已经拥有的数据。

这种技术也有助于非常深入的查询，这种查询可能是由于递归模式而发生的，因为它检测数据中的循环。例如，想要获得五个相似度的查询不会重复请求相同的作者，而是在填写结果时重用该信息。

```
{
 authors(name:  “Huxley”)
      {  similar  {  name
 similar  {  name
            similar  {  name
 similar  {name
                  similar  {name}}}}}}
}

```

虽然重用和重复数据删除都避免了对同一数据的多次请求，但重用与重复数据删除的不同之处在于重复发生在树的不同级别。重用必须从以前的请求中找到工作，其中重复数据删除当时知道它正在提供结果的多个部分。

因此，在我们的示例中，重复数据删除会将对 id:100 的三个请求合并成一个后端请求，并使用它来填充三个实例，但是通过重用，稍后对 id:100 的请求会找到之前执行的请求的结果，并使用它来填充其实例。

重复数据删除和重复使用还有一个额外的优势，即它们可以提供一致的结果。由于相同标识符的结果会在整个查询中重复使用，因此后续执行不会返回不同的结果。例如，如果没有重复数据删除和重用，作者的评级可能在结果的一部分显示为 3.4，而在另一部分显示为 3.7。

## 贮藏

缓存保存经常需要的数据的本地副本，以避免昂贵的检索和重新计算。在 GraphQL 服务器中，我们可以在许多不同的级别应用缓存:

*   后端请求:对给定后端请求的响应，比如 HTTP 请求和数据库查询。
*   GraphQL 字段:模式上下文中的响应，例如缓存查询选择字段的响应，该字段可以将来自多个后端的数据集合在一起，这样就可以避免在将来的请求中重新构建相同的选择字段。
*   GraphQL 操作:对整个选择集、操作文本和变量的响应，因为应用程序倾向于发送相同的操作集。

缓存减少了后端的负载，同时减少了前端的延迟。它类似于重用，只是缓存的数据将跨请求，并且随之而来的是必须处理的其他场景，例如当源数据被修改时缓存的结果失效，以及当本地存储已满时驱逐缓存的项。幸运的是，缓存已经存在很长时间了，在硬件和软件堆栈中有许多我们可以利用的众所周知的技术。

## 字段预取

另一种众所周知的技术，预取，在预期未来需要时检索额外的数据。在 GraphQL 中，如果我们识别出这些字段随后被请求的模式，我们可以将字段添加到选择中。

例如，对于一个查询`{author { name birthplace }}`，后端请求被扩充以包括`Author type`的其他字段，比如`email`、`birth`、`death`。然后，当未来的查询请求`email`(或任何其他返回的字段)时，可以使用缓存，而不是从后端请求。

例如，在数据库中，不是执行最小的

```
SELECT name,  birthplace
FROM authors
WHERE name  =  “Greene”

```

该查询改为还返回邮件，出生和死亡:

```
SELECT id,  name,  birthplace,  email,  birth,  death
FROM authors
WHERE name  =  “Greene”

```

重复数据消除、重用、缓存和预取是完全由 GraphQL 服务器封装的技术，因此可以应用于任何后端，无需任何额外的支持。相比之下，我们认为还有另外两种优化需要后端的额外访问模式。幸运的是，这些访问模式非常常见。

## 定量

批处理是将多个单独的后端请求(通常在重复数据消除之后)作为单个请求发送到后端的能力。考虑以下查询:

```
{
 greene:  authors(name:"Greene")  {  name birthplace email}
 huxley:  authors(name:"Huxley")  {  name birthplace email}
 orwell:  authors(name:"Orwell")  {  name birthplace email}
}

```

单个后端请求同时返回所有三个作者的详细信息会将多个请求(在本例中为两个)保存到同一个后端。为了利用这种优化，后端必须能够支持多值参数。幸运的是，这种类型的功能对于 SQL 查询、REST 调用和 GraphQL 端点来说相当简单，如下例所示。

**SQL 数据库**:用于定义 API 为单个作者返回信息的 SQL 可以很容易地重写为使用 IN 列表、临时连接表，或者更不优雅地在同一个客户端请求中提交多个 SQL 语句。

**REST 调用**:REST API 可以通过简单地重复查询参数来支持多值参数，例如`/authors?name=Greene&name=Huxley&name=Orwell`，或者通过提供一个不同的端点来接受 POST 正文中的名称列表，而不是路径元素`author/<name>`。

**GraphQL 终结点:**对于 GraphQL，我们可以简单地在操作中包含多个顶级字段选择，例如:

```
{
 batch001:  authors(name:”Greene”)  {  name birthplace email  }
 batch002:  authors(name:”Huxley”)  {  name birthplace email  }
 batch003:  authors(name:”Orwell”)  {name birthplace email  }
}

```

对后端的一个不太明显的要求是，对扩展请求的响应必须保留从请求的对象到它们的结果的映射，这样 GraphQL 服务器就可以将返回的结果与请求参数相关联。在我们的示例中，我们在结果类型中返回名称，因为结果需要将返回的图书列表映射到其关联的作者，然后 GraphQL 服务器可以使用该映射来构建其结果。

在 SQL 中，这很容易，因为可以将请求参数添加到结果中返回的行中，但这在其他 API 中可能不容易实现。例如，一些 weather REST APIs 被传递一个 lat/long，但是返回气象站或网格点的 lat/long，而不是输入 lat/long。为了支持 XML 和 JSON 中的聚合而引入的这种响应是有优先级的。

## 结合

顾名思义，组合将来自不同级别的请求合并到一个来自后端的请求中。这要求 GraphQL 服务器了解哪些请求来自同一个后端，并且可以组合成一个请求。

在我们的运行示例中，考虑如何解析`Author`类型的`books`字段:

```
type  Author  {
 …
 books:  [Book]
      @materializer(
 query:  “bookByAuthor”
 arguments:  [{name:  auth_id”,  field:  “id”}]
}

```

@ materializer 指令告诉我们，给定作者的书籍是满足 booksByAuthor 查询的书籍，查询的 auth_id 与作者的 id 相匹配。

GraphQL 操作—

```
{
author(id:  1)  {id  name  books  {title}}
}

```

——首先从作者后端请求`id`和`name`，然后从图书后端请求带有给定`auth_id`的`books`，这样就很简单了。如果两个后端都是数据库，这将导致下面的数据库查询序列:

```
1.  SELECT name,  id FROM authors WHERE id=1
2.  SELECT title FROM books WHERE auth_id  =  1

```

如果这两个后端来自同一个数据库，那么我们可以将这两个请求合并成一个:

```
SELECT  A.name,  B.title
FROM authors  A,  books  B
 WHERE  A.id  =  1  AND  B.author_id  =  A.id

```

虽然这种组合请求在 SQL 数据库中很容易实现，并且可以被一些 REST API 支持，但是它并不被所有的 REST API 支持，必须仔细考虑。例如，获取 Twitter 用户的固定推文及其详细信息是可能的，但其他 API 将需要额外的端点。

类似于批处理，当这样的请求被组合时，GraphQL 服务器需要能够将响应解包到所需的对象字段结构中。

## 结论

GraphQL 引入了一个声明性数据层，有望加速前端的开发。就像关系数据库将逻辑模式从物理模式中分离出来，为数据独立性和访问优化开辟了一个新的天地，GraphQL 在前端数据消费和后端数据检索之间提供了数据独立性。

这种能力允许 GraphQL 引擎对整个应用程序的数据需求有一个全面的了解，这个应用程序可能是由多个程序员随着时间的推移共同开发的。

我们已经确定了一些优化 GraphQL 的机会，并提出了一些在应用程序使用 GraphQL 时最小化后端请求的技术。这些技术的变体先前已经在整个硬件和软件栈中使用。虽然一些建议的技术可以通过定制的解析器有效地实现，但是这种方法将受限于它可以优化的程度，因为它不能完全了解数据模型。

在 StepZen，我们正在添加一种独特的、声明性的方式来构建和运行访问 REST、数据库和 GraphQL 后端的 GraphQL APIs。模式定义语言(SDL)的这种声明性方法为我们提供了更多的上下文，例如字段与后端的关系、它们的类型和功能。这种可见性增加了优化的机会。此外，我们可以在后台实现这些优化，而不会增加模式开发人员或后端服务的负担。模式开发人员只需描述数据和链接，剩下的就交给我们了。

我们只是触及了 GraphQL 提供的潜在优化和数据独立性的皮毛。正如 SQL 优化从灵活的索引定义、简单的谓词下推、基于成本的连接优化和查询重写引擎发展而来，我们相信 GraphQL 优化将随着数据独立性层提供的需求和机会而发展。

<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 68 31" version="1.1"><title>Group</title> <desc>Created with Sketch.</desc></svg>