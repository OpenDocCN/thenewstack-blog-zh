# 当你发现一只几十年前的虫子时会发生什么？

> 原文：<https://thenewstack.io/what-happens-when-you-find-a-decades-old-bug/>

据说 90%的编程都是在调试(另外 10%必须包括编写那些 bug)。但人们往往没有说的是，一些 bug 提供了一个受欢迎的挑战——在一个开放的过程中，这些谜团让我们敢于揭开看似不可能的事情，如果不是娱乐，也可以是教育。这是一个探索我们的代码及其支持工具的最深层工作的机会，同时解决一个现代的谜题。在这条路的尽头:吹牛的权利。

这个月，两位勇敢的探险家分享了他们自己的故事…

[J .保罗·里德](https://github.com/preed)，网飞大学的一名[高级应用弹性工程师](https://www.linkedin.com/in/preed)，里德最近挖掘了他在`cron`中偶然发现的一个潜在的几十年的不一致性，这是一个古老的 Unix 守护进程，它在预定的时间运行命令。Reed 在 Twitter 上指出，使用 cron，作业应该运行的时间可以用数字来指定，但也可以用符号名称(如“Wed”或“Feb”)来代替数字，并补充说许多程序员也使用列表和范围。(“例如，要在工作日运行作业，请输入 1-5。”)

但是突然有一天，里德发现了一个潜在的问题。根据其[手册页](https://en.wikipedia.org/wiki/Man_page)，范围和名称列表“是不允许的”

这惊恐的芦苇。“如果你的 crontab 条目中有‘周一至周五’或‘一月、四月、七月、十月’的，请举手。啊……我也是。”

有可能他违反协议的 cronjobs 实际上并没有运行。也许他们不会真的跑。不，那不可能是对的。他们中的一些人已经生成了电子邮件。里德已经看到了…

这需要调查…

首先，一些测试。Reed 使用工作日名称的列表和范围创建 cronjobs，然后“每天早上焦急地等待，看 cronjob 是否运行。”他们做到了。整整一周，电子邮件纷至沓来。因此，有了一个可靠的完整性检查，他就可以阅读实际处理来自 crontabs 的指令解析的源代码——对于 Reed 来说是 cronie 包中的`load_entry()`函数[(在 Red Hat 系统中使用)。](https://github.com/cronie-crond/cronie/blob/master/src/entry.c#L248-L264)

他发现，甚至在其`get_number()`子例程中，代码也是为解析包含月份名称和工作日名称的字符串而设计的。甚至有一个评论明确地说了同样的话。

/*没有数字，如果有字符串，请查找*/

Reed 甚至更深入地研究了 cron 代码的起源，它是在 2007 年从 vixie-cron 4.1 中派生出来的…

但是它的手册页仍然带有同样的警告——不允许范围和名称列表——即使它的代码似乎仍然支持带有月份和工作日名称的范围和列表。他很难找到任何比它更老的版本。

但是故事发生了有趣的转折，Reed 联系了互联网先驱 [Paul Vixie](https://www.linkedin.com/in/paulvixie) ，他不仅创建了 vixie-cron，还创建了[其他几个著名的 UNIX 程序](https://icannwiki.org/Paul_Vixie)，包括 SENDS、proxynet 和 rtty。

Vixie 在 Twitter 上直接回应说，早期版本的源代码已经在在线新闻组 comp.unix.sources 中共享。

早在 20 世纪 90 年代初，vixie-cron 的 2.0 版本就已经发布到了新闻组上——三个文件必须拼接成一个。但即使在那时，里德发现，其手册页仍然坚持认为，范围或名单的名字“是不允许的。”然而，这个更老的代码仍然包含名为`get_list()`和`get_range()`的子程序，甚至在`get_number()`中也隐藏了一个类似的注释。

/*尝试在名称列表中查找名称*/

里德的结论？甚至在 vixie-cron 2.0 版本中，也支持名称列表和范围。

除了再次在 Twitter 上 ping Paul Vixie，并问他为什么手册页说代码明确支持这些范围，而这些范围是不允许的。这一切导致了一个胜利和高潮的时刻，维谢的回答用 22 个简单的词驱散了整个神秘。“哦，我起初不支持范围或名称列表。

“当我修复代码时，我没有修复手册页。”

## 20 世纪 90 年代的一个 Linux 漏洞

同一个月，希腊比较购物引擎 Skroutz 的首席信息官 Apollon Oikonomopoulos 讲述了发现一个更加难以捉摸的漏洞的故事。在公司的工程博客上，Oikonomopoulos 描述了其(匿名化)生产数据的快照是如何转移到开发环境中的，开发环境会创建自己的可写快照。有一个 600GB 的 MariaDB 实例和一个 200 GB 的 MongoDB 实例保存这些数据。Oikonomopoulos 写道:“这种设置在十年的大部分时间里都运行得相当好，并成功地从 15 名开发人员扩展到 150 名。”

只有一个问题。“有时，来自源服务器的 [rsync](https://linux.die.net/man/1/rsync) 传输会在没有明显原因的情况下无限期挂起。”

他们无法重现这个问题——尽管增加了一个速率限制使其发生的频率降低了，“频率从每周一两次到每三个月一次不等。”但当它开始每天发生时，就该进行彻底的调查了。

在检查了他们的网络接口控制器，并在挂起的进程上使用了 strace 和 gdb 等调试工具之后，调试团队发现了 ss 实用程序的第一个线索(用于调查套接字):数据接收进程似乎已经消耗了所有传入的数据，尽管数据发送进程显示有更多的数据正在排队等待发送。最终，他们决定研究 Linux 内核如何处理 TCP 流控制——传入数据包如何获得它们的标识序列号以及它们的接收如何被确认的具体细节。

不幸的是，这些变量的实际实时值被深锁在内核的内部状态中——也就是说，不向用户公开——所以他们求助于 [SystemTap](https://sourceware.org/systemtap/) 工具/脚本语言。使用它来转储有问题的 TCP 连接的内部状态，他们发现了其中一个变量的问题。

有一个内置的检查来防止重新接收之前已经发送的数据。但是在 TCP 中，传入数据段的数字是简单的整数，并且具有固定的大小——这意味着它们最终将达到其可能的最高值，并从可能的最低值重新开始(就像里程表从 9999 翻转到 00000)。这是可以预见的；有一个子程序可以准确地比较两个序列号，即使其中一个已经“回绕”但它似乎偶尔会失败。

Oikonomopoulos 把他学到的东西带给了 Linux 内核的维护者——具体地说，就是在 Kernel.org 的网络开发邮件列表中的[。显然，TCP 代码有一个单独的“批量接收方快速路径”,该路径针对批量数据进行了优化，而这个 bug 已经潜伏了这么多年。一位维护者估计，这个漏洞自 1996 年 11 月发布的 Linux 2.1.8 以来就一直存在。来自 Oikonomopoulos 的信息足以让内核维护人员在两小时内快速创建一个补丁，一周后 Oikonomopoulos 回来分享他的成果。“差不多一周了，我们在 60 次 rsync 运行中没有出现挂起，所以我想我们可以称之为修复。](https://lore.kernel.org/netdev/87eelz4abk.fsf@marvin.dmesg.gr/T/#u)

"同时，我们没有发现任何不良副作用."

他还与内核维护者分享了他的想法，为什么这么多年过去了，这个 bug 仍然没有被发现。它是由 rsync 的异步协议的特性触发的，并且也很可能只发生在高容量和“稳定、长时间运行、低速或中速 TCP 连接的本地网络中，在这些网络中数据包丢失是最小的。”最后，这个错误很可能被误认为是一个常规的网络故障——一个普通的连接丢失——通过重新连接很容易解决。

Oikonomopoulos 在邮件列表中写道:“万一你的应用程序永远停留在持久状态，绕过你的无知，确定这可能确实是一个内核错误，并追踪它，这肯定需要相当多的烦恼。”

但是他在他公司的工程博客上添加了一个新的想法。“当你这样做时，你将获得一次美妙的冒险，在那里你将了解互联网协议的历史，一瞥内核内部，并见证开放源码工作的进展！”

* * *

# WebReduce

特征图片:第一个漏洞，发现于 1945 年，当时格蕾丝·赫柏在哈佛大学(海军水面作战中心)的马克 2 号计算机上工作

<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 68 31" version="1.1"><title>Group</title> <desc>Created with Sketch.</desc></svg>