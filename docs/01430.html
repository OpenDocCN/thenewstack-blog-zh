<html>
<head>
<title>Microsoft Brings Kubernetes to Azure</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微软将Kubernetes带到Azure</h1>
<blockquote>原文：<a href="https://thenewstack.io/microsofts-burns-azure-breaks-kubernetes-free-exclusivity-lock/#0001-01-01">https://thenewstack.io/microsofts-burns-azure-breaks-kubernetes-free-exclusivity-lock/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">


<p class="translated">“我认为人们在生态系统中有很多价值，我们不一定想要，甚至不认为有必要绑定到一个特定的操作系统上，”微软的合作伙伴架构师兼谷歌Kubernetes的最初首席开发人员之一Brendan Burns表示，<a href="https://thenewstack.io/new-updates-making-azure-container-service-applications-run-not-containers-run/" class="local-link">微软上周在Azure Container服务</a>上全面发布Kubernetes支持之前，他谈到了新的堆栈。</p>
<p class="translated">Burn的断言可能是你期望在Linux基金会或云本地计算基金会的一位研究员的新堆栈中找到的那种声明。但是，微软单方面宣布脱钩的唯一重要之处在于:首先，是谁说的。接下来，就是他从哪里来到现在的位置。然后是他发表声明的背景。</p>
<p class="translated">“我们只是想确保人们能够使用这种技术，如果他们也在. NET或Windows操作系统环境中部署他们的应用程序，”Burns继续说道。“我们不想让它成为唯一的选择。我们不想让人们不得不做决定。我们想让人们找到适合他们的地方。”</p>
<h2 class="translated">没有区别的区别？</h2>
<p class="translated">微软目前的政策，正如包括伯恩斯在内的多位公司官员所说，是同时启用多种工作负载部署选项，所有这些都由Azure作为底层平台提供支持。这是一种将该公司描绘成首选代理商的方式，也是一个难得的机会，让它在历史上一直是“首选”公司。</p>
<p class="translated">然而，它去年6月从谷歌挖走了伯恩斯，他在谷歌是<a href="/category/kubernetes/" target="_blank"> Kubernetes </a>容器编排引擎的联合创始人，随后它授权伯恩斯作为数据中心异构性的倡导者和微软作为其推动者，缺乏过去该公司特有的烟雾和屏幕的指示性组件。</p>
<p class="translated">“在我来到这里之前，每个人都很清楚[<em>开源软件</em>和Linux将成为Azure非常重要的组成部分，”伯恩斯在最近的一封电子邮件中告诉新的堆栈。“我的经验让我关注如何同时参与公共云和上游开源社区，以及这看起来像什么。我们有许多活跃的开源社区，例如<a href="https://code.visualstudio.com/" class="ext-link" rel="external "> Visual Studio Code </a>。你如何参与两者——构建你的产品和参与OSS社区——有点独特，我们正在扩展。例如，我的一个同事正在开发Kubernetes 1.6版本，以确保它是Azure的高质量版本，但这项工作也使Kubernetes整体上变得更加强大。”</p>
<p class="translated">这里有一个不太容易解释的目标，即使对微软的人来说…即使对帮助建立容器生态系统，然后进入微软的人来说。从表面上看，这一想法是为了在开发可部署到公共云的服务时为开发人员提供更多的选择——在这种情况下，显然是部署到Azure。本质上，策略是使平台之间的差异达到以下任何程度:a)可以忽略不计；b)不太明显；c)多余的；d)开发者个人品味的问题。在上述任何一种情况下，也许微软都无法获得超过竞争对手的优势，但反过来也是如此。</p>
<p class="translated">Burns是这样对我们说的:“我们交谈过的大多数客户都对在混合和/或多云环境中运营感兴趣，并且正在寻找容器编排。我们很高兴能够通过开源来实现为他们服务的混合服务。”</p>
<h2 class="translated">开发人员可以看到的差异</h2>
<p class="translated">2015年春天，一位名为<a href="https://www.youtube.com/watch?v=DC7NECq3Ghs" class="ext-link" rel="external ">的后起之秀谷歌工程师布兰登·伯恩斯(Brendan Burns)首次演示了从Linux命令行运行Kubernetes集群的基本原理</a>:</p>
<p class="translated"><iframe loading="lazy" src="https://www.youtube.com/embed/DC7NECq3Ghs?feature=oembed" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen="">视频</iframe></p>
<p class="translated">这个演示包括启动NGINX的一个工作实例。从Linux命令行，Burns实例化了一个<a href="https://github.com/coreos/etcd" class="ext-link" rel="external "> etcd </a>容器，作为一个简单的存储组件。一旦实例化，他交付一个<strong> docker run </strong>命令来触发应用程序的主组件，并交付另一个<strong> docker run </strong>命令来启动服务代理，启用与这些组件的通信。从开发人员的角度来看，这是一个三步过程，但实际上，几个自动化步骤在后台发生，包括创建<a href="https://kubernetes.io/docs/admin/kubelet/" class="ext-link" rel="external ">kube let</a>——代表Kubernetes工作的pod端容器管理器。kubelet自动生成了必要的API和调度器容器，并将它们绑定到pod。从那里，kubelet将负责管理其监护下的集装箱的健康状况。</p>
<p class="translated">(伯恩斯后来澄清说，他的演示涉及从Visual Studio代码创建标准的Linux容器，而不是Windows容器。)</p>
<p class="translated">随着通信过程的建立，Burns可以使用Kubernetes API调用简单的、类似动词的命令，使用<strong> <a href="https://kubernetes.io/docs/user-guide/kubectl-overview/" class="ext-link" rel="external "> kubectl </a> </strong>命令行界面将它们传递给orchestrator。通过这个通道，Burns可以告诉Kubernetes调用并运行NGINX。</p>
<p class="translated">快进19个月。在此期间，Kubernetes API发生了几次变化，但如果有人睡了那么久，也不会让人认不出这个管弦乐队。微软的合作架构师Brendan Burns演示了如何使用Azure的资源调用和操作Kubernetes管理的pod。</p>
<p class="translated"><iframe loading="lazy" src="https://www.youtube.com/embed/nhY9XdzNbbY?feature=oembed" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen="">视频</iframe></p>
<p class="translated">Azure中的命令行工具是<strong> az </strong>，所以Burns访问<a href="https://azure.microsoft.com/en-us/services/container-service/" class="ext-link" rel="external "> Azure容器服务</a>的方式是通过<strong> az acs </strong>。这里启动orchestrator的过程是通过命令<strong> az acs create </strong>完成的，值得注意的是，属性<strong>orchestrator-type</strong>是完全开放的。这是运营商可以指定Kubernetes的地方，而不是Swarm或Mesosphere的数据中心操作系统，后者是Azure也支持的其他orchestrators。在指导Kubernetes收集在Azure上运行其容器所需的凭证后，他就可以与<strong> kubectl </strong>通信了。(<a href="https://docs.microsoft.com/en-us/azure/container-service/container-service-kubernetes-walkthrough" class="ext-link" rel="external ">微软的文档更详细。</a>)</p>
<p class="translated">但是从那里，伯恩斯没有坚持使用命令行，而是跳到了Visual Studio Code (VS Code)控制台。如果您对历史悠久的基于Windows的开发工具的Visual Studio套件有些熟悉，请忘记您认为自己了解的一切——除了定性的相似性，VS代码是一个非常不同的世界。</p>
<p class="translated">在后面的演示中，终端面板给了Burns一个更完整的Azure命令行连接——比每次都调用<strong> az acs </strong>更有效。但是当他需要向Azure上的Kubernetes发出命令时，他不必打开终端面板。</p>
<p class="translated">相反，他使用编辑器顶部的搜索行，通过名字向<strong> kubernetes </strong>发出命令(而不是<strong> kubectl </strong>),就好像这是一个网络浏览器，他正在谷歌上查找一个页面。这里的搜索行就像一个术语表，显示Kubernetes是如何寻址的，并让开发人员有效地浏览选项。</p>
<p class="translated">通过VS代码在Azure上使用Kubernetes有种无服务器的感觉。除了在最开始初始化pod之外(这可能很快就会改变)，单个控制台中功能之间的内聚性让人想起了过去编程是多么舒适，当时您正在编程的机器离您有12英寸远，您使用的工具是光滑、健壮和经过良好测试的。到Git的链接、主要源代码、JSON部署和配置代码以及用于构造容器的docker文件都隐藏在VS代码控制台中指定的部分——而不是像彩弹锦标赛一样显示在桌面上的各个窗口中。</p>
<h2 class="translated">这一点也不疼</h2>
<p class="translated">敏锐的观众不会忘记Burns的VS代码演示是在Linux桌面上进行的。然而，被掩盖的是这个相当重要的信息:使用Docker构建并使用Kubernetes编排的容器，利用了微软的<a href="https://blogs.technet.microsoft.com/windowsserver/2016/02/10/exploring-nano-server-for-windows-server-2016/" class="ext-link" rel="external "> Windows Nano Server </a>，而不是最小化的Linux。如果莎士比亚还在寻找众所周知的难题，这就是了。</p>
<p class="translated">“以前——老实说，这对Linux和Windows用户来说是真的——让他们能够构建云原生应用的东西是自主开发和定制的，”Burns告诉New Stack。“他们将有效地构建他们的编排系统，但它将与他们的应用程序紧密集成。</p>
<p class="translated">“现在有了容器，我们有机会构建一个每个人都可以使用的编排系统。你不必成为[<em>微软</em>Exchange团队或Xbox团队的规模来构建你自己的编排层。通过构建这些容器，您可以利用云原生技术，而不必构建太多。这就是正在发生的转变，允许这些中小型团队专注于他们的应用程序，同时仍然获得云原生方法的好处。”</p>
<p class="translated">这是微软通过Azure Container服务和orchestrator选择瞄准的市场:不是Linux已经大量存在的超大规模、跨云的复杂系统，而是<em>新浪潮</em>尚未触及的较小企业——微软尚未被进化的力量所取代的领域。</p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
<title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>

</div>
</div>    
</body>
</html>