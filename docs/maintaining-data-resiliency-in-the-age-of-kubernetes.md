# 在 Kubernetes 时代维护数据弹性

> 原文：<https://thenewstack.io/maintaining-data-resiliency-in-the-age-of-kubernetes/>

[](https://www.linkedin.com/in/petebrey/)

 [皮特·布雷

皮特是红帽公司数据服务部门的高级首席产品营销经理。他曾在 NetApp 和 Hewlett Packard 担任营销职位，并获得了丹佛大学的 MBA 学位。](https://www.linkedin.com/in/petebrey/) [](https://www.linkedin.com/in/petebrey/)

新的应用程序方法需要新的数据管理方法。十年前，许多组织可以使用传统的数据库、数据仓库和数据恢复方法来掌控自己的数据。今天，数据通过 Linux 容器与应用程序紧密耦合。这些容器越来越多地通过 Kubernetes 进行编排，根据云本地计算基金会(CNCF)的最新年度调查，83%的受访者正在生产中使用 Kubernetes。

这是否意味着如果您正在使用 Kubernetes，您需要重新考虑您的数据弹性和恢复方法？不完全是。事实上，即使您正在使用 Kubernetes，您也可以基于现有的最佳实践和经验教训来保持您的数据随时可用并在发生不利事件时得到保护。

让我们看看为什么会这样，以及在 Kubernetes 环境中优化数据弹性应该做的四件事。

## **辞旧迎新**

Kubernetes 通过微服务和自动化实现了新的效率水平。它使您能够更快、更灵活地将软件推向市场，为您带来竞争优势。

Kubernetes 还依赖持久存储卷来保存和在容器之间共享数据。持久存储通过在容器中存储数据来解决容器的短期或临时性质，即使在容器关闭之后，数据仍然保持完整。这可能会让您认为您需要抛弃您所知道的关于灾难恢复和业务连续性的一切。但事实是，您的 IT 经理、数据存储专家、备份管理员和应用程序开发人员的数据恢复知识和能力仍然适用。您只需将 Kubernetes 与云、裸机服务器和您支持的任何其他环境一起添加到您的数据弹性产品组合中。

事实上，像 Kubernetes 这样的开源技术的一个关键优势是，它们旨在支持不断变化的需求，而不必在新技术出现时重新发明轮子。此外，许多最新的容器存储平台都包含内置的针对云原生工作负载的数据弹性功能。这些功能使您能够跨混合和多云环境扩展这些工作负载的现有数据保护解决方案和基础架构。

## **4 项数据弹性最佳实践**

一旦您认识到 Kubernetes 并不要求您完全重新考虑数据弹性，问题就变成了:您需要什么样的数据可用性的基本最佳实践？

无论您是否使用 Kubernetes，优化数据弹性都要从了解您组织独特的业务连续性需求开始。它继续投资于适合每种工作负载的数据保护和灾难恢复级别。这项投资涉及四个级别的数据保护:

1.  **快照**:时间点快照是您的第一道防线。例如，它们在升级之前很有用，因为它们使您能够快速轻松地将系统恢复到以前的状态。
2.  **备份和恢复**:将数据备份到云或利用云提供商的对象存储服务等策略使您能够在需要时快速访问备份数据。有效的数据保护 API 应该允许您正确地恢复在容器单元中运行的数据和应用程序。
3.  灾难恢复:无论您面对的是相对较小的灾难(如在数据中心丢失一个机架)还是重大事件(如地震)，灾难恢复都是必要的。通常，您需要在地理上分散的位置复制数据。请注意，有状态应用程序比无状态应用程序需要更复杂的灾难恢复。
4.  **业务连续性:**最成熟的数据保护级别也可能是成本最高的。对业务连续性的投资适合于任务关键型应用程序，如处理客户订单输入或金融交易的应用程序。有两个选项需要考虑:同步镜像和异步复制。

同步镜像适用于绝对不能丢失的最关键数据。使用这种方法，每次将数据写入本地磁盘时，也会将数据写入远程磁盘。如果在很短的时间内没有从远程站点收到更改确认，系统会重新传输更改或声明失败。该过程通过光纤网络尽可能快地进行。

异步复制更适合重要但不太关键的工作负载。在这种情况下，系统首先将数据写入本地存储，然后以预定的时间间隔将数据复制到远程站点。

Kubernetes 可以帮助您的组织变得更加灵活和更具竞争力。更好的是，它不需要您彻底检查您的数据弹性策略。但是，您确实需要确保您的容器化环境中的每个应用程序都有合适的弹性级别。幸运的是，您可能已经知道如何做到这一点。

<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 68 31" version="1.1"><title>Group</title> <desc>Created with Sketch.</desc></svg>