<html>
<head>
<title>How Cloud Platforms Will Evolve Programming Languages and Runtime Models</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">云平台将如何发展编程语言和运行时模型</h1>
<blockquote>原文：<a href="https://thenewstack.io/cloud-platforms-will-evolve-programming-languages-runtime-models/#0001-01-01">https://thenewstack.io/cloud-platforms-will-evolve-programming-languages-runtime-models/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">


<p class="translated"><a href="https://apprenda.com/" class="clearfix infoBlock " target="_blank"> <div class="infoBlockTextBlock"> <p class="infoBlockTitle">辛克莱·舒勒</p> <p class="infoBlockText">辛克莱·舒勒是Apprenda的CEO。Apprenda和他的两位联合创始人从NEA、Ignition Partners、Safeguard Scientifics和High Peak Ventures获得了5700万美元的风险投资，为企业开发者提供私有和公共PaaS。Apprenda是企业在当前和未来的基础设施投资上实现现有和新应用程序云化的最佳方式。Sinclair服务于多个风险网络，并在全国范围内就企业IT效率、云计算和下一代企业架构等主题发表演讲。在Apprenda之前，Sinclair曾在Morgan Stanley、Eden Communications任职，并为SUNY州立大学的大型IT系统提供咨询。Sinclair拥有伦斯勒理工学院的双学士学位。</p> </div> </a></p><p class="translated">与30年前相比，我们开发人员拥有的编程语言的数量是惊人的，这些语言的持续发展速度令人眩晕。虽然语言范式发生了巨大的变化，但在执行和编译方面没有太大的变化。</p>
<p class="translated">几乎所有的语言都被编译成处理器本机字节码或中间字节码(例如Java字节码，IL ),目的是在单个节点上运行。即使是为分布式开发而微调的语言也使用语法糖和运行时支持服务的组合来简化分布式执行。</p>
<p class="translated">最终，即使是这些“分布式优先”的语言和运行时也遵循传统的编译或解释成一些字节码，然后在非常传统的操作系统上作为单个进程运行。这些进程可能会被嵌入到分布式架构中(例如Erlang)，但在某些方面，它们仍然被传统地编译为本地的。</p>
<p class="translated">基于传统操作系统上执行范例的历史，这是有意义的。在之前的计算执行时代，通用的是指令集、内存、CPU周期和资源管理——所以这就是我们对语言编译和执行的看法。</p>
<p class="translated">但是30年来发生了很大的变化。云计算时代，执行的货币不一样了。它更高级，在某些方面更复杂。我们不再考虑多线程，而是考虑多节点。我们的软件架构构建为在包含数百个操作系统的网络上运行，并且具有以前难以维持的并行性或并发性。</p>
<p class="translated">再加上应用程序运行的基础设施可以被应用程序自身重塑，这种可能性是惊人的。应用程序可以动态地配置和重新路由网络，并且可以向加速运行的执行节点(如VM或容器)发出简单的请求，然后这些执行节点可以托管它自己制作的应用程序的副本，或者更强大地，托管由该应用程序通过元编程生成的应用程序。所有这些都将执行从传统操作系统转移到了堆栈上，使传统操作系统沦为现代云原生应用中的一种商品。</p>
<p class="translated">云平台，如平台即服务(PaaS)或集群管理器，通过提取尽可能多的细节来承认这一点，并通过策略或推理，允许应用程序以独立的方式在基础架构上执行。这有助于隐藏分布式应用程序的复杂性，并降低开发人员在编写和部署这些类型的应用程序时的复杂性。</p>
<p class="translated">但它就此止步了吗？我们是否仍将使用已知的编程语言，这些语言由传统编译器编译成中间或本机字节码，然后由云平台托管，帮助应用程序正确执行？大概不会。</p>
<p class="translated">随着内存变得越来越便宜，应用程序开始更自由地使用内存。用C语言编写应用程序的开发人员近乎不顾后果地使用<strong> malloc() </strong>和<strong> free() </strong>，导致了内存泄漏，这通常是许多软件错误的原因。为了解决这个问题，JVM和。NET CLR的引入，抽象出内存管理，并为应用程序提供执行缓冲，而不是直接在操作系统上运行。对内存的轻松访问推动了消耗的增加，缺陷的数量增加到了成为问题的程度。这迫使内存管理的发明。</p>
<p class="translated">云计算和云平台没什么区别。获得某个短暂的操作系统实例的句柄变得很便宜。看看通过REST APIs在AWS或Azure上运行主机是多么容易。软件定义的网络(SDN)正在降低网络操作的成本。随着这种趋势的继续，我们会发现管理起来会更加复杂。鉴于这是“云系统编程”发生的地方，云平台提供商可能会首先意识到这一点。</p>
<p class="translated">类似于托管内存运行时的创建，我们可能会创建托管基础设施运行时(MIR)。语言将被编译成某种中间指令集，作为执行的一部分，MIR将接收MIR指令并旋转容器或单核实例，改变网络路由，并在这个新的抽象级别上管理资源。</p>
<p class="translated">应用程序逻辑可以迁移到不同的容器中，以优化数据局部性或性能，而无需开发人员或云平台的参与。云优先语言很可能会发展到允许语法“云提示”如何塑造基础设施或何时只强制本地执行，而不是隐式跨节点迁移。这类似于我们在C#中通过“unsafe”关键字或在Java中使用“final”进入非托管代码，这可能会导致方法内联。</p>
<p class="translated">这些会发生吗？复杂性似乎必然会推动新的云运行时模型的发明和采用。虽然不完全相同，但我们在像<a href="https://aws.amazon.com/lambda/" class="ext-link" rel="external "> AWS Lambda </a>这样的技术中看到了一些这样的东西，所以这个想法不应该看起来太牵强，很快就会出现。</p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
<title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>
</div>
</div>    
</body>
</html>