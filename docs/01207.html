<html>
<head>
<title>How the Container Storage Interface (CSI) Boosts Cloud Native DevOps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">容器存储接口(CSI)如何提升云原生开发运维</h1>
<blockquote>原文：<a href="https://thenewstack.io/how-the-container-storage-interface-csi-boosts-cloud-native-devops/#0001-01-01">https://thenewstack.io/how-the-container-storage-interface-csi-boosts-cloud-native-devops/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">


<p class="attribution translated"><a href="https://www.delltechnologies.com/en-us/index.htm" target="_blank" rel="noopener noreferrer external " class="ext-link">戴尔科技</a>赞助了这次播客。</p>
<p class="translated">现代数字组织的内在斗争在于速度和安全性。随着软件开发速度似乎不断增加，IT组织正在寻找他们可以使用的工具来提供防护和治理——而不减慢速度。</p>
<p class="translated">基础设施即代码作为解决方案和双方的共同语言而出现。随着开发人员要求类似云的消费和自动化继续成为成功开发运维组织的秘密，工具和规范成为受欢迎的解决方案。</p>
<p class="translated">在<a href="https://events19.linuxfoundation.org/events/kubecon-cloudnativecon-north-america-2019/" class="ext-link" rel="external "> KubeCon + CloudNativeCon </a>，New Stack创始人兼发行人Alex Williams与负责容器存储和界面驱动程序的产品经理<a href="https://www.linkedin.com/in/audrius-stripeikis/" target="_blank" rel="noopener noreferrer external " class="ext-link"> Audrius Stripeikis </a>和产品组合营销顾问<a href="http://linkedin.com/in/parasarkodati" target="_blank" rel="noopener noreferrer external " class="ext-link"> Parasar Kodati </a>坐在一起，谈论针对最古老的瓶颈之一的最新修复方案。他们深入探讨了<a href="https://github.com/container-storage-interface/spec" target="_blank" rel="noopener noreferrer external " class="ext-link">容器存储接口(CSI) </a>规范及其接口驱动程序，以及它们如何响应Kubernetes支持的企业DevOps的需求。<br/> <br/> <span class="media-direct-link"> <a href="https://thenewstack.simplecast.com/episodes/the-battle-between-speed-and-security" class="ext-link" rel="external ">速度与安全的较量</a> </span></p>

<p class="translated">CSI旨在将最终控制权交给IT管理员，同时仍然允许开发人员直接调配他们自己的存储，而不是等待他人为他们调配存储。</p>
<p class="translated">Stripeikis解释说,<a href="https://kubernetes.io/blog/2019/01/15/container-storage-interface-ga/" target="_blank" rel="noopener noreferrer external " class="ext-link">容器存储接口</a>基本上是一个规范，它定义了存储区域如何连接到Kubernetes集群。</p>
<p class="translated">“最初当[Kubernetes orchestration]开始时，每个人都对存储区域如何连接到Kubernetes提出了自己的定义。这使得美国供应商很难开发那些连接到各种容器编排器的驱动程序，”他说。</p>
<p class="translated">因此，Kubernetes社区尝试了一个名为<a href="https://kubernetes.io/docs/concepts/storage/volumes/" target="_blank" rel="noopener noreferrer external " class="ext-link"> FlexVolume </a>的规范，但它被认为是一个低效、甚至繁琐和复杂的解决方案。驱动程序只能在Kubernetes发布期间更新。</p>
<p class="translated">因此，Kubernetes社区决定制定一个规范，允许像戴尔EMC这样的供应商提供新的驱动程序，这些驱动程序以软件的形式作为规范的实现。</p>
<p class="translated">借助CSI，存储管理员可以为开发人员用户分配存储空间。然后，消费者将以永久卷的形式使用该分配。</p>
<h3 class="translated">CSI让存储管理员设置护栏</h3>
<p class="translated">Stripeikis警告说，对于这些接口驱动程序，“存储管理员不习惯这种模式。他们觉得自己现在正在失去控制，事实并非如此。”</p>
<p class="translated">他说，CSI为这些管理员提供了存储类，允许他们定义可以使用哪个存储区域，该存储区域内将分配多少容量，以及谁可以访问它。它使管理员能够设置护栏和配额，就像在特定卷上一次只能有这么多分支一样。</p>
<p class="translated">如果开发人员的构建超过了这些配额规则，部署将会停止。</p>
<p class="translated">CSI旨在应用于CI/CD管道。Kodati解释说，无论定义什么样的存储类别，都会自动为他们的应用或微服务调配。</p>
<p class="translated">这一切都归结为“您如何教育您的It组织，该组织传统上负责通过进入自动化和以代码形式调配基础架构的思维模式来帮助开发人员以他们希望的速度前进？”科达提说。</p>
<p class="translated">这是拥抱基础设施的更大趋势的一部分，正如Kodati所说，基础设施“嵌入”到CI/CD管道中，允许开发人员独立和基于策略的供应、配置管理和流程的自动移交。</p>
<p class="translated"><iframe loading="lazy" title="The Battle Between Speed and Security" src="https://www.youtube.com/embed/wsKCJhAxRJk?feature=oembed" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="">视频</iframe></p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
<title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>


</div>
</div>    
</body>
</html>