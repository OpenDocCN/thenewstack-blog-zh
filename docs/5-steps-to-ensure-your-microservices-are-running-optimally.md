# 确保微服务最佳运行的 5 个步骤

> 原文：<https://thenewstack.io/5-steps-to-ensure-your-microservices-are-running-optimally/>

如今，似乎每个人都喜欢微服务，而整体架构正在慢慢淡出人们的视线。

当然，潮流来来去去，他们得到的关注往往被夸大了，并不能反映真实的情况。然而，对于微服务，似乎有更多的共识认为这一趋势将会持续下去。有道理。从概念上讲，微服务扩展了工程师们已经使用了几十年的原则。

一旦你确定了微服务架构，这里有五条规则需要记住，以便成功地运行它们。

## 微服务的另一面

 [塔尔维斯

Tal Weiss 是 OverOps 的联合创始人兼首席技术官，负责产品和工程战略。OverOps 是一个持续的可靠性解决方案，它使创建软件的公司能够确保快速代码更改不会影响客户体验。使用 OverOps，团队可以快速识别、预防和解决关键的软件问题。](https://www.linkedin.com/in/talws/) 

关注点分离(SoC)是一种设计原则，它规定软件应该由“关注点”或整体功能决定的不同部分构建，它已经被使用了 30 多年来规定技术应该如何构建。在单片应用程序中，它体现在典型的三层体系结构中表示层、业务层和数据层的分离。

微服务采用了这个概念，并将其颠倒过来。他们采用相同的应用程序，并以这样的方式将其分离，即应用程序的单一代码库可以被分解并单独部署。好处是巨大的，但也是有代价的，通常体现在时间和金钱方面的运营成本更高。除了将现有应用程序转换到容器所带来的巨大前期投资之外，维护该应用程序也带来了新的挑战。

## 挑战#1:好像监测一个整体还不够困难

虽然单块应用程序有自己的挑战，但是回滚单块应用程序中的“坏”版本的过程相当简单。在容器化的应用程序中，事情要复杂得多。无论您是逐渐将单一应用分解为微服务，还是从头开始构建新系统，您现在都有更多服务需要监控。其中每一项都可能:

●使用不同的技术和/或语言

●在不同的机器和/或容器上运行

●使用 K8 或类似技术进行集装箱化和编排

这样一来，系统变得高度分散，对集中监控的需求更加强烈。可悲的是，这也意味着有更多的东西需要监控。曾经有一个单一的整体流程，现在可能有几十个容器化的流程在不同的区域运行，有时甚至是不同的云(！).这意味着 IT/运营团队不再需要一套运营指标来评估应用程序的正常运行时间。相反，团队现在必须处理数百(甚至数千)种度量标准、事件和警报类型的洪水，他们需要从中分离信号和噪声。

**前进之路:** DevOps 监控需要从平面数据模型转移到分层模型，在该模型中可以随时观察一组高级系统和业务 KPI。只要有一点点偏差，团队就必须能够深入到指标层次结构中，查看部队中的干扰是从哪个微服务开始的，并从那里深入到发生故障的实际容器。从数据存储和可视化的角度来看，这很可能需要对 DevOps 工具链进行重组。开源时间序列数据库和工具，如[普罗米修斯](https://prometheus.io/)和 [Grafana 7.0](https://grafana.com/) 使这一目标非常容易实现。

## 挑战#2:跨服务记录

当谈到监控应用程序时，首先想到的是:日志、日志、日志。相当于碳排放的 IT，服务器每天都会产生数 GB 的非结构化文本，最终导致硬盘溢出以及疯狂的摄取、存储和工具成本。即使使用整体架构，您的日志可能已经让您的工程师有些头疼了。

有了微服务，日志变得更加分散。一个简单的用户事务现在可以通过许多服务，所有这些服务都有自己的日志框架。要解决一个问题，您必须从事务可能经过的所有服务中提取所有不同的日志，以了解哪里出错了。

**前进之路:**这里的关键挑战是理解单个事务如何在不同的服务之间“流动”。要实现这一点，需要对传统的 monolith 在顺序事务执行期间记录所有事件的方式进行大规模改造。虽然已经出现了许多框架来帮助开发人员处理这个问题(我们尤其喜欢 Jaeger 的方法)，但是对于希望将单片重构为微服务的企业来说，转向异步、跟踪驱动的日志记录仍然是一项艰巨的工作。

## 挑战#3:部署一个服务会破坏另一个服务

在 monolithic world 中，一个关键的假设是所有代码都是同时部署的，这意味着应用程序最容易受到攻击的时间段是一个已知的相对较短的时间段(即部署后的前 24-48 小时)。在微服务的世界中，这一假设不再成立:由于微服务天生相互交织，一个微服务中的重大变化可能会导致行为或性能问题，而这些问题只会在另一个微服务中显现。挑战在于，另一个微服务失败的开发团队没有预料到他们的代码会出现中断。这可能会导致应用程序整体的意外不稳定性，以及一些组织摩擦。虽然微服务架构可能使部署代码的过程更加容易，但它们实际上使部署后验证代码行为的过程更加困难。

**前进之路:**每当部署相关的微服务时，组织必须创建共享的发布日历并分配资源，以便从整体上密切测试和监控应用的行为。在没有跨团队协作的情况下部署新版本的微服务，就像牛油果配烤面包一样容易带来麻烦。

## 挑战#4:找到问题的根本原因

此时，您已经确定了有问题的服务，从日志中提取了所有需要的数据，包括堆栈跟踪和一些变量值。你可能也有某种 APM 解决方案，比如 New Relic、AppDynamics 或 Dynatrace(我们也在这里写了和)。从那里，您将获得一些关于一些相关方法异常高的处理时间的额外数据。但是…问题的[根本原因](https://blog.overops.com/the-7-key-components-of-true-root-cause-analysis/)是什么？

您(希望)从日志中获得的可变数据的前几位很可能不是移动指针的数据。它们通常更像是面包屑，指向下一条线索，而不是更远。在这一点上，我们需要尽我们所能来揭示我们的应用程序背后更多的“魔力”。传统上，这需要发出关于每个失败事务状态的详细信息(即，它失败的确切原因)。这里的挑战是，这需要开发人员有极大的远见，知道他们需要什么信息来提前解决问题。

**前进之路:**当微服务中的错误的根本原因跨越多个服务时，采用集中的根本原因检测方法至关重要。团队必须考虑需要哪些信息粒子来诊断未来的问题，以及出于性能和安全性的考虑，应该在什么级别发出这些信息粒子——这是一座需要攀登的高山，没有尽头。

## 挑战#5:版本管理

另一个问题，也是我们之前提到过但我们认为值得强调的问题，是从典型整体架构中的层模型过渡到具有微服务的图形模型。由于超过 80%的应用程序代码通常是第三方的，管理第三方代码在公司不同微服务之间共享的方式成为避免令人恐惧的“依赖地狱”的关键要素

考虑这样一种情况，一些团队使用第三方组件或共享工具的 X.Y 版本(几乎所有公司都有),而其他团队使用 X.Z 版本。这增加了由于不同版本之间缺乏兼容性而导致的关键软件问题的风险，或者版本之间行为的细微变化可能导致最特殊和最令人痛苦的软件错误以进行故障排除。

所有这一切都是在我们提醒自己任何一个使用第三方代码的旧版本、更易受攻击的微服务所带来的安全问题之前——这是黑客的梦想。在一个铁板一块的世界里，允许不同的团队在孤立的回购协议中管理他们的依赖关系可能是可行的(如果不推荐的话)。在微服务架构中，这是绝对不允许的。

**前进的道路:**公司必须投资重新设计他们的构建过程，以利用第三方和共享实用程序代码的集中式工件库( [Artifactory](https://jfrog.com/artifactory/) 就是其中之一)。团队应该只被允许在他们的个人回购中存储他们自己的代码。

## 最后的想法

正如科技行业的大多数进步一样，微服务采用了一个熟悉的概念，并将其颠倒过来。他们重新思考大规模应用程序的设计、构建和维护方式。随之而来的有许多好处，但也有新的挑战。当我们一起看这五个主要挑战时，我们可以看到它们都源于同一个想法。底线是，采用像微服务这样的新技术需要对代码如何构建、部署和观察进行重新思考和重组。奖励是巨大的——但风险也是巨大的。

<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 68 31" version="1.1"><title>Group</title> <desc>Created with Sketch.</desc></svg>