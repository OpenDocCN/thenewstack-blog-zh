<html>
<head>
<title>Off-The-Shelf Hacker: Putting the MQTT Broker to Work on the CHIP Platform</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现成的黑客:让MQTT代理在芯片平台上工作</h1>
<blockquote>原文：<a href="https://thenewstack.io/off-shelf-hacker-putting-mqtt-broker-work-chip-platform/#0001-01-01">https://thenewstack.io/off-shelf-hacker-putting-mqtt-broker-work-chip-platform/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">


<p class="translated">MQTT消息传递协议非常适合物理计算项目和机器对机器的消息传递，因为它独立于内容。您可以在消息中放入任何您想要的内容，而不用担心格式或内部结构。消息结构在发送端和接收端被定义、解释和作用。发布到主题的消息可以有不同的解释，这取决于您编写的代码。一个边缘设备可能会将“1”消息解释为打开LED的命令，而笔记本电脑在查看相同主题的相同“1”消息时，可能会在用户的桌面仪表盘上点亮一个绿点。</p>
<p class="translated">在这一期的<a href="/tag/off-the-shelf-hacker/" target="_blank">现成黑客</a>专栏中，我们将看看在联网到基于<a href="https://www.engadget.com/2015/05/10/chip-is-a-9-raspberry-pi-killer/" class="ext-link" rel="external ">芯片低成本处理器</a>的数据中心的几个实际设备上使用MQTT作为消息传输方法。</p>
<p class="translated">听起来很复杂。幸运的是，我们可以使用<a href="https://www.python.org/" class="ext-link" rel="external "> Python </a>，它可以在几乎所有基于Linux的系统上运行。</p>
<h2 class="translated">Python和库是编程粘合剂</h2>
<p class="translated">早在发现MQTT之前，我就开始在Raspberry Pi上用Python编写程序，因为它被捆绑到了Raspbian Linux中。事实证明，Python很容易安装在芯片上，我的Xubuntu Linux笔记本也是如此。更重要的是，所有这些平台都有Python MQTT库。</p>
<p class="translated">Paho项目是一个流行的MQTT库。它很容易安装在树莓派和芯片上。我只是在Xubuntu笔记本上使用了Synaptic包管理器来加载Paho-MQTT库。</p>
<p class="translated">首先，如果你需要把Python放到芯片上或者你的Xubuntu Linux笔记本上，使用下面的命令行:<br/></p>
<div id="crayon-642311c5df588479793484" class="crayon-syntax crayon-theme-github-gist crayon-font-liberation-mono crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-always">
<p class="crayon-plain-wrap"/>
<div class="crayon-main">
<pre><span class="crayon-e">sudo </span><span class="crayon-i">apt</span>-<span class="crayon-e">get </span><span class="crayon-e">install </span><span class="crayon-v">python</span>
</pre>
</div>
</div>

<p class="translated"><br/> Python有自己的包管理器，叫做<a href="https://packaging.python.org/installing/" class="ext-link" rel="external "> pip </a>。只需在Raspberry Pi和芯片上运行pip来安装mqtt库。<br/></p>
<div id="crayon-642311c5df58d831877501" class="crayon-syntax crayon-theme-github-gist crayon-font-liberation-mono crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-always">
<p class="crayon-plain-wrap"/>
<div class="crayon-main">
<pre><span class="crayon-e">sudo </span><span class="crayon-e">pip </span><span class="crayon-e">install </span><span class="crayon-i">paho</span>-<span class="crayon-v">mqtt</span>
</pre>
</div>
</div>

<p class="translated"><br/>安装完成后，继续将库集成到一些Python代码中。</p>
<h2 class="translated">读取芯片上的按钮</h2>
<p class="translated">作为发布者和订阅者的MQTT代理和客户机可以在同一个设备上愉快地工作。考虑到芯片或Raspberry Pi等设备上提供的所有通用输入/输出(GPIO)引脚，它还是一个强大的工具。</p>
<p class="translated">考虑到这一点，一个简单的Python脚本并不多，它在芯片上运行，等待按钮按下，然后在“mqtt”主题下向代理(在我们的例子中是本地的)发布消息。<br/></p>
<div id="crayon-642311c5df58e447895478" class="crayon-syntax crayon-theme-github-gist crayon-font-liberation-mono crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-always">
<p class="crayon-plain-wrap"/>
<div class="crayon-main">
<pre><span class="crayon-e">import </span><span class="crayon-i">paho</span><span class="crayon-st">.</span><span class="crayon-i">mqtt</span><span class="crayon-st">.</span><span class="crayon-e">client </span><span class="crayon-e">as </span><span class="crayon-e">mqtt</span>
<span class="crayon-e">import </span><span class="crayon-i">CHIP_IO</span><span class="crayon-st">.</span><span class="crayon-e">GPIO </span><span class="crayon-e">as </span><span class="crayon-e">GPIO</span>
<span class="crayon-e">import </span><span class="crayon-e">time</span>
<span class="crayon-e">import </span><span class="crayon-e">os</span>
<span class="crayon-e">import </span><span class="crayon-i">paho</span><span class="crayon-st">.</span><span class="crayon-i">mqtt</span><span class="crayon-st">.</span><span class="crayon-e">publish </span><span class="crayon-e">as </span><span class="crayon-e">publish</span>
 
<span class="crayon-i">GPIO</span><span class="crayon-st">.</span><span class="crayon-e">setup</span>(<span class="crayon-s">"XIO-P0"</span>,<span class="crayon-h"> </span><span class="crayon-i">GPIO</span><span class="crayon-st">.</span><span class="crayon-i">IN</span>)
<span class="crayon-i">GPIO</span><span class="crayon-st">.</span><span class="crayon-e">input</span>(<span class="crayon-s">"XIO-P0"</span>)
 
<span class="crayon-e">while </span><span class="crayon-i">True</span>:
<span class="crayon-h">    </span><span class="crayon-i">input_state</span><span class="crayon-h"> </span>=<span class="crayon-h"> </span><span class="crayon-i">GPIO</span><span class="crayon-st">.</span><span class="crayon-e">input</span>(<span class="crayon-s">"XIO-P0"</span>)
<span class="crayon-h">    </span><span class="crayon-e">if </span><span class="crayon-i">input_state</span><span class="crayon-h"> </span>==<span class="crayon-h"> </span><span class="crayon-i">True</span>:
<span class="crayon-h">           </span><span class="crayon-i">time</span><span class="crayon-st">.</span><span class="crayon-e">sleep</span>(.<span class="crayon-cn">5</span>)
<span class="crayon-h">           </span><span class="crayon-i">publish</span><span class="crayon-st">.</span><span class="crayon-e">single</span>(<span class="crayon-s">"mqtt"</span>,<span class="crayon-h"> </span><span class="crayon-cn">1</span>,<span class="crayon-h"> </span><span class="crayon-i">hostname</span>=<span class="crayon-s">"172.20.0.1"</span>)
 
<span class="crayon-i">GPIO</span><span class="crayon-st">.</span><span class="crayon-e">cleanup</span>()
</pre>
</div>
</div>

<p class="translated"><br/>首先，在程序中导入并初始化各种库。</p>
<p class="translated">接下来，按钮的GPIO引脚被初始化。按钮连接在芯片U14L接头上的XIO-P0引脚和地之间。面对芯片的顶部，USB端口在顶部，引脚在右侧双接头上，左侧大约向下1/3处。</p>
<p class="translated">“while”循环只是停留在那里查看XIO-P0引脚。当它看到一个按钮被按下时，一个“1”被发布到mqtt代理上的“MQTT”主题。芯片是代理和MQTT发布客户端。回想一下，上次我们在芯片中添加了独立接入点(AP)功能，因此有了一次性的172.20.0.1 IP地址。芯片的接入点SSID是“dr-torq-1”</p>
<p class="translated">该循环实际上足够快来捕捉<a href="https://en.wikipedia.org/wiki/Switch#Contact_bounce" class="ext-link" rel="external ">触点反弹</a>，所以我在代码中加入了第二个延迟，以最小化这种影响。看看能否在其他应用中找到利用这一速度的方法。</p>
<p class="translated">还要记住，由于MQTT数据中枢(芯片)是一个独立的AP，所以在从另一个设备执行任何操作之前，您需要连接到那个SSID。</p>
<p class="translated">要编写和运行Python脚本，从Linux笔记本SSH到芯片。<br/></p>
<div id="crayon-642311c5df58f626933755" class="crayon-syntax crayon-theme-github-gist crayon-font-liberation-mono crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-always">
<p class="crayon-plain-wrap"/>
<div class="crayon-main">
<pre><span class="crayon-i">drtorq</span>-<span class="crayon-i">notebook</span>%<span class="crayon-h">  </span><span class="crayon-e">ssh </span><span class="crayon-i">chip</span>@<span class="crayon-cn">172.20.0.1</span>
</pre>
</div>
</div>

<p class="translated"><br/>进入芯片后，使用以下代码编辑并运行Python脚本。<br/></p>


<p class="translated"><br/></p>
<div id="crayon-642311c5df592635710409" class="crayon-syntax crayon-theme-github-gist crayon-font-liberation-mono crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-always">
<p class="crayon-plain-wrap"/>
<div class="crayon-main">
<pre><span class="crayon-i">chip</span>%<span class="crayon-h">  </span><span class="crayon-e">sudo </span><span class="crayon-e">python </span><span class="crayon-i">button1</span><span class="crayon-st">.</span><span class="crayon-v">py</span>
</pre>
</div>
</div>

<p class="translated"><br/> <strong> sudo </strong>是必需的，因为普通用户没有权限直接控制GPIO管脚。</p>
<p class="translated">通过订阅Linux笔记本中的“mqtt”主题来检查按钮的操作。<br/></p>
<div id="crayon-642311c5df593858374451" class="crayon-syntax crayon-theme-github-gist crayon-font-liberation-mono crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-always">
<p class="crayon-plain-wrap"/>
<div class="crayon-main">
<pre><span class="crayon-i">drtorq</span>-<span class="crayon-i">notebook</span>%<span class="crayon-h">  </span><span class="crayon-i">mosquitto_sub</span><span class="crayon-h"> </span>-<span class="crayon-i">h</span><span class="crayon-h"> </span><span class="crayon-cn">172.20.0.1</span><span class="crayon-h"> </span>-<span class="crayon-st">t</span><span class="crayon-h"> </span><span class="crayon-v">mqtt</span>
</pre>
</div>
</div>

<p class="translated"><br/>每次按下微动开关，您应该会看到屏幕上弹出一个“1”。</p>
<p class="translated">接下来，我们将解决“订户”方面的问题。</p>
<h2 class="translated">点亮“臭氧管”</h2>
<p class="translated">当您可以重新利用现有设备作为概念验证原型时，为什么还要增加新硬件呢？聪明点，通过回收项目，从你工作台上堆积如山的零件中获取最大价值。目前业界的一个热门话题是如何构建硬件，改变物理计算结果只需要一个软件模块。</p>
<p class="translated">当然，徽章需要贴在芯片AP (dr-torq-1 SSID)上，得到一个172.20.0.xxx的地址。我将把它作为一个实际的网络练习留给读者。我们已经将Linux笔记本连接到dr-torq-1 SSID。在我的例子中，Pi从芯片AP获取了172.20.0.137 IP地址。<br/></p>
<div id="crayon-642311c5df594701512083" class="crayon-syntax crayon-theme-github-gist crayon-font-liberation-mono crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-always">
<p class="crayon-plain-wrap"/>
<div class="crayon-main">
<pre><span class="crayon-i">drtorq</span>-<span class="crayon-i">notebook</span>%<span class="crayon-h">  </span><span class="crayon-e">ssh </span><span class="crayon-i">pi</span>@<span class="crayon-cn">172.20.0.137</span>
</pre>
</div>
</div>

<p class="translated"><br/>在Pi上编辑和运行“subscribe”(我称之为mqtt-sub.py) Python脚本与在芯片上编辑和运行“publish”脚本完全一样。<br/></p>


<p class="translated"><br/></p>
<div id="crayon-642311c5df596240568744" class="crayon-syntax crayon-theme-github-gist crayon-font-liberation-mono crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-always">
<p class="crayon-plain-wrap"/>
<div class="crayon-main">
<pre><span class="crayon-i">pi</span>%<span class="crayon-h">  </span><span class="crayon-e">sudo </span><span class="crayon-e">python </span><span class="crayon-i">mqtt</span>-<span class="crayon-i">sub</span><span class="crayon-st">.</span><span class="crayon-v">py</span>
</pre>
</div>
</div>

<p class="translated"><br/>这个Python脚本读取芯片代理上的mqtt订阅主题(“MQTT”)，并对消息进行操作，打开一个绿色LED。<br/></p>
<div id="crayon-642311c5df597660326131" class="crayon-syntax crayon-theme-github-gist crayon-font-liberation-mono crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-always">
<p class="crayon-plain-wrap"/>
<div class="crayon-main">
<pre><span class="crayon-e">import </span><span class="crayon-e">time</span>
<span class="crayon-e">import </span><span class="crayon-i">paho</span><span class="crayon-st">.</span><span class="crayon-i">mqtt</span><span class="crayon-st">.</span><span class="crayon-e">client </span><span class="crayon-e">as </span><span class="crayon-e">mqtt</span>
<span class="crayon-e">import </span><span class="crayon-i">RPi</span><span class="crayon-st">.</span><span class="crayon-e">GPIO </span><span class="crayon-e">as </span><span class="crayon-e">GPIO </span>
 
<span class="crayon-i">GPIO</span><span class="crayon-st">.</span><span class="crayon-e">setwarnings</span>(<span class="crayon-i">False</span>)
<span class="crayon-i">GPIO</span><span class="crayon-st">.</span><span class="crayon-e">setmode</span>(<span class="crayon-i">GPIO</span><span class="crayon-st">.</span><span class="crayon-i">BCM</span>)
<span class="crayon-i">GPIO</span><span class="crayon-st">.</span><span class="crayon-e">setup</span>(<span class="crayon-cn">27</span>,<span class="crayon-h"> </span><span class="crayon-i">GPIO</span><span class="crayon-st">.</span><span class="crayon-i">OUT</span>)
 
<span class="crayon-e">def </span><span class="crayon-e">on_connect</span>(<span class="crayon-i">client</span>,<span class="crayon-h"> </span><span class="crayon-i">userdata</span>,<span class="crayon-h"> </span><span class="crayon-i">rc</span>):
<span class="crayon-h">    </span><span class="crayon-e">print</span>
 
<span class="crayon-e">def </span><span class="crayon-e">on_message</span>(<span class="crayon-i">client</span>,<span class="crayon-h"> </span><span class="crayon-i">userdata</span>,<span class="crayon-h"> </span><span class="crayon-i">msg</span>):
<span class="crayon-h">    </span><span class="crayon-e">if </span><span class="crayon-e">str</span>(<span class="crayon-i">msg</span><span class="crayon-st">.</span><span class="crayon-i">payload</span>)<span class="crayon-h"> </span>==<span class="crayon-h"> </span><span class="crayon-s">"0"</span>:
<span class="crayon-h">         </span><span class="crayon-i">GPIO</span><span class="crayon-st">.</span><span class="crayon-e">output</span>(<span class="crayon-cn">27</span>,<span class="crayon-i">False</span>)
<span class="crayon-h">    </span><span class="crayon-e">elif </span><span class="crayon-e">str</span>(<span class="crayon-i">msg</span><span class="crayon-st">.</span><span class="crayon-i">payload</span>)<span class="crayon-h"> </span>==<span class="crayon-h"> </span><span class="crayon-s">"1"</span>:
<span class="crayon-h">         </span><span class="crayon-i">GPIO</span><span class="crayon-st">.</span><span class="crayon-e">output</span>(<span class="crayon-cn">27</span>,<span class="crayon-i">True</span>)
<span class="crayon-h"> </span><span class="crayon-i">time</span><span class="crayon-st">.</span><span class="crayon-e">sleep</span>(<span class="crayon-cn">1</span>)
<span class="crayon-h">         </span><span class="crayon-i">GPIO</span><span class="crayon-st">.</span><span class="crayon-e">output</span>(<span class="crayon-cn">27</span>,<span class="crayon-i">False</span>)
<span class="crayon-h">    </span><span class="crayon-i">else</span>:
<span class="crayon-h">         </span><span class="crayon-e">print</span>
<span class="crayon-e"> </span>
<span class="crayon-i">client</span><span class="crayon-h"> </span>=<span class="crayon-h"> </span><span class="crayon-i">mqtt</span><span class="crayon-st">.</span><span class="crayon-e">Client</span>()
<span class="crayon-i">client</span><span class="crayon-st">.</span><span class="crayon-e">connect</span>(<span class="crayon-s">"172.20.0.1"</span>,<span class="crayon-h"> </span><span class="crayon-cn">1883</span>,<span class="crayon-h"> </span><span class="crayon-cn">60</span>)
<span class="crayon-i">client</span><span class="crayon-st">.</span><span class="crayon-e">subscribe</span>(<span class="crayon-s">"mqtt"</span>)
 
<span class="crayon-i">client</span><span class="crayon-st">.</span><span class="crayon-i">on_connect</span><span class="crayon-h"> </span>=<span class="crayon-h"> </span><span class="crayon-e">on_connect</span>
<span class="crayon-i">client</span><span class="crayon-st">.</span><span class="crayon-i">on_message</span><span class="crayon-h"> </span>=<span class="crayon-h"> </span><span class="crayon-e">on_message</span>
 
<span class="crayon-i">client</span><span class="crayon-st">.</span><span class="crayon-e">loop_forever</span>()
</pre>
</div>
</div>

<p class="translated">首先是导入库。请注意，<a href="https://github.com/xtacocorex/CHIP_IO" class="ext-link" rel="external ">芯片</a>和<a href="https://pypi.python.org/pypi/RPi.GPIO" class="ext-link" rel="external ">树莓派</a>的GPIO库是不同的。不同的平台有多个库，尽管它们的功能都非常相似。选择一个，阅读文档，你应该可以让它工作。我认为不管平台如何，熟悉使用库的“过程”对于现成的黑客来说是一项非常有价值的技能。库是硬件行业在软件中整合功能的方式。</p>
<p class="translated">接下来，初始化GPIO引脚27以进行输出。此引脚连接到徽章臭氧管中的绿色LED。</p>
<p class="translated">然后我们定义一个小函数来检查MQTT消息中的“0”、“1”或其他值。如果它收到一个“0 ”,它关闭LED。“1”打开它，任何其他值都不打印，也不采取任何行动。</p>
<p class="translated">最后，我们连接到172.20.0.1上的mqtt代理，并无限循环，查找主题“MQTT”中的任何值。</p>
<p class="translated">在Pi上启动脚本，每次按下芯片上的微动开关时，您应该会看到绿色LED灯亮起。还要注意，我在代码中添加了几行代码，以便在一秒钟后自动关闭LED。如果你按下按钮，LED已经亮了，那就没什么用了。</p>
<h2 class="translated">后续步骤</h2>
<p class="translated">对于物理计算系统来说，能够同时在许多设备之间发送和接收消息是一种超级能力。我们已经看到了如何通过MQTT代理发布和订阅，以实际控制物理行为。</p>
<p class="translated">有了这个框架，下一步可能是探索控制电机，伺服，步进器和其他驱动器。我们能做到近乎实时的控制吗？谁知道呢。这个设置是否足够快，能够使用MQTT消息远程控制机器人？我也不知道那个。这会有任何应用或意义吗？</p>
<p class="translated">而且，我们甚至还没有谈到在联网的Linux笔记本电脑或Android superphone上面向MQTT的仪表板，以在我们的边缘设备上显示输入、趋势等。一条消息可以点亮一个LED，同时驱动桌面图上的一个数据点。</p>
<p class="translated">我们可以选择任何不同的方向。</p>
<p class="translated">您希望便携式无线数据中枢具备哪些功能和特性？我很想看看现成的黑客如何将这种物理计算堆栈技术应用到他们的项目中。</p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
<title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>

</div>
</div>    
</body>
</html>