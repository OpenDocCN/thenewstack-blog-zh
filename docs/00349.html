<html>
<head>
<title>F5 Networks: Containers Need Both Networking and Orchestration</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">F5网络:容器需要网络和协调</h1>
<blockquote>原文：<a href="https://thenewstack.io/f5-networks-containers-need-networking-orchestration/#0001-01-01">https://thenewstack.io/f5-networks-containers-need-networking-orchestration/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">


<p class="translated">我们试图将它描绘成职责和工作职能的结合，特别是当我们试图同时向两个客户群销售产品时:<a href="https://thenewstack.io/modern-business-devops-die/" class="local-link"> DevOps，开发和自动化的合并</a>。然而，有太多有意开发的技术来支持应用程序和网络之间的抽象层。最初，这些层应该将OSI堆栈第7层的应用程序开发人员从第2层或第3层所有肮脏的基础设施事务中解放出来。</p>
<p class="translated">随着容器化将可移植部署和分布式系统提升到同一个聚光灯下，结果可能是心态的冲突。舞台的一边是这样一种观点，即无服务器开发，开发者永远不会看到或关心底层基础设施，是真正的云原生的<a href="https://thenewstack.io/iron-io-brings-serverless-computing-cloud-foundry-platform/" class="local-link"/>。在舞台的同一侧为自己腾出空间是一个同样有效的论点，即你不能保护一个你不了解的网络。如果一个分布式系统应用程序，如他们所说，是一个网络，那就是一个问题。</p>
<p class="translated">F5 Networks的技术宣传员Lori MacVittie在谈到新的堆栈时表示:“在集群中，您必须拥有能够为客户端提供连接终端的设备。“一个虚拟服务、一个虚拟IP、一个虚拟服务器，在此之前—通过群集中该服务或应用程序的多个版本进行扩展。有些东西必须在前端提供这种功能，比如说，“嘿，我是你的应用程序，我将负责后端的伸缩。”无论解决方案是什么，它都必须能够自动更新正确的信息，因为手动流程在这里行不通。它必须与环境挂钩，并作为系统的一部分工作。"</p>
<h2 class="translated">查理检查站</h2>
<p class="translated">MacVittie与我们的讨论是通过F5周五向<a href="http://www.datacenterknowledge.com/archives/2016/11/15/f5-leverages-equinix-extend-deployment-security-microservices/" class="ext-link" rel="external ">介绍一个名为Container Connector的组件来进行的，该组件是F5去年11月开始构建的系统</a>，用于将微服务与现有网络集成。该系统始于Application Connector，该组件将基于云的应用与F5的Big-IP应用交付控制器相连接。这样做的目的是启用安全和防火墙策略，这些策略还管理对部署在云平台(包括公共云)上的本地应用程序的访问。</p>
<p class="translated">同时发布但通常在周五发布的Container Connector将同样的前提扩展到了微服务。它创建一个代理检查点，将整个微服务聚合作为一个实体，供任何服务或其他应用程序尝试与之通信。通过这种方式，可以实时监控和管理流量，并且可伸缩性可以以一种对<em>传入的请求是什么</em>以及有多少更敏感的方式发生。BIG-IP系统不是试图篡夺Kubernetes或Mesos，而是与指挥者和调度者一起工作。</p>
<p class="translated">“假设你有一个API，有一个服务器来处理它。一旦你添加了一个容器的第二个实例，”MacVittie解释道，“就必须提供一个端点来平衡[<em>服务</em>的负载。如果中间没有代理，就没有多少负载平衡。”</p>
<p class="translated">信不信由你，MacVittie令我惊讶地说，今天许多手机和平板电脑应用程序实际上把它处理请求的逻辑委托给了客户端应用程序。您的手机可能会根据对流量的评估来决定与哪个IP通话。如果你曾经和几十个人以及六个工作人员一起在邮局排队，你就会知道，每条线的长度从来都不是你可能在那里花费时间的一个好指标。想象一下，给定六个左右的IP地址，一个手机应用程序做出类似的决定，决定哪一个响应最快。</p>
<p class="translated">一些开发人员会说，所有事情都是随机的，这个方案将解决整个负载平衡问题。但它真正做的是把问题推到客户端，让应用程序对出现的流量模式完全负责。此外，MacVittie告诉我，应用程序开发人员试图通过创建一种外部注册表来解决这个问题——从字面上看，这是另一种服务的<em>，当一个队列被备份或另一个队列被清除时，它会通知他们。</em></p>
<p class="translated">在这样一个架构中，有一个观察者服务来报告随机分布的状态，引用伟大的乔·鲍勃·布里格斯的评论“任何人都可能在任何时候死去。”</p>
<p class="translated">“让你的客户决定应该选择15个不同实例中的哪一个是非常低效的，”MacVittie说，“当它真的不知道[<em>服务是如何</em>执行的，它有什么样的负载，或者它可能位于哪里。”</p>
<p class="translated">这可能是将开发和运营混为一谈的错误方式的终极例子。它还说明了抽象层的价值，即应用程序的工作方式应该比应用程序的工作方式少一个或多个步骤。</p>
<h2 class="translated">平衡平衡器</h2>
<p class="translated">MacVittie解释说，Container Connector监视一个活动的服务器集群是否有被扩展的迹象，以及新的实例何时上线。然后，CC通知F5的Big-IP控制器，以便它可以通过从应用安全策略的地址池中注册新实例(或删除旧的和不用的实例)来做出响应。应用服务代理——该方案中的另一个组件——管理实例之间和实例之间的网络路由。例如，该特定代理使得实例化的容器更容易从池中移除，而这些容器实际上并没有被使用。</p>
<p class="translated">MacVittie说，Big-IP可以与现有的负载平衡器一起工作，包括NGINX、HAProxy和Kubernetes的本地kube-proxy。“我们坐在入口处，我们看到容器里的那些解决方案，”她告诉我们。“进行东/西负载平衡。因为都是基于协议的，所以我们很容易与他们合作。我确实看到了许多以F5为入口的架构，还有其他所有这些负载平衡器。当然，我们更希望您使用F5，但我们并不要求您这样做。因为它都是基于标准的，所以我们将能够对您在环境中可能使用的任何东西进行负载平衡。”</p>
<p class="translated">更广泛地说，Big-IP系统正在完成<em>运营</em>部分的工作。正如麦克维蒂毫不犹豫地承认的那样，系统操作员更有能力处理这项工作。预定义的模板有助于解决如何响应orchestrator或scheduler触发的事件的问题。例如，一个这样的模板可以为仅供内部使用的服务建立HTTP 1.1连接，同时为面向公众的网关建立HTTP/2连接。其他人设置基本的web应用程序防火墙(WAF)策略，为跨站点脚本(XSS)事件或SQL注入尝试发送标志。另一种方法可以清除传出数据中可能出现的信用卡号或社会保险号。</p>
<p class="translated">“开发人员没有理由不使用[<em>这些模板</em>]，”她说，“但在我看来，它似乎更适合运营人员。”</p>
<h2 class="translated">交钥匙的光环</h2>
<p class="translated">F5的价值主张基于一种非常实用的方法来管理虚拟网络并维护其与物理网络的连接。VMware一直认为，维护它在虚拟机管理程序和处理器之间建立的网络安全基础对于构建未来的新应用程序至关重要，即使并非所有这些应用程序都需要虚拟机管理程序。这就是为什么许多企业坚持使用他们现有的虚拟化层，而不是转向他们不知道的其他虚拟化层。</p>
<p class="translated">Docker Inc .最近发展了其安全论点，称集装箱安全可能几乎完全在交付过程中实现，或者用上周DockerCon期间首席执行官Ben Golub从早期借用的短语“供应链”。</p>
<p class="translated">“安全的基础是开始，但不是结束，”Golub说。“我们需要以某种方式取代所有那些口香糖、唾沫、铁丝网、诅咒等等。，看起来有点像供应链。去年，我们引入了CaaS的概念——容器即服务。这基本上就是说，我们希望拥有适当的工具和流程，以将已构建为容器的应用程序部署为容器，但要有一种方法来连接开发人员和IT运营部门，其中包括安全映像注册等技术，以及一个允许您在异构环境中监控、管理和部署容器的控制平面。”</p>
<p class="translated">Golub认为，服务之间如何建立连接的规范应该位于与Docker的CaaS模型完全不同的层次上，即他所描述的IaaS和PaaS层次。“IaaS很好，PaaS也很好，”他指出，“但要确保你在经历这个过程时，不要最终让你的-aaS陷入困境。”</p>
<p class="translated">F5的反驳观点似乎是，新的分布式系统架构需要一种新的网络安全方法，这种方法至少与旧方法一样有效，甚至更有效。微服务架构的模糊、奇怪的不确定性不会长久地充当它的安全毯。</p>
<p class="translated">IBM将是第一批支持F5论点的公司之一。</p>
<p class="translated">IBM杰出的软件工程师Andre Tost在最近的一次采访中表示:“我认为，常规的、基于中间件的企业应用程序，为了使它们支持微服务，需要对它们进行改变。“你需要重构它们。有工作要做。我们发现很多很多公司没有时间、精力、资金、动力或激励去做这些事情。它不是说，“我有一个一致的企业架构，并希望我的所有应用程序都属于这一类别。”我只是觉得不太现实。"</p>
<p class="translated">F5的Lori MacVittie并非没有意识到商业因素，例如，<a href="https://thenewstack.io/docker-ceo-integrating-old-apps-big-deal/" class="local-link"> Docker Inc .新推出的一键式整体集装箱化</a>，对首席信息官们极具吸引力。</p>
<p class="translated">“作为一名非常年轻的开发人员，”她告诉New Stack，“我一直对我工作的大型企业拒绝重新架构和现代化感到非常沮丧。为什么我们会有这些东西？这太荒谬了！随着时间的推移，我了解到有业务原因和财务原因，实际上重新架构的成本可能会如此巨大，以至于它不会发生。投资回报从来没有回报。她引用了一个案例研究，在这个案例中，澳大利亚的一家银行铤而走险，对其基于大型机的旧业务逻辑进行了全面的重新架构，最终花费了7.5亿美元。</p>
<p class="translated">“你可以将一个应用程序封装在Docker容器中，然后通过简单地启动多个容器，在前面放置一个代理，并让它根据需要进行扩展，从而获得性能提升和更无摩擦的扩展，这种想法对许多组织来说可能非常有吸引力，”她继续说道，并指出调查表明，企业被这种方法提供的即时可移植性所吸引，让他们可以将应用程序“提升并运送”到公共云中。</p>
<p class="translated">然后她承认，这种交钥匙功能中的一些可能会集成到F5的Big-IP等系统中。毕竟，这将是思维方式的融合——只是不是我们想象的那两种。</p>
<p class="attribution translated">标题图片<a href="http://collection.sciencemuseum.org.uk/objects/co8347377/three-switchboard-operators-breastplate-transmitters-and-headsets-1925-1960-headset" class="ext-link" rel="external ">一个老式的英国电话交换总机</a>大约1925-1960年，来自英国科学博物馆，在知识共享4.0下获得许可。</p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
<title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>

</div>
</div>    
</body>
</html>