# Redis:概率数据结构如何支持最先进的应用

> 原文：<https://thenewstack.io/redis-how-probabilistic-data-structures-support-state-of-the-art-apps/>

[](https://redis.com/)

 [洛里斯·克罗

洛里斯在米兰学习生物信息学，并参加了 2014 年的谷歌代码之夏，在那里他开发了利用 NoSQL 数据库支持下一代测序数据分析的工具。之后，他在一个犯罪学研究中心工作了一年，担任数据工程师。最近，他转到了后端开发人员的职位，在那里他利用以前的经验，使用 Go 和 Redis 构建高性能服务。](https://redis.com/) [](https://redis.com/)

正确的架构设计和强大的开发过程对于编写可伸缩的、有效的应用程序至关重要。然而，为了构建最先进的解决方案，另一个基本实践是正确使用数据结构。流行的开源数据库 Redis 提供了多样化和可扩展的数据类型工具箱，包括工程师工具箱中一些最锋利的工具:概率数据结构。

概率数据结构都通过利用其独特的属性来解决非常具体的问题，但是它们都有两个共同的特征，这是任何体系结构或过程复杂性都无法弥补的。它们速度很快，内存需求极低。因此，您可以使用它们来跟踪数十亿个项目，既经济又简单。

大型企业的任何领域都可以受益于概率数据结构。例如，在接受客户订单之前，运输部门可能需要立即知道某些商品是否缺货；市场营销可能需要一个显示各种用户群总数的实时仪表板，而工程可能需要一种快速的方法来丢弃来自不良客户的请求。这些只是概率数据结构可以大大提高效率的几种情况。

在本文中，我们将介绍三种概率数据结构，它们解决了大型数据集的两个常见用例:1)跟踪集合基数，2)测试集合成员资格。

## 快速概率数据结构初级读本

在讨论这些具体的用例之前，让我们先来探讨一下概率数据结构的一些反直觉的性质。

*   这些数据结构的行为强烈依赖于散列函数，有时是随机性的来源。哈希在存储不同分布的数据时具有更大的灵活性，通常会提高效率。不幸的是，这也使得行为更难预测。
*   概率数据结构不存储整个项目，所以您不能使用它们来检索您之前添加的项目。这也意味着(与您对非概率数据结构的期望相反)概率数据结构可以在给定的空间内存储更大的数据量。这是因为它们只存储解决特定问题所需的最少量的数据(例如计数或集合成员)。
*   最后，值得注意的是概率数据结构给你一个模糊的数据视图。因此，计数不会精确到一个单元，集合成员测试可能会给出错误的答案。虽然不是最佳的，但这不是一个问题，因为这些错误率具有特定的结构，可以量化，也可以通过调整一些参数来调整。当您更关心速度或低内存占用而不是精确定位时，概率数据结构非常有用。当您确实需要完全正确时，您总是可以与传统的数据结构配对，并使用概率数据结构作为优化层。

有了这本书，我们将深入研究三种强大的数据结构的真实例子:超对数、布鲁姆过滤器和布谷鸟过滤器。

## 集合基数的超对数

当有大量用户与更大的项目集进行交互，并且希望记录这些交互时，HyperLogLog 是一个很好的数据结构。此外，这种数据类型可以记录各种集合，并快速计算它们的并集或交集的基数。是 Redis 内置的，可以马上用。每个计数器占用 12 千字节的内存，有 0.81%的标准误差，并且可以计算几乎无限量的唯一项目(2^64).

**例子**:

*   YouTube、Reddit、亚马逊视图
*   用户组的有效联合/交叉

### 基本用法

创建一个新的计数器就像添加第一个项目一样简单。如果密钥不存在，Redis 将为您创建一个。指挥结构如下:

### 计算独特视图

比方说，你想保持一个独特的视频观看计数。要将用户 01 的视图添加到视频 42，请使用:

这将创建一个以包含事件 user01 的视频命名的键。要获得一个项目的唯一视图计数，请使用:

这将返回之前添加的唯一元素的总量。因为我们通过用户 id 来识别每个事件，所以同一用户的多个视图只被计算一次。

### 每天不同的视图

如果您对惟一性的定义更加细致，您只需要将所有相关信息打包到标识每个视图事件的字符串中。假设您希望将随后几天发生的视图视为不同的视图，即使它们来自同一个用户。在这种情况下，您的命令结构可能是:

```
PFADD video42 user01:2018-08-22

```

这样，user01:2018-08-22 和 user01:2018-08-23 将算作两个单独的事件。另一种方法是每天创建不同的计数器:

```
PFADD video42:2018-08-22  user01

```

注意日期是如何从每个项目的一部分变成关键字的一部分的。使用这种方法，您可以轻松地绘制直方图，但是要注意，您将为每天创建一个新的计数器。要获得多天内的总视图计数，可以通过调用每个计数器上的 PFCOUNT 对结果求和。如果你还想知道唯一用户的总浏览量，你可以使用:

```
PFCOUNT video42:2018-08-22  video42:2018-08-23

```

这个调用返回所有给定计数器的并集的基数。因为我们只通过用户 id 存储每个视图事件，所以这个计数将对应于我们的第一个惟一性定义。

### 合并计数器

您还可以将多个计数器合并为一个，这对于跟踪多个级别的粒度和转出旧的计数都很有用。例如:

```
PFMERGE video42:2018-08  video42:2018-08-22  video42:2018-08-23  ...

```

这个调用将在 video42:2018-08 中存储所有给定集合的并集。压缩较旧的指标可以让您将历史数据保存在手边，同时仍然将大部分内存分配给最近的事件。我们所有的例子都是关于按日期对数据进行切片，但同样的概念可以应用于任何其他维度，如类别、视频长度、年龄范围等。

### 进一步阅读

*   HyperLogLog 命令的完整列表可以在 Redis 官方网站[上找到。](https://redis.io/)
*   Reddit 的高级软件工程师 Krishnan Chandra 写了[一篇有趣的博文](https://redditblog.com/2017/05/24/view-counting-at-reddit/)，讲述了他们如何使用 Redis 的超对数计数器计算访问量，重点是架构方面。

## 集合成员的布隆过滤器

布隆过滤器是概率数据结构中最具代表性的类型，并且在广泛的应用中使用。数据库、网络设备甚至加密货币都广泛使用布鲁姆过滤器来加速内部操作。客户端可以向服务查询是/否答案，并有效地缓存这些答案。这种数据结构可以作为一个名为 [ReBloom](https://oss.redis.com/rebloom/) 的 Redis 模块使用，它允许您测试一个项目是否是一个大集合的一部分，而不必将整个集合保存在内存中。

值得注意的是，您可以指定 0%到 100%之间的假阳性错误概率(不包括极端情况)，并避免假阴性。关于 Bloom Filters，要记住的最重要的事情是否定答案的错误概率为零。换句话说，布隆过滤器总是回答“可能是”或“肯定不是”

使用 ReBloom 时，空间使用与目标错误率成反比。

此外，ReBloom 支持增长过滤器，这允许您为每个过滤器动态分配内存。这对于没有“一刀切”解决方案的情况非常有用(例如，跟踪社交网络中的关系，这遵循[幂律分布](https://en.wikipedia.org/wiki/Power_law#Power-law_probability_distributions))。虽然过滤器会自动增长，但为了确保最佳的空间和 CPU 效率，当您有一个已知的近似集合大小时，尽可能准确地分配是很重要的。

要了解如何将 ReBloom 这样的模块加载到 Redis 中，请参考[Redis 官方文档](https://redis.io/) [n](https://redis.io/) 。

**举例**:

*   检查用户名的可用性
*   欺诈检测和缓解某些类型的网络攻击
*   跟踪已知 URL 的网络爬虫

### 基本用法

一旦你加载了 ReBloom 模块，添加一个项目到一个不存在的键将会为你无缝地创建它:

如果你想指定更多的选项，你可以使用:

```
BF.RESERVE  <key>;  <error_rate>;  <size>;

```

这将创建一个名为<键>的过滤器，该过滤器最多可容纳<大小的>项，目标错误率为< error_rate >。一旦你溢出了你最初的<大小>估计，过滤器将自动增长。

### 抓取网址不超过一次

假设您正在运行一个网络爬虫，并且希望确保您不会在每次遇到一个已知的 URL 时都不停地爬行。

只要你在一个域中爬行，保存一个所有已知 URL 的列表可能不成问题。然而，在这个范围和 Google 规模之间的某个地方，你可能会开始浪费太多的资源来更新和读取这个列表(它甚至可能不再适合内存)。

同样的问题可以用布隆过滤器来解决，例如:

```
BF.ADD crawled  "redis.io/documentation"

```

要测试一个 URL 是否已经被抓取，您可以使用:

```
BF.EXISTS crawled  "redis.io/maybe-new-url"

```

回复将是:

*   **0** (肯定没有):这是新网址，可以抓取；或者
*   **1** (可能是):这很可能是一个已知的 URL。

在积极的情况下，是接受跳过一些 URL 并继续前进的可能性很小，还是在系统中跟踪这些 URL，您可以查询这些 URL 以获得精确但较慢的答案，这取决于您。

### 布隆过滤器需要多大的空间？

一个大小为 100 兆字节的过滤器可以容纳多达 1 亿个独特的项目，误差率为 2 %,误差率为 2%。

在官方文档的[中可以找到 ReBloom 命令的完整列表。在网上，你可以找到许多帮助计算布隆过滤器存储需求的网站(比如这个](https://oss.redis.com/rebloom/)[交互式可视计算器](https://hur.st/bloomfilter/))。比特币还实施了一项提议，使用布隆过滤器来优化和隐藏客户端通信。

## 当花开不够:布谷鸟过滤器

Bloom Filters 是一种令人惊叹的、经过时间考验的数据结构，可以满足大多数需求，但它们并不完美。他们最大的缺陷是不能删除项目。由于数据存储在过滤器中的方式，一旦添加了一个项目，就不可能将其与其他项目完全分开。这使得删除不可能不引入新的错误。

或者，布谷鸟过滤器提供了一个更新的概率数据结构。这种方法存储信息的方式不同，导致性能特征和在需要时删除项目的能力略有不同。

### 在以下方面，布谷鸟过滤器优于布鲁姆过滤器:

*   删除项目
*   更快的查找(因为更好的内存局部性)
*   空间效率(当目标错误率低于 3%时)
*   更快的插入(当过滤器处于 80%的填充率时)

### 在以下情况下，布谷鸟过滤器比布鲁姆过滤器更差:

*   你的填充率超过了 80 %;在这种情况下，布谷鸟过滤器的插入速度很快下降到布鲁姆的速度以下。
*   您有更宽松的目标错误率(大于 3%)，使布谷鸟过滤器空间效率更低
*   您需要高度可预测的行为(因为布谷鸟滤波器在插入过程中使用随机性来源来提高性能)

### 基本用法

布谷鸟滤镜也出现在 ReBloom 中，使用方式与使用 Bloom 完全相同。唯一的区别是命令前缀是 CF 而不是 BF，并且您有了一个新的删除命令:

就这样。其他一切都可以用与布隆过滤器相同的方式建模。

在我们之前的例子(web 爬行)中，我们不需要该功能来正确地对不断增长的爬行 URL 列表进行建模。但是现在，我们可以在项目可能从集合中移除的情况下解决问题。例如，在收到客户的发货订单时，预先检查库存可用性。

命令的完整列表可在 [ReBloom 的文档](https://oss.redis.com/rebloom/)中找到。这种数据结构首次出现在“[布谷鸟过滤器:实际上比布鲁姆更好。](https://www.cs.cmu.edu/~dga/papers/cuckoo-conext2014.pdf)

## 结论

概率数据结构优雅地解决了许多类型的问题，否则这些问题需要更多的计算能力、成本和开发工作。在本文中，我们介绍了三种有用的概率数据结构:

*   HyperLogLog(包含在 Redis 中)对集合中的元素进行计数。
*   布隆过滤器(在 ReBloom 中可用)用于跟踪集合中存在或缺少的元素。
*   布谷鸟过滤器(ReBloom 中可用)可以像 Bloom 一样跟踪元素，但是具有从集合中删除元素的附加功能。

虽然这些是最著名的，但这并不是一个完整的列表，我们完全期待未来会发明新的概率数据结构，就像 2014 年提出的布谷鸟过滤器一样。因此，关注新的 Redis 模块是值得的，因为它们可能以意想不到的有效方式解决问题。

通过 Pixabay 的特征图像。

<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 68 31" version="1.1"><title>Group</title> <desc>Created with Sketch.</desc></svg>