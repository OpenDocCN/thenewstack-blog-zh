# 流程等式(节奏就是一切，第 2 部分)

> 原文：<https://thenewstack.io/the-process-equation-cadence-is-everything-part-2/>

在本系列的第一部分中，我们看到了高迭代率——或者说高节奏——是如何被用来取得非凡成就的，甚至是在航空航天领域，那里的失败成本比软件领域要高得多，也更容易燃烧。

在很大程度上决定太空飞行可能性的一个方面是火箭方程，这是不可阻挡的:任何你想带入轨道的额外重量都需要更多的燃料，这本身就是更多的重量，这需要更多的燃料，这就是更多的重量，等等。

周期时间和开销在一个类似的正反馈循环中表现，尽管有负面影响:当开销增加时，总是对开发人员施加压力，增加他们的批量大小并控制相对开销，这导致更长的周期时间，这导致更多的开销，从而给开发人员造成更大的压力，等等。

解决方案是关注等式的另一面:疯狂地优先去除过程开销，并确保我们的反馈循环有效。这听起来没有争议，也很容易:我们都同意浪费是不好的，所以让我们消除它！

然而，事实证明，干扰高[节奏](https://thenewstack.io/kelsey-hightower-on-software-minimalism-and-js-frameworks/)的不仅仅是那些我们明显认为是浪费的东西，还有那些我们认为是重要的，甚至是对产生好作品至关重要的东西。关键是在这些情况下也要优先考虑节奏，这是非常困难的。当这些问题发生冲突时，我们要么需要做出艰难的选择来消除它们以支持节奏，要么找到创造性的方法使它们不影响节奏。

这是真正的敏捷。这是非常有效的，如果做对了，可以感觉几乎毫不费力，尽管事实上到达那里可能很难。另一方面，“敏捷”和它的仪式大多是容易的，但充其量也是无用的。

## **传统 QA**

在传统的[质量保证](https://thenewstack.io/traditional-quality-assurance-is-dead-and-why-thats-a-good-thing/)思维模式中，产品开发生产……嗯，*一些东西*，然后 QA 确保产品具有可以交付的所需特性；它确保产品实际上是它应该是的产品。因此质量保证。给予这种保证所需的信心需要一个详尽的测试周期，通常包括手动元素。

这是好事。

然而，它也将软件开发组织推向更长的迭代，因为 QA 周期需要一定的最小时间量，所以您可能不能也肯定不想为了一行代码的更改而运行它。(也许你是这样，因为在 1990 年，由于一行代码，他们的电话网络发生了灾难性的故障，这让[在&T](https://users.csc.calpoly.edu/~jdalbey/SWE/Papers/att_collapse)付出了巨大的代价。因此，开发人员将会有动力增加代码变更的批量。更大的批量，反过来，增加了未被发现的问题的可能性，因此降低了确定性，增加了全面质量保证的需要，达到了我们的正反馈循环越来越长的周期时间。

摆脱这种恶性循环的关键是利用相同的动态，只是相反，通过使批量大小尽可能小，并接受 QA 实际上不能*保证*质量的事实(上面提到的导致电话网络瘫痪的代码更改经历了一个彻底的 QA 周期)。它所能做的就是增加我们对即将发布的代码的信心。

小批量肯定有助于增加我们的信心:在极限情况下，如果批量是空的，我们非常确定软件将继续像以前一样工作。变化越小越频繁，任何一个变化产生不可预见的负面影响的机会就越小。首先，变化很小。其次，较小的变化更容易评估。最后但同样重要的是，更高的频率也意味着我们做得更频繁，因此做得更好。

为了使小批量与 QA 一起工作，您需要有自动化测试，最好安排在众所周知的测试层次结构中。传统 QA 的功能不再是测试产品，而是验证自动化测试并锚定一组嵌套的测试反馈循环。

单元测试运行得很快，并且不断地检查产品，理想的情况是每次构建都要检查，但是当然是每次签入都要检查。长期运行的集成测试和自动化 UI 测试检查单元测试的质量。如果他们发现了单元测试遗漏的问题，单元测试必须更新。最后，人工 QA 是定期检查测试套件没有遗漏任何东西的后盾。

## **快速测试**

快速测试是实现高节奏和勇气的主要驱动力之一，它允许你冒更大的风险，将我们在以前的迭代中学到的东西付诸实践。一旦你所有的测试都通过了，你就可以签入你的代码，从而完成一次迭代，并得到一些反馈，告诉你你实际上已经完成了一些事情，并且没有退步。

理想情况下，测试足够快，你可以一次一个测试地进行测试驱动开发(TDD)循环:编写测试(红色)，通过测试(绿色)，重构(保持绿色)检入。

这可能是我们在软件中可以合理达到的最快迭代速度。

但是如果你所有的测试都没有这么快呢？您仍然可以做到这一点，首先，确保将您的测试分成本地化的快速单元测试，以及检查更大系统的验收和/或集成测试。然后，您可以只将单元测试视为阻塞，并将更大的测试套件用作异步信号。

这意味着如果失败了，您可能不得不返回并恢复(或修复)您不久前所做的更改，但是只要这种类型的测试失败很少发生——通常都是这样——这种权衡是值得的。

这里需要注意的是，有趣的情况是[测试失败](https://thenewstack.io/surprise-software-testing-is-every-developers-job-now/)，而不是测试通过。除了您当前试图使之为绿色的测试之外，所有的测试本质上都应该是绿色的，如果不是，您需要修复它。

记住这一点，很明显，我们可以加速我们需要的来自更大的测试套件的信号，而不必加速测试套件本身:简单地首先运行失败的测试！

当然，为此我们必须知道什么样的测试会失败，而预测是困难的，尤其是对未来的预测，我们无法知道会是什么样的测试。然而，有一些技术可以找出哪些测试最有可能失败，并首先运行这些测试。

在 GitLab，我们一直在使用[故障快速测试](https://docs.gitlab.com/ee/ci/testing/fail_fast_testing.html#fail-fast-testing)来做这件事，我们也向我们的优质客户推出了这一功能。此外，您可以使用蛮力来并行运行测试。(你的测试*是*独立的，对吗？)

## **合并请求和异步反馈**

让潜在的慢反馈变得非常快或者异步的想法也适用于代码评审。合并请求(MRs)，也称为拉请求，是当今业界普遍采用的方法，但这并不是一个好主意。

[https://www.youtube.com/embed/ASOSEiJCyEM?feature=oembed](https://www.youtube.com/embed/ASOSEiJCyEM?feature=oembed)

视频

原因是拉请求需要等待其他开发人员离开他们当前的任务，进入您的变更的环境，尝试检查它们，留下有意义的反馈，然后您必须合并反馈，重新开始循环，等等。同时还要照顾其他开发者的 PRs。

为了一两行代码的修改而定期经历这个过程显然是疯狂的，而且可能会让你在同事中很不受欢迎。因此，开发人员有强烈的动机使他们的 MRs 更大，这既是为了证明这种开销的合理性，也是为了顾及他们同事的时间和精力。

但是，当然，更大的 PRs 更难审查，所以它们不仅需要更多的时间，还会产生更大的不情愿来转换焦点，进一步增加周期时间，所以我们回到了负面后果的正反馈循环中。

PRs 来自开源世界，在那里未知的合作者可能会发送需要仔细检查的补丁，至少因为参与者之间没有信任关系，并且默认情况下通信是非常异步和分布式的。在高度信任的环境中，这样的防御机制实际上没有意义，特别是当增加了强制审查要求的自动检查时。

相反，代码审查可以通过配对完全同步地完成，类似于快速单元测试提供的有希望的即时反馈。或者，默认情况下，代码评审可以异步执行，评审在代码签入后进行。

在大多数情况下，这种审查不应该发现任何必须消除的障碍，而是可以方便地添加的改进建议。如果这不是正常的情况，如果大多数变更引入了如此严重的问题，以至于它们应该被推迟，那么可能有严重的团队问题需要解决。

## **传统的产品管理和设计流程**

已经走了这么远，你不希望这些毫发无损？如果你的产品管理定义了规格，并把它们交给设计人员，为工程实现创建完美的模型，你就不能以高节奏进行迭代开发。这个过程有一个很长的前置时间，没有任何反馈周期，因此没有从迭代中得到的复合改进。

> 产品、设计和工程需要在实际的产品上一起迭代…所以你需要让*的东西*快速出来，一些没有完成的东西。

迭代是为了*发现*正确的规格和最好的设计，为过程带来真实世界的反馈。认为自己能够在没有反馈的情况下完成这项工作是狂妄自大。它们不是为了更快地实现规范，将一个任务分割成不同的包不是迭代。

产品、设计和工程需要在实际产品上一起迭代。这样，规格、设计和最终产品都受益于真实世界的反馈，而不是人们的想象。为了让这样的反馈收集成为可能，必须有一个初始的产品来迭代，所以你需要很快地得到*一些*的东西，一些还没有完成、没有润色、没有完成的东西。

希望每个人都抵制这一点。工程师们想要的是他们能够实施并完成的特别的标签和设计。设计师希望提供像素级的完美设计。产品经理希望在开始之前就能控制最终的结果，以便与路线图保持一致。

## **总是改变一个运行系统，牛仔**

可能在没有完全理解的情况下，匆忙地编写代码——这难道不是可怕的牛仔程序员心态吗？是的，但同时，它也是高度自律和有效的敏捷方法的基石。怎么可能两者兼得？

到目前为止所描述的所有精简都是为了实现快速迭代，在收集和整合早期尝试的反馈的同时设计和构建解决方案，就像 MacGready 对 Gossamer Condor 和 SpaceX 对 Raptor 引擎和 Starship 所做的那样。如果处理得当，它显然会带来令人印象深刻、近乎神奇的结果。

然而，过早地进行编码也会导致快速交付、不可维护和几乎不起作用的混乱，也就是牛仔编码。结果如何很大程度上取决于使用这种能力进行实际迭代的意愿。可能这最大的敌人是“永远不要改变一个正在运行的系统”的心态，这种心态在敏捷环境中是绝对致命的。

你想要的几乎是相反的:我们不仅应该尽早拥有一个运行系统，然后根据环境的反馈进行修改，而且在没有一个能够提供这种反馈的运行系统的情况下进行修改也是非常不鼓励的。

## **保持跟踪**

你怎么知道自己过得怎么样？如果你做得非常好，你会知道，因为你甚至不需要测量周期时间；它们几乎是瞬间完成的。对于我们这些仍在努力变得更好的人来说，你可以尝试使用上一期文章中讨论的[多拉指标](https://cloud.google.com/blog/products/devops-sre/using-the-four-keys-to-measure-your-devops-performance)。GitLab 提供了一个 [API](https://docs.gitlab.com/ee/api/dora/metrics.html#devops-research-and-assessment-dora-key-metrics-api) 来自动跟踪这些，并帮助你[变得更好](https://about.gitlab.com/blog/2022/01/24/how-zoopla-uses-dora-metrics-and-your-team-can-too/)。

## **结论:不只是让你的 10 倍的人快乐！**

跟踪你成功的另一个方法是看看你的 10 倍开发人员是否快乐，因为她比其他人更能感受到进程开销的影响。原因很简单:比方说，对于像你和我这样的普通开发人员来说，我们有代表 50%开销的过程。对于一个需要两个小时编码的示例任务，这将是一个小时的开销，也就是所花时间的三分之一。

另一方面，10 倍的开发人员将在 12 分钟内完成编码，但是开销仍然保持在 1 小时。对他们来说，过程开销是实际有用工作的五倍，这是一种徒劳和沮丧的练习。你的开发人员越多产，缓慢的过程就越令人沮丧，你就越有可能失去他们，不管 10x 开发人员是否存在。

从你的过程中减肥是简单的，但是像大多数简化一样，这可能非常困难。就像火箭中的设备一样，聪明人出于一个好的理由把每一个过程都放在那里。但是，就像火箭一样，创造性的解决方案是可能的，这些解决方案会让你从一个开销越来越大的正反馈循环，变成一个重量更轻、生产率更高的正反馈循环，其中包含越来越紧密的反馈循环，从而改进你的产品。尝试一下，看着你的组织腾飞吧！

<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 68 31" version="1.1"><title>Group</title> <desc>Created with Sketch.</desc></svg>