# 动态日志记录如何减轻开发人员和您的钱包的压力

> 原文：<https://thenewstack.io/how-dynamic-logging-saves-strain-on-developers-and-your-wallet/>

在一个完美的世界里，开发人员会把所有的时间花在编写创造性的、有价值的代码上，这些代码有助于开发有意义的软件。

然而，实际上，开发人员在非功能性需求上花费了大量时间。其中最主要的是应用程序工具——应用程序中监控或测量其性能的那些方面(最常见的是日志，但也包括指标和跟踪)。

应用程序插装是一种“以防万一”的措施。这是一种安全预防措施，工程组织围绕这一措施制定命令，以确保底层系统在生产中是可靠的。根据定义，它不是面向客户的增值。

当前的插装方法，我们称之为“静态插装”，仅在编译时(开发中)将分析代码插入到应用程序中，这有很大的局限性:

*   **耗时** —开发人员可能会花费大量时间编写工具，等待应用程序重新部署，并从结果中筛选他们需要的信息。
*   ****降低生产力—**** 每当开发人员想要添加新的工具时，他们需要将上下文切换出他们的代码并进入他们的工具，打断他们的流程并分散他们核心任务的注意力。
*   **成本高昂** —接收、管理和存储所有仪器所需的工具成本会迅速增加。

一种新的方法正在出现:生产系统中的动态仪器*。*

动态插装允许开发人员在运行时“动态地”添加插装——当应用程序正在运行时——这具有弥补静态插装的许多限制的巨大潜力。

本文将通过静态日志记录的例子来探讨静态插装的局限性，然后探讨生产系统中的动态插装如何能够降低复杂性、提高生产率并降低静态插装的成本。

## **静态仪器的限制:看看测井记录**

伐木是不可避免的罪恶。

如果记录的代码是好的，那么编写这些日志并重新部署应用程序将被证明是浪费时间。然而，如果开发人员忽略了正确地记录日志，那么在应用程序执行过程中出现的任何错误都将很难修复。

因此，许多开发人员倾向于过度记录他们的应用程序，以应对任何可能发生的情况。这增加了筛选这些日志以大海捞针的复杂性，并带来了应用性能管理(APM)许可证和其他与可观察性相关的成本。

为什么开发者日志这么多？

乍一看，记录这么多日志的原因是显而易见的:如果应用程序没有包含足够的日志，我们在解决棘手问题时就会缺乏粒度。

但这只是这里更大问题的一部分:日志工作流作为一个整体被破坏了。值得注意的是，传统的静态测井带有 it⁠的许多关键限制:

1.  **日志只能在开发过程中添加** —由于日志只能在编写应用程序时添加到应用程序中，因此由开发人员决定以后需要哪些数据(即在测试和生产环境中)。如果以后需要添加更多的日志，开发人员将需要经历一个完整的发布周期。这造成了在第一个实例中使用大量日志的倾向，以确保为每一个可能的意外事件都有日志记录。
2.  **日志不能提前添加，对于每个场景** ***—*** 一个明智的系统架构师知道必须在系统性能和日志覆盖率之间取得平衡。如果开发人员没有记录足够的信息，就不可能可靠地知道系统内部发生了什么；它会是一个黑匣子。向每一行代码添加日志也是不切实际的，因为这会严重影响系统性能，并导致遥测比功能本身花费更多的 CPU 周期。
3.  **没有办法预先知道所需的粒度** —即使有大规模的日志覆盖，也不可能可靠地考虑所有可能的未知因素。当问题不可避免地发生时，对所需数据的预先“猜测”很少是绝对正确的。

以上三点为大多数现代应用程序中的日志状态描绘了一幅可怕的画面:如果你不日志，你就不会知道。这意味着开发人员总是编写比可能需要的更多的日志，然后在原始日志没有正确放置或者没有提供缓解问题所需的深度时添加更多的日志。

当唯一的武器是添加更多的日志时，日志量可能会快速增长，而组织不会关注它们*。*许多公司——尤其是以数据为中心、交易量大的公司，如电子商务网站或金融机构——每天都在生成数百 TB 的日志数据，以确保其系统具有足够的可观察性。

## **静态仪器的局限性越来越严重**

随着云原生技术越来越多地成为新应用的默认技术，情况似乎只会变得更糟。应用程序的底层组件变得越来越抽象和复杂，这使得在出现问题时对这些应用程序进行故障排除变得前所未有的困难。

正如读者现在可能已经猜到的，解决方案是添加更多的日志。

在这些日志中，99.9%永远不会被查看或分析。它们的存在仅仅是为了抵御在没有足够遥测技术的情况下，不得不忍受生产事故所带来的痛苦恐惧感。

此外，随着日志量的激增以应对应用程序日益增长的复杂性，成本也随之攀升。

## **伐木成本**

日志记录的成本主要来自我们用来收集和分析应用程序日志的软件。

这些软件通常被称为 APM 和集中日志解决方案，按量收费。具体来说，他们对这些日志的摄取、存储和处理收费。随着应用程序发出的日志量不断增加，使用这些平台的成本也在增加。

此外，这些不仅是前期的已知成本。随着应用程序规模的增长，日志量也会同步增长。如果最初没有考虑这些成本(很少考虑)，组织最终不得不使用现收现付的计费结构来购买额外排放日志的覆盖范围，这大大增加了最终的账单。

同时，许可费(席位、主持人等。)因为这些软件包也不便宜。这些公司知道，在日志记录和可观察性供应商之间迁移是很棘手的，投资于一个平台的工程组织很难在没有充分理由的情况下转移到另一个供应商。这种供应商锁定也带来了降低成本上升的实际问题。

(顺便说一句，如果你想了解与静态测井相关的实际经济成本以及来自动态仪器的成本降低，你可以[查看我们关于这个主题的研究](https://go.lightrun.com/lightruns-impact-on-enterprise-logging-costs-study))。

## **进入:动态测井**

在复杂的应用程序中，可能很难确定应用程序的哪个部分生成的日志最多，因此成本最高。在实践中，以任何有意义的方式优化应用程序日志，同时仍然保持足够的日志覆盖率是一个挑战。

开发人员发现自己陷入了进退两难的境地:APM 不利的定价模式，以及他们需要尽可能多地记录以在事故期间获得清晰的视图。

组织是否应该最小化日志记录——以及通过代理最小化系统的可观察性——以保持低成本和高速度？或者，相比之下，开发人员应该尝试用更多的日志来覆盖每一个可能发生的事情，并在此过程中承担巨大的成本吗？

这是一个艰难的决定。

然而，我想建议在生产系统中从静态仪器转向动态仪器。

这意味着使用动态日志*。*

动态日志是您可以在应用程序执行期间添加到应用程序中的日志*、*，而无需修改您的源代码、运行整个开发周期甚至重启应用程序。

使用动态日志，任何开发人员都可以在需要时只写他们需要的日志。但是，更重要的是，它提供了一种方法来摆脱许多开发人员发现自己所处的令人不安的困境:必须在成本/速度和可观察性之间做出选择。

这使得开发人员可以随时向正在运行的应用程序添加新的日志语句，而无需重新部署、重启或停止它。

## **为什么要使用动态日志？**

与静态日志相比，动态日志提供了一些关键优势，与传统日志相比，它们在现代工作流中更加高效。

(如果你想直接跳到数字，你应该看一下 [Lightrun 的“对企业日志记录成本的影响”报告](https://go.lightrun.com/lightruns-impact-on-enterprise-logging-costs-study)，该报告详细记录了在一个由企业团队开发和维护的高事务量应用程序中实施 Lightrun 的动态日志记录之前和之后的确切支出)。

### **动态日志可以追溯添加**

通常，APMs 和其他可观察性供应商使开发人员能够分析现有的信息:即，在开发期间添加到应用程序中，然后在运行时发出的日志和度量。

动态日志可以添加到实时应用程序中，即使它已经在运行。如果有一段新代码最终没有良好的日志覆盖，或者代码库中缺少可见性的特别棘手的部分，开发人员可以在运行中添加动态日志，而不必改变应用程序的状态。

这意味着遥测技术可以随时扩展以满足组织的需求，而开发人员不必花时间提前为每一种可能发生的情况编写日志。

### **动态日志是短暂的**

动态日志不会保存在代码库中。相反，它们有一个“生命周期”,一旦生命周期结束就终止，这意味着如果在到期时间过后调用相同的代码路径，就不会再次发出日志。

在这种情况下，动态日志记录是有意义的，因为大多数日志根本不适合长期存储。在大多数情况下，开发人员只想获得应用程序运行时的一定程度的上下文，得出关于应用程序状态的结论，然后继续。

虽然动态日志不会取代组织出于法律或法规原因而必须保留的日志，但它们允许开发人员大大减少对调试日志的依赖，并消除在每次故障排除会话后“清理”代码库的操作负担。

### **动态日志是有条件的**

动态日志是以非常精确的条件编写的，这些条件只与日志本身相关，而与整个应用程序无关。这意味着，不是添加分支功能(如 if/else 或 switch 语句)来发出更细粒度的日志，而是可以在运行时基于开发人员需要的任何代码级逻辑有条件地发出日志。

例如，开发人员可以选择只发出以下日志:

1.  一台机器，只有一个云区域，只有一个 Kubernetes 名称空间或整个生产机群。
2.  一个特定的用户或用户类，基于只在运行时可用的属性(比如他们的用户代理或其他 HTTP 头)。
3.  当特定事件发生时，例如当客户购买产品时。

实际上，这意味着不是在每次代码路径调用时都发出日志，而是只有在需要时才发出日志。如果用户通过了某个特定的检查点，并且不再需要被监视，则可以添加一个动态日志，以便它只在检查点之前发出，而不在检查点之后发出，从而节省了该过程中绝大多数的日志发出。

### **动态日志是细粒度的**

动态日志可以包含与普通静态日志完全相同的信息。

每个动态日志都包含添加一个或多个代码级表达式的可能性，使用开发人员已经习惯的相同语法和模式。这意味着，从本质上讲，开发人员可以提出任何代码级别的问题，并从正在运行的应用程序中实时按需获取所需的信息。

当记录所有内容并在以后进行分析时，对应用程序日志输出的每次检查都包含大量信息，需要仔细阅读才能真正找到问题。

动态日志的粒度意味着开发人员可以跳过对无尽日志的筛选，而只获得他们一开始就想获得的信息。

### **执行动态日志**

静态日志总是会影响性能和内存，即使日志被禁用。动态日志只有在活动时才会对性能产生很小的影响，并且可以限制执行期间的性能影响，从而确保应用程序的完整性。

此外，动态日志比静态日志要少得多，这确保了应用程序的总体吞吐量由于日志记录量的减少而得到了极大的提高。

动态日志不会对应用程序的吞吐量产生很大影响，会受到持续监控和调节，永远不会绕过一组自定义的上限，包括 CPU 使用率、内存消耗和 I/O。

## **动态日志记录的好处**

### **性价比**

追溯创建日志的能力提供了很高的精确度:组织可以选择在需要时只记录需要的内容，而不是依赖 APM 来聚合、过滤和分析系统中的所有日志以了解实际发生的情况。

结果，日志记录和可观察性账单大幅下降，因为日志记录量大幅降低，从而导致更低的消费费用:更少的日志摄取、更少的日志存储和更少的日志分析。

### **提高开发人员的工作效率**

每次开发人员想要添加新日志时，静态日志记录都需要重新部署整个应用程序，这是开发生命周期中上下文切换、延迟和摩擦的主要原因。

通过引入动态日志，开发人员可以实时添加遥测技术，并将日志直接传送到集成开发环境(IDE)或现有的可观测性系统中，而无需重新部署应用程序。

这减少了上下文切换，消除了部署延迟，并极大地提高了开发人员的工作效率。您可以在此了解[如何使用动态日志记录帮助 WhiteSource](https://lightrun.com/case-studies/how-lightrun-saved-whitesource-cycles-of-redeployments/) 识别问题，而不必经历重新部署的周期。

**减少 MTTR**

通过使用动态日志，开发人员能够遵循实时调查过程，而不依赖于发布周期来完成。取而代之的是，开发者将能够提出具体的问题，并根据需要获得答案，而不必等待发布周期的结束。

这一过程的加速产生了更符合人体工程学的、对开发人员友好的工作流，该工作流鼓励开发人员更快地调试，而不必等待 CI/CD 管道完成或依赖于使用专有查询语言的深入的手动调查例程。你可以在这里阅读更多关于 [Taboola 如何使用动态日志](https://lightrun.com/case-studies/how-taboola-slashed-mttr-saved-260-plus-debugging-hours-a-month-with-lightrun/)和其他实时[开发人员可观察性](https://lightrun.com)技术节省超过 260 小时的调试时间。

### **保持安全、可靠和私密**

最后，值得再次注意的是，动态日志的所有好处都可以在不牺牲安全性的情况下获得:

1.  **动态日志是只读的** —没有任何工具会改变应用程序的状态。
2.  **不访问或传输源代码** —动态日志不访问源代码，只访问元数据。
3.  **不需要打开任何入站端口** —所有联网都以出站、长轮询的方式完成。

## **通过动态日志记录削减成本、降低复杂性并保持有效性**

静态日志的成本和复杂性开始变得难以承受。当前“记录一切，稍后分析”的方法，在开发团队多年的运作方式中根深蒂固。对于理解复杂的生产应用程序中正在发生的事情这一问题，它似乎是唯一可行的解决方案。

然而，生产系统中的动态日志记录实践克服了静态日志记录的许多限制，而成本却很小，无论是在经济上还是在整个系统性能方面。

通过使用 Lightrun 等专用的开发人员观察平台，您的开发人员无需离开 IDE 就可以享受安全、实时和符合人体工程学的动态日志记录，从而提高开发人员的工作效率并降低 MTTR。

## **按数字**

对于使用 Lightrun 的动态工具如何削减螺旋上升的日志记录成本、提高开发人员生产力和减少平均解决时间的具体的、数据驱动的探索，我们最近的[“对企业日志记录成本的影响”报告](https://go.lightrun.com/hubfs/Lightrun_Impact_On_Enterprise_Logging_Costs.pdf)值得一读。

<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 68 31" version="1.1"><title>Group</title> <desc>Created with Sketch.</desc></svg>