# 为什么我们要将数据库驱动程序移植到 Async Rust

> 原文：<https://thenewstack.io/why-were-porting-our-database-drivers-to-async-rust/>

[](https://pl.linkedin.com/in/piotr-sarna-548a76a3)

[Piotr Sarna](https://pl.linkedin.com/in/piotr-sarna-548a76a3)

[Piotr 是一位非常热衷于开源项目和 C++的软件工程师。他之前开发了一个开源分布式文件系统(LizardFS ),并在三星电子实习期间对 Linux 内核进行了短暂的探索。Piotr 毕业于华沙大学，获得计算机科学硕士学位。](https://pl.linkedin.com/in/piotr-sarna-548a76a3)

[](https://pl.linkedin.com/in/piotr-sarna-548a76a3)[](https://pl.linkedin.com/in/piotr-sarna-548a76a3)

一个快速可扩展的 NoSQL 数据库 [ScyllaDB](https://www.scylladb.com/?utm_content=inline-mention) 的最新客户端驱动程序是用纯 Rust 编写的，带有一个使用 [Tokio](https://tokio.rs/) 的完全异步 API。

虽然针对 ScyllaDB 进行了优化，但该驱动程序也与 Apache Cassandra 兼容。

这个 Rust 驱动程序从一个不起眼的黑客马拉松项目开始，但是它已经发展成为我们最快和最安全的 Cassandra 查询语言(CQL)驱动程序。

在我们的基准测试中，我们高兴地观察到 ScyllaDB Rust 驱动程序在原始性能方面甚至胜过了[参考 C++驱动程序](https://github.com/scylladb/cpp-driver)。这给了我们一个想法:为什么不统一我们所有的驱动程序，在下面使用 Rust？

## 统一核心的优势

数据库驱动程序很酷，但有一个基本问题:大量的重新发明轮子，为人们编写应用程序的每一种可能的语言反复实现相同的逻辑。在如此多的语言中实现同样的东西也增加了一些实现出现细微错误、性能问题、比特腐烂等等的机会。通过重用一个通用内核来尽可能多地进行重复数据删除听起来很诱人。在我们的情况下，这将是铁锈司机。

### 更容易维护

当大部分逻辑实现一次后，维护人员可以通过广泛的测试和适当的审查来关注这个中心实现。与尝试管理每种语言的一个项目相比，保持单个项目的最新状态需要更少的人力。一旦 ScyllaDB 中添加了新特性，就有可能只更新核心，从而使所有衍生实现自动从中受益。

### 更少的错误

不言而喻，重复数据删除有助于减少错误的数量，因为出现错误的代码更少了。此外，反向移植紧急修复也变得相当容易，因为相同的修复不必在每种支持的语言中仔细重写。

更好的是，现有的驱动程序已经有了自己的单元测试、集成测试等测试套件。因此，单核实现将由许多独立的测试工具和大量案例进行测试。当然，它们中的大多数会重叠。然而，没有完美的测试套件这样的东西。使用几个可以减少遗漏 bug 的可能性，通常可以提高测试覆盖率。所有的测试都已经有了，而且是免费的！

### 表演

一些驱动程序由于过时的设计而运行缓慢。有些更快，因为它们是用开销更少的语言实现的。有些，像我们的铁锈司机，是最快的。

类似于 Python 依赖于用 C 编译的模块来使其他模块更快更慢，我们的 CQL 驱动程序可以从 Rust 内核中受益。轻量级 API 层将确保驱动程序仍然向后兼容其以前的版本，但新版本将尽可能多的工作直接委托给 Rust 驱动程序，相信它会更快更安全地执行工作。

Rust 的异步模型非常适合实现高性能、低延迟的数据库驱动程序，因为它是可伸缩的，并允许应用程序中的高并发性。与其他语言实现的相反，Rust 抽象出了负责运行异步任务的层。这一层称为运行时。

对于开发人员来说，能够选择甚至实现自己的运行时是一个强大的工具。经过仔细研究，我们选择了 Tokio T1 作为我们的运行时，因为它是一个活跃的开源社区，注重性能；丰富的功能集，包括网络流、定时器等的完整实现。，以及许多奇妙的实用程序，如 [tokio-console](https://github.com/tokio-rs/console) 。

## 语言绑定

用一种语言编写代码以便在另一种语言中使用是常见的做法，并且有许多工具可用于这项工作。铁锈也不例外。它的生态系统通常对开发人员非常友好，并且有许多板条箱可以毫不费力地与其他语言绑定。

### C/C++

与 C/C++应用程序绑定实际上并不需要太多努力。Rust 使用 LLVM 生成代码，输出的可执行文件、库和目标文件或多或少都可以与任何 C/C++项目链接。尽管如此，在一个项目中使用 Rust 和 C/C++还是有一些好的实践。

首先，确保 name mangling 不会让链接器很难找到你在 Rust 中编译的函数。任何曾经用 C++编写函数并在 C 中使用它们的人肯定都熟悉关键字`extern “C”`，同样的[也适用于 Rust](https://doc.rust-lang.org/std/keyword.extern.html) 。只需用`extern "C"`标记您想要导出的函数，名称不会以任何方式被破坏。然后，链接器将更容易地将 Rust 部分与 C++目标文件和可执行文件进行匹配。

为了更流畅的开发体验， [cxx 机箱](https://docs.rs/cxx/1.0.66/cxx/)可以用来减少样板代码的数量，使绑定更加健壮。

### 计算机编程语言

Python CQL 驱动程序在 ScyllaDB 和 Cassandra 用户中非常受欢迎，但是，嗯，Python 并不以其高并发应用程序的惊人速度或可伸缩性而闻名。

幸运的是，由于它的动态类型和宽松的解释器，为 Python 应用程序提供绑定也非常容易。PyO3 crate 听起来在简化原生 Python 模块的开发方面有很大的潜力。

## 挑战

尽管统一多个驱动程序的实现有很多优点，但也有缺点。首先，Rust core 中的每个微小 bug 现在都有全局范围；这会影响所有的衍生驱动因素。然后，用来将我们的 Rust 驱动程序与目标语言绑定的胶水代码也是一个潜在的 bug 藏身之处。而且，依赖第三方库进行绑定会给每个驱动程序增加另一个依赖性。

### 无人驾驶？

最近，拥抱“无人驾驶”方式并公开为 gRPC 或 HTTP(S)等众所周知的协议实现的接口变得流行起来。这是一个有趣的观点，某些应用程序和开发人员肯定会从这种方法中受益。然而，通过另一层协议会产生开销(多轮序列化/反序列化、解析协议帧等等)。用户应该能够选择加入更好的性能，这是本地 CQL 驱动程序提供的。

## 已经做了什么

在我们的内部黑客马拉松[中，移植 CQL C++驱动程序的工作已经基本完成。虽然它仍然是一项正在进行的工作，但它也非常有前途，因为 C++的兼容层非常薄，部分原因是两种语言的应用程序二进制接口(ABI)有许多相似之处。](https://github.com/hackathon-rust-cpp/cpp-rust-driver)

## 摘要

统一驱动程序是一项相当大且复杂的任务。我们才刚刚开始，但我们对所有 CQL 车手未来的表现和稳健性寄予厚望。在最近的一次谈话中，我分享了更多关于我们旅程的信息:“ [ScyllaDB Rust Driver:一个驱动程序统治所有人](https://www.scylladb.com/presentations/scylladb-rust-driver-one-driver-to-rule-them-all/)”此外，如果你已经读到这里，也许你想成为 ScyllaDB 本地 Rust 驱动程序的贡献者？在 https://github.com/scylladb/scylla-rust-driver.加入我们

<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 68 31" version="1.1"><title>Group</title> <desc>Created with Sketch.</desc></svg>