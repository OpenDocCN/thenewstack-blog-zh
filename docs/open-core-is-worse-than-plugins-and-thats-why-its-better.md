# 开放核心比插件更糟糕…这就是它更好的原因

> 原文：<https://thenewstack.io/open-core-is-worse-than-plugins-and-thats-why-its-better/>

开放核心显然是一种可怕的方法，它创建了一个具有扩展和集成生态系统的产品:没有合适的协议和接口。相反，任何人都可以将他们的集成添加到代码库中，如果代码库不适合，甚至可以根据他们的需要调整代码库。

那么，为什么我们在 GitLab 使用“更差”的方法已经很多年了，并且取得了巨大的成功呢？因为[越差越好](https://www.dreamsongs.com/RiseOfWorseIsBetter.html)(这个术语是由 [Richard P. Gabriel](https://en.wikipedia.org/wiki/Richard_P._Gabriel) 想出来的)。当然，事实证明“更糟”实际上比“更糟”更好。

Gabriel[最初的观点](https://www.dreamsongs.com/RiseOfWorseIsBetter.html)是，本质上(稍微)更差但更简单、更容易实现的软件比设计更好、更复杂的软件具有更好的生存特性，因此将在市场上持续获胜。

在 GitLab，我们发现这基本上是正确的，这就是为什么我们，例如，喜欢“无聊技术”，即使它可能不是给定场景的最佳解决方案。但这并不能说明全部:事实证明，这样的软件不仅更成功，而且最终质量也会更好。

## **越差越好**

 [西德·西伊布兰迪

Sid 是 DevOps 平台 GitLab，Inc .的联合创始人、首席执行官兼董事会主席。Sid 花了四年时间为 U-Boat Worx 建造休闲潜艇，并在荷兰司法和安全部(Ministerie van Justitie en Veiligheid)从事 Legis 项目，该项目开发了几个创新的网络应用程序来帮助立法。他第一次看到 Ruby code 是在 2007 年，他非常喜欢它，以至于自学了编程。2012 年，作为一名 Ruby 程序员，他遇到了 GitLab，并发现了他对开源的热情。不久之后，Sid 将 GitLab 商业化，到 2015 年，他带领公司通过了 Y Combinator 的 2015 年冬季队列。在他的领导下，该公司从初创公司发展到全球企业，注册用户超过 3000 万。](https://www.linkedin.com/in/sijbrandij/) 

值得注意的是，Gabriel 最初的观点并不是说*坏的*软件会胜出，事实上，他的“更坏”和“更好”都具有相同的品质:

1.  接口和实现的简单性
2.  正确性
3.  一致性
4.  完全

然而，他的“更差”和“更好”对这些特征的重视程度略有不同，新泽西学派(更差)更喜欢实现的简单性而不是界面的简单性，而麻省理工学院学派(更好)更喜欢界面的简单性，即使以更复杂的实现为代价。

如果一个简单的接口可以用一个简单的实现来实现，两个学派都同意，当需要做出权衡时，差异就出现了。

让情况变得更糟甚至更好的是，即使在后来的版本中，加布里埃尔也没有考虑到反馈回路的巨大价值。早到不仅让新泽西的方法在市场上胜出，还让它比麻省理工学院的方法更早、更快地收集反馈。

保罗·麦克格雷迪赢得了第一个[克雷默奖](https://en.wikipedia.org/wiki/Kremer_prize)，不是因为他最初开始建造最好的人力飞机，而是因为他建造了一架最容易修理的飞机，以便更快地收集反馈。当其他团队花了一年或更长时间从坠机中恢复过来时，他的飞机有时会在同一天再次飞行。因此，正是这种对奖项视而不见的意愿导致了他的获奖。

同样，正是这些快速的反馈循环，使得“更差”的方法能够更早地开始，最终导致更好的产品。

## **外挂的问题**

至少从 Photoshop 成功以来，一个合适的插件界面已经被认为是一种正确的方式，通过创建一个第三方生态系统来提供有用的功能，而无需供应商自己提供所有功能，从而使软件对用户更有吸引力，并且更不容易留下。

它是如此的成功，以至于像 OpenDoc 这样的系统更进一步，仅仅是一套插件，没有真正的主机应用。这些系统都没有在市场上获得成功。

其中一个原因是好的插件界面不仅很难，而且非常难以开发。基本的困难是很难取得平衡:暴露什么，隐藏什么，如何提供功能。但这还不是最可怕的部分。

插件 API 开发中极其困难的部分是，你需要做的处理困难的事情使任务变得更加困难:你需要更仔细地设计，你需要使接口稳定，你只能缓慢地迭代它们。

简而言之:你面临一个过早抽象的先有鸡还是先有蛋的问题。为了制作一个好的插件 API，你需要看到它被使用，但是为了看到它是如何被使用的，你需要首先拥有它。这种动态延迟了初始可用性，并使反馈周期变慢。

软件不是面临这个问题的唯一领域。例如，公园通常有官方的路径，与人们实际想去的地方不匹配。一组景观建筑师通过减少工作量解决了这个问题:他们没有在他们创建的公园里修建任何人行道。相反，当人们走到他们需要走的地方时，他们等待路径的出现。只有在这些踪迹实现之后，他们才铺平它们，使它们成为官方的。

最后但同样重要的是，插件界面意味着用户看到的最终产品，包括核心应用程序和所有插件，并没有像它应该的那样集成好。“这里有一个带工具的盒子，玩得开心！”对开发人员来说，这听起来比对最终用户更有吸引力，即使这些工具本身是同类中最好的。

## **开芯**

另一方面，开放核心听起来像是完全错误的方法，当然从软件工程的角度来看，因为没有定义的黑盒边界，但从商业的角度来看，因为似乎没有一个实际的相互加强的生态系统。

然而，对于终端用户来说，开放核心方法是很棒的，无论是对于那些只是想使用它的采纳者，还是那些需要根据他们的用例来定制系统的适配器。最终，最终用户才是最重要的。

对于适配器来说，系统可以立即被黑客攻击。不需要首先等待供应商提供插件接口，也不需要等待供应商在将来的某个时间(如果有的话)使插件接口提供特定应用所需的功能。即使需要更改核心应用程序，这至少是可能的。

由于更多的适应活动发生得更快，系统在适应需求方面变得更好，良性循环随之而来。

对于采用者来说，好处是多方面的:首先，系统更快地获得更多的功能，这总是好的。更重要的是，该功能由供应商集成，并作为一个集成的整体提供。单供应商办公套件成功是有原因的，因为 OpenDoc 的工具箱方法失败了。

也就是说，开放核心方法确实需要坚实的工程、良好的架构基础和持续的警惕。正如[之前解释的](https://thenewstack.io/why-were-sticking-with-ruby-on-rails-at-gitlab/)，我们相信 Ruby on Rails 为我们提供了一个很好的起点，将 GitLab 构建成一个坚固的模块化整体，既平易近人又结构良好。以此为起点，好的设计是由例子来鼓励的，而不是由严格的 API 边界来强制的。另一方面，强制以更人性化的形式出现，因为拉式请求被考虑、形成、批准或拒绝。

因此，界限仍然存在，但它们不是用来撞击的砖墙，而是明显存在的低矮栅栏，但如果需要，可以被跨过。

虽然这些矮墙被认为比我们习惯的砖墙“更糟糕”，但它们实际上给每个参与者带来了更好的结果。

<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 68 31" version="1.1"><title>Group</title> <desc>Created with Sketch.</desc></svg>