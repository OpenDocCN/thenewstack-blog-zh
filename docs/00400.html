<html>
<head>
<title>Site Reliability Engineering for Cloud-Native Operations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向云原生操作的站点可靠性工程</h1>
<blockquote>原文：<a href="https://thenewstack.io/site-reliability-engineering-cloud-native-operations/#0001-01-01">https://thenewstack.io/site-reliability-engineering-cloud-native-operations/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">



<p class="translated">开发人员希望尽快改变事物，而运营团队仍然担心改变会破坏事物。为了调和这两种驱动力，谷歌创造了站点可靠性工程(SRE)之路，这是一种维护需要高可靠性运行的复杂计算系统的新兴实践。正如谷歌SRE团队的创始人，<a href="https://en.wikipedia.org/wiki/Site_reliability_engineering" class="ext-link" rel="external ">本·特雷诺(Ben Treynor)在</a>所说的那样:SRE是“当一个软件工程师被赋予过去被称为运营的任务时所发生的事情。”</p>
<p class="translated">SRE可以追溯到2003年，当时Treynor加入谷歌，管理一个工程师团队来运行生产环境。实践证明是成功的，该公司现在有1500名工程师在SRE工作。苹果、甲骨文、微软、Twitter、Dropbox、IBM和亚马逊也都成立了自己的SRE团队。</p>
<p class="translated">那么SRE到底是什么？有人会称之为<a href="/category/devops/" target="_blank"> DevOps </a>本身的子集。Treynor将其描述为传统sysadmin服务管理方法的一种替代方法，在传统sysadmin方法中有两个不同的开发和运营团队。他说主流的sysadmin方法很容易实现，并且已经有很多工具和例子可以帮助你实现。然而，Treynor说，这个过程会带来直接和间接的成本，包括团队必须根据服务和流量需求进行扩展和收缩。</p>
<p class="translated">“从本质上讲，开发团队希望推出新功能，并看到它们被用户采用。他们的核心是，运营团队希望确保在他们拿着寻呼机时服务不会中断。因为大多数中断是由某种变化引起的——新配置、新功能发布或新类型的用户流量——两个团队的目标从根本上来说是紧张的，”<a href="https://landing.google.com/sre/book/chapters/introduction.html" class="ext-link" rel="external "> Treynor写道</a>。</p>
<p class="translated"><img decoding="async" loading="lazy" src="../Images/e19bcb903467757a7c308337ba500bb0.png" alt="" data-original-src="https://cdn.thenewstack.io/media/2017/06/6e56321f-site-relability-engineering-1-1024x570.png"/></p>
<p class="translated">SRE团队的首要任务是至少花一半的时间在开发上，以确保系统保持强大和稳定。谷歌SRE团队由谷歌软件工程师组成，其中许多人拥有Unix或网络管理等专业技能。所有人都专注于解决复杂问题的软件。他们有一种“要么编码，要么淹死”的心态，因此没有人会长期从事某项工作，从而将运营的债务保持在最低水平。</p>
<p class="translated">在今年的<a href="https://coreos.com/resources/index.html#ufh-i-347359245-coreos-fest-day-2-coreos-cto-brandon-philips-google-sre-chris-jones-astronomer-lucianne-walkowicz/588810" class="ext-link" rel="external "> CoreOS Fest </a>上，<a href="https://g.co/srebook" class="ext-link" rel="external ">O ' Reilly的书《站点可靠性工程》的联合编辑，</a> Google研究员<a href="https://www.linkedin.com/in/chris-jones-122969/" class="ext-link" rel="external ">克里斯·琼斯</a>告诉观众，即使是思想进步的敏捷软件工程仍然缺少软件工程的维护方面，专注于构建软件而不是操作软件。</p>
<p class="translated">琼斯说，软件可靠性工程师所做的是“考虑软件对象的整个生命周期，从它们的开始到它们的部署到操作、改进，以及最终的和平退役”。</p>
<p class="translated"><img decoding="async" loading="lazy" src="../Images/cec79cc7c3187a0208adcc635b1709a3.png" alt="" data-original-src="https://cdn.thenewstack.io/media/2017/06/b47385c7-site-relability-engineering-1024x471.png"/></p>
<h2 class="translated">云世界中的站点可靠性工程</h2>
<p class="translated">谷歌SRE团队所做的一切不仅包括创造和自动化，还包括衡量事情是如何进行的。这些指标推动了软件的进一步开发，从而使软件运行得更可靠、更快、更便宜。</p>
<p class="translated">但是这在我们的云世界中是如何工作的呢？</p>
<p class="translated">“云是一个计算环境，你很难指出运行你的软件的确切东西，”琼斯说。</p>
<p class="translated">云部署的一个重要步骤是将应用程序与它们自己的依赖项配对。对于谷歌来说，容器是实现这一点的云的基础技术。“在内部，我们几乎是开源的，”琼斯谈到谷歌时说，在谷歌，工程师可以对任何代码提出修改，允许他们真正根据需要构建软件，并理解它在做什么。</p>
<p class="translated">琼斯承认，这种方法可能不适用于那些对他们正在建设和运行的东西没有完全透明度和所有权的公司，但他怀疑将开始出现涵盖这一点的标准。随着越来越多的软件为云而构建，云将变得内在可互操作，以实现这些目标。</p>
<p class="translated">最后，Jones认为，随着我们越来越多地向云迁移，我们将需要SRE作为瀑布或DevOps的替代方案，因为它是在云中构建的。</p>
<p class="translated"><iframe loading="lazy" title="CoreOS Fest Day 2: CoreOS CTO Brandon Philips, Google SRE Chris Jones, astronomer Lucianne Walkowicz" src="https://www.youtube.com/embed/MICZJ1A9LsM?start=2467&amp;feature=oembed" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="">视频</iframe></p>
<p class="attribution translated"><a href="https://coreos.com/" class="ext-link" rel="external "> CoreOS </a>是新堆栈的赞助商。</p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
<title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>

</div>
</div>    
</body>
</html>