<html>
<head>
<title>Facebook Tackles PrestoDB’s Query Performance Block with an Optimized Reader</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">脸书用一个优化的阅读器解决了PrestoDB的查询性能问题</h1>
<blockquote>原文：<a href="https://thenewstack.io/facebook-tackles-prestodbs-query-performance-block-with-an-optimized-reader/#0001-01-01">https://thenewstack.io/facebook-tackles-prestodbs-query-performance-block-with-an-optimized-reader/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">


<p class="translated">这是一个大海捞针的问题，除了你要寻找多种针匹配一个特定的类型。你如何接近干草堆？在你的头脑中，你可以把谷仓分成几块，每块又分成几个小方块。然后你可以从左到右，从上到下，依次搜索公寓中的每个立方体和街区中的每个单元。在网络中立问题上，你会比国会更慢地得出结论。</p>
<p class="translated">如果你需要的只是对实际有多少根针的可靠估计，那么你可以采用抽样策略。最简单的策略假设针的分布总是均匀的。但在实践中，应用简单的抽样策略可能无法帮助您估计您正在寻找的特定类型的针的数量。尽管如此，你可能不喜欢评估针的类型，直到你已经从干草中分离出所有的针。</p>
<p class="translated">至少，这是逻辑会告诉你的。谓词逻辑建立在Edgar F. Codd博士在20世纪60年代首先奠定的基础上，但实际上并不是这样的。它可能更喜欢您从干草和其他针中分离出确切的针类型，并且它可能会在让您开始按块细分之前将该上下文应用于整个谷仓。</p>
<p class="translated">因此，可以想象，将为关系数据库系统创建的查询应用于庞大的半结构化数据集可能会产生差的结果或慢的结果——随你挑。</p>
<h2 class="translated">迅速改变</h2>
<p class="translated">PrestoDB，<a href="https://thenewstack.io/airbnbs-airpal-reflects-new-ways-to-query-and-get-answers-from-hive-and-hadoop/" class="local-link">正如我们在之前的帖子</a>中所讨论的，是脸书针对将快速查询应用于存储在Hadoop HDFS中的巨大数据集的问题而开发的解决方案。脸书的工程师们发现他们自己在构建PrestoDB(或者只是“Presto”)，原因很简单，Hadoop的查询引擎Hive在处理大型数据集时太慢了。</p>
<p class="translated">使脸书的Presto开发更快的是它的开发者与更大的开源社区分享他们的经验。它仍在积极开发中。正如脸书最近宣布的，为了获得更快的速度，它已经更换了Presto的一个关键组件。</p>
<p class="translated">这样的声明听起来就像汽车工程师鼓吹更换化油器以获得更大的排量。但是现在世界上越来越多的巨大工作量依赖于脸书技术，我们可以使用新的汽化器，谢谢。</p>
<p class="translated">具体来说，这是Presto的优化行/列阅读器，它从Hadoop的HDFS文件格式中提取记录。在一篇博客文章中，脸书软件工程师Dain Sundstrom解释说，他的团队一直在使用“兽人的一个分支”(他可能写了整篇文章，所以他可以这么说)，叫做DWRF。但Presto的分析任务需要列读，这可以比作将所有针堆叠起来而不必从干草中单独提取每一根针的能力。DWRF提取行或记录，而不是列。</p>
<h2 class="translated">DWRF推下:这一次，它是个人的</h2>
<p class="translated">此外，DWRF不支持脸书迫切需要的一个关键特性，称为谓词下推。</p>
<p class="translated">我们请Arshak Navruzyan,<a href="http://www.argyledata.com/" class="ext-link" rel="external ">Argyle Data</a>的产品管理副总裁解释这是什么。Argyle是PrestoDB的主要第三方客户之一，也是Presto开源项目的贡献者。它在为主要电信提供商提供实时欺诈检测服务的过程中使用Presto。你可以在这里找到我们关于阿盖尔使用急变戏法<a href="https://thenewstack.io/how-argyle-data-uses-facebooks-prestodb-to-detect-fraud/" class="local-link">的故事。</a></p>
<p class="translated">Navruzyan告诉我们，Argyle在Presto和<a href="https://accumulo.apache.org/" class="ext-link" rel="external "> Apache Accumulo </a>(分布式键/值存储)之间的连接器确实使用了谓词下推。“因此，查询的WHERE子句实际上被下推到索引存储中，也就是Accumulo中，”他说。"然后Accumulo就可以进行范围查询了."</p>
<p class="translated">向下推是一种延迟，但完全是正确的延迟。它的意思是:不要开始寻找精确的东西，直到先把一般的东西分离出来。</p>
<p class="translated">Navruzyan说，Presto的主要优势之一是进行近似查询的能力，这是建立在加州大学伯克利分校研究人员的<a href="https://www.cs.berkeley.edu/~sameerag/blinkdb_eurosys13.pdf" class="ext-link" rel="external "> BlinkDB项目</a> [PDF]的基础上的。几年前，正是这个团队首次尝试平衡效率和实用性的需求，提出了一个合理的折衷方案。</p>
<p class="translated">“以前的解决方案都不太适合今天的大数据分析工作负载，”伯克利团队在2013年写道。“OLA [online aggregation]为稀有元组的查询提供了相对较差的性能，而采样和草图对工作负载的可预测性做出了强有力的假设，或者极大地限制了它们可以执行的查询类型。… BlinkDB允许用户对存储的数据提出基于SQL的聚合查询，以及响应时间或错误限制。因此，超过数TB数据的查询可以在几秒钟内得到回答，并伴有相对于查询在完整数据上运行时得到的答案的有意义的误差界限。”</p>
<p class="translated">这是脸书工作背后的灵感的一部分，自柏克莱以来，它已经发展了至少几代。根据脸书的计算，Presto的新ORC阅读器移植到位后，对内存中ZLIB压缩数据集的端到端单线程查询速度比DWRF快3.5到4倍。(脸书大学的Sundstrom警告说，你的结果可能会有所不同。)</p>
<p class="translated">Sundstrom写道:“我们一直在挑战规模和性能方面的极限。实际上，他可能低估了自己的情况。那个信封，尽管如此，却被丢在了几英里以外。在后视镜中，你仍然可以看到灰尘，还有一些干草斑点和一些弯曲折断的针。</p>
<p class="translated">特色图片<a href="https://www.flickr.com/photos/cernaovec/15671888594/in/photolist-pSSwtL-6WCq3s-hf9Hz-6MMYqU-4VkN3R-2x8mvr-8MBG8c-34krtF-4xczrV-7u4pup-N39Y6-dbo2AB-5fYpMA-a9pd8s-5LdHDQ-o5ef8W-6Yz7Lz-oT5uXE-xVtw2-aa8HLR-dFwGvP-dFC7Lw-P5BSr-4xgNLU-4xgNwW-dNiF3Z-5gPQjp-5fYoRf-3HBdU-6FMtWX-a6kSVB-4MqrHF-abxBzG-abuAvB-abukxc-abuj9R-54RxSJ-54MkjZ-54MjQg-54Rtgw-54Rrsq-54MdR2-5DXrkY-5DT9Ta-5DXpWJ-dNpf11-bR3Fbx-4peuUA-5DT8ni-5DT7Mg" class="ext-link" rel="external ">通过</a> Flickr知识共享。</p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
<title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>

</div>
</div>    
</body>
</html>