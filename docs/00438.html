<html>
<head>
<title>Dashbird: Turning Serverless Monitoring Instruments into Debugging Tools</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Dashbird:将无服务器监控仪器变成调试工具</h1>
<blockquote>原文：<a href="https://thenewstack.io/dashbird-turning-serverless-monitoring-instruments-debugging-tools/#0001-01-01">https://thenewstack.io/dashbird-turning-serverless-monitoring-instruments-debugging-tools/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">


<p class="p1 translated">无服务器技术发展很快，但对于更主流的采用，需要一套监控工具来允许开发人员跟踪他们的应用程序和工作流的实际情况。<a href="/category/serverless/" target="_blank">无服务器</a>需要不同类型的监控(例如，专注于单个功能性能和复杂工作流的健壮性)，一波新工具渴望提供解决方案:<a href="https://thenewstack.io/emerging-ops-tooling-serverless-reveals-two-adoption-paths/" class="local-link">斯塔克里</a>、<a href="https://thenewstack.io/iopipe-launches-lambda-monitoring-tool-aws-summit/" class="local-link"> IOpipe </a>，现在<a href="https://dashbird.io/" class="ext-link" rel="external "> Dashbird </a>都已进入舞台。</p>
<p class="p1 translated">Dashbird的联合创始人<a href="https://github.com/taavirehemagi" class="ext-link" rel="external ">Taavi rehemgi</a>和<a href="https://github.com/kirstein" class="ext-link" rel="external "> Mikk Kirstein </a>认为他们的监控方法是最有洞察力和最准确的，不会降低性能，因为监控直接来自<a href="https://aws.amazon.com/cloudwatch/" class="ext-link" rel="external "> CloudWatch </a>日志，而不是注入在函数之间运行的新代码。但几乎作为副产品，Dashbird发现他们的监控解决方案有了新用途:作为一种调试工具，可以帮助开发人员在执行无服务器工作流时获得反馈。</p>
<p class="p1 translated">目前，Dashbird专注于AWS中的监控，因为95%的市场都在AWS Lambda上，首席执行官兼联合创始人rehemgi说。“我们连接到一个AWS账户，查看CloudWatch日志。我们的服务绝对不会对代码执行速度产生任何影响，也不会增加包的大小或任何其他开销。我们的直接好处是设置速度和帐户范围的可见性，”他说。</p>
<p class="p1 translated">rehemgi说，传统的应用程序性能监控方法通常通过远程API发送数据来收集日志，然后使用这些日志来创建仪表板和基于所摄取数据的警报。这种方法不适合无服务器，他解释道:“你有很多功能，一切都发生在瞬间，所以收集引擎缓存更有意义。此外，可能不会报告超时，因为调用在那里停止。为了避免这种情况，我们为函数退休设置了一个标志，以显示它是重试还是第一次调用。”</p>
<p class="p1 translated">rehemgi说，他在用户中看到的主要错误类型包括:</p>
<ul>
<li class="p1 translated"><em> <strong>超时:</strong> </em>这些是主要的错误类型，尤其是在无服务器工作流中，一个功能可能需要超过六秒钟</li>
<li class="p1 translated"><em> <strong>无声故障:</strong> </em>雷海姆吉说，这是一个大问题，因为用户没有将报告附加到一些他们认为不会失败的功能上。“500个函数中有10到20个函数可能会出现你认为不会出现的问题。这是Docker或传统编程方法所没有的问题。”</li>
<li class="p1 translated"><em> <strong>配置错误:</strong> </em>当用户忘记附加依赖项或库时会出现这些错误，这意味着事件处理程序没有被触发，所以问题甚至没有被报告。</li>
</ul>
<p class="translated">所有这三种类型的错误都可以通过Dashbird进行分析和解决，dash bird目前有仪表板视图来提供无服务器架构性能的概述，并且可以与Slack集成来根据需要提供关键报告。该团队的下一步是开始分析一段时间内的内存使用情况，以便用户可以在无服务器架构达到某个阈值或面临内存限制的风险时获得主动警报。</p>
<h2 class="translated">使用监控工具进行调试</h2>
<p class="p1 translated">但是Dashbird的一个意想不到的用例可能是它被用作调试工具。无服务器的挑战之一是没有开发阶段，因此开发人员必须执行他们的功能，看看他们在现实世界中是如何运行的，然后找出如果它没有按预期执行会发生什么。关于代码发生了什么的反馈循环要长得多:采用者需要构建和部署他们的无服务器工作流，然后才能看到发生了什么。</p>
<p class="p1 translated">与无服务器框架一起使用的开源<a href="https://github.com/dherault/serverless-offline" class="ext-link" rel="external "> <span class="s1">无服务器离线插件</span> </a>可以模拟Lambda操作和API网关，以允许开发者创建开发阶段环境。有了无服务器离线，“至少现在我可以在把代码推给AWS之前，在本地测试我所有的代码。克罗地亚在线学习平台<a href="https://bookvar.co/all" class="ext-link" rel="external "> <span class="s1"> Bookvar </span> </a>的联合创始人兼开发者Adnan Rahic  写道:“这真是松了一口气。</p>
<p class="p1 translated">但是对于那些不需要完全独立环境的人来说，Dashbird的监控本身或许可以充当调试工具。“由于我们将所有的调用和日志分开，你可以在开发时使用它，这样你就可以在发生时获得上下文，”rehemgi说。“所以你可以在代码执行时看到它。这不仅是关于捕捉错误，也是关于建立系统。”</p>
<p class="p1 translated">rehemgi说，他看到许多Dashbird用户每天都会在他们的监控工具上停留几个小时，这表明它是用于调试的。虽然他认为Dashbird确实能够缩短反馈回路，但他不太愿意称之为实时——“延迟大约是一分钟”——但他希望这个例子能够鼓励其他无服务器产品的创造者开始构建解决方案。</p>
<p class="p1 translated">与此同时，Dashbird现已正式发布，其使用量已经比私人测试阶段翻了一番。正如其他无服务器工具制造商发现的那样，早期采用者通常来自营销和在线广告公司，但即使在这一领域，也存在很大的差异。在迄今为止使用Dashbird的公司中，大约10%的公司每月的调用次数达到1亿次。中型公司开始在一个特定的用例中采用无服务器，其余的公司则在尝试可行的方案。“但是有一半是Lambda的忠实用户，”rehemgi估计。</p>
<p class="attribution translated">专题图片:由<a href="https://unsplash.com/photos/kuJkUTxR0z4" class="ext-link" rel="external "> Unsplash上的</a>rid ham Nagralawala拍摄。</p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
<title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>

</div>
</div>    
</body>
</html>