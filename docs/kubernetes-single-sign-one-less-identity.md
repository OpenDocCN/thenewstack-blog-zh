# Kubernetes 的单点登录:简介

> 原文：<https://thenewstack.io/kubernetes-single-sign-one-less-identity/>

[](https://pusher.com/)

 [Joel Speed，云基础架构工程师，推动者

Joel Speed 是一名 DevOps 工程师，在 Kubernetes 工作了最后一年。他从事软件开发已经超过 3 年，目前正在帮助 Pusher 构建他们的内部 Kubernetes 平台。最近，他一直专注于改善 Kubernetes 内部的自动伸缩、弹性、身份验证和授权的项目，并为 Pusher 的工程团队构建了一个 ChatOps 机器人 Marvin。在学习期间，他深入参与了沃里克学生电影院，将他们的基础设施集装箱化，并定期放映电影。](https://pusher.com/) [](https://pusher.com/)

我不是世界上最有条理的人。对我来说，必须记住我个人和工作访问的服务的大量登录变成了一场噩梦。

每当我注册一个新网站时，我会立即寻找“登录…”链接，看看它是否能从谷歌或脸书等网站获取我的详细信息。我发现单点登录体验是一种享受，它让我不必创建更多的帐户，并减少了我一天中必须登录的次数。

作为 [Pusher](https://pusher.com) 的云工程师，我每天都和 Kubernetes 一起工作。有一段时间，使用我们的 Kubernetes 集群进行身份验证远不是理想的单点登录体验。自 Kubernetes 之旅开始以来，我们一直使用单一的共享证书进行身份验证，但我们希望让每个工程师都有自己的证书。为此，我开始让我们的 Kubernetes 登录体验变得简单易用，就像我从其他服务中熟悉的“登录”体验一样。

Kubernetes 的一大优点是它完全分离了身份验证和授权。身份验证(Authn)意味着识别用户身份的行为，授权(Authz)意味着确定用户是否被允许执行某些操作的行为。这可以从护照和签证的角度考虑。在边境检查站，他们检查我的护照(Authn ),看看我是不是我声称的那个人，然后他们检查我的签证(Authz ),上面写着我可以去他们的国家旅行。

在这篇文章中，我将讨论 Kubernetes 中的身份验证，特别是它的单点登录方法。我不会详细介绍我们的具体设置，但是，我会接着写一篇更具技术性的文章，解释我们当前的身份验证流程，以及您可以如何自己进行配置。

## Kubernetes 支持哪些认证方式？

对于与 API 交互的工程师，Kubernetes 有三种主要的身份验证方法。有一个[页面](https://kubernetes.io/docs/admin/authentication/)列出了更多的身份验证方法，但是下面的三种是用户身份验证更常用的方法。

### 静态密码

这也称为基本身份验证。这不能很好地扩展，因为添加新用户需要更新每个 API 服务器节点上的文件，然后重新启动每个 API 服务器。我们很快就排除了这种方法。

### X.509 客户端证书

使用这种方法，每个开发人员都有自己的证书，在建立连接时，他们会将证书提交给 API 服务器。然后，API 服务器验证证书，并使用证书中的信息来识别该会话的用户。

证书身份验证存在一些问题:

*   证书有一个到期时间，该时间是在颁发证书时设置的。他们将验证用户直到这个时候(无论如何没有 [OCSP](https://en.wikipedia.org/wiki/Online_Certificate_Status_Protocol) )。
*   证书必须由某个公共证书颁发机构(CA)签名。Kubernetes 需要此 CA 证书的副本来验证客户端证书。如果您允许访问这些 CA 证书的人签署他们自己的证书，他们将能够授予他们自己想要的任何组凭据或身份。这将允许特权升级，因此您必须设法集中颁发证书。
*   颁发证书并不容易，因此这些证书通常具有很长的有效期。
*   在浏览器中提供认证证书是很困难的，例如对于 K8s 仪表板。

虽然这种解决方案会给我们提供可单独识别的用户，但它似乎不是非常用户友好，所以我决定尝试找到一种更简单的解决方案。

### OpenID 连接(OIDC)

OIDC 是 Kubernetes 对单点登录的回答。但是，这是一个很大的但是，目前很少有提供商支持 OIDC。虽然这个选项最初看起来很糟糕，但看起来我们似乎可以不用为每个工程师创建新的登录帐户，因此，这是我的团队选择进一步研究的途径。

## 什么是开放 ID 连接？

在 Pusher，我们使用谷歌的 G 套件来托管我们的电子邮件，因此，如果我们能够建立一个由谷歌支持的单点登录，每个工程师都可以使用一个登录。由于谷歌支持 OIDC 作为他们平台的一部分，我们决定调查 OIDC 是什么和它是如何工作的。

OpenID Connect 基于 OAuth 2.0。然而，它在设计时更多地考虑了身份验证。OIDC 的明确目的是生成所谓的 id-token。

这个 id-token 采用 JSON Web Token 或 [JWT](https://jwt.io/) (发音为 jot)的形式，可能看起来像这样:

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ

```

这个字符串实际上由三部分组成，每一部分都是 Base64 编码的 JSON。第一部分为令牌提供元数据。第二部分提供身份信息，称为有效载荷。第三部分是签名，用于验证令牌是由可信方颁发的。

如果你解码有效载荷，它可能看起来像这样:

```
"iss":  "https://auth.pusherplatform.io/dex",
"sub":  "ChUxMDk0MzA2MjQwNTcwNDc3MDE4MTkSBmdvb2dsZQ",
"aud":  "kubernetes",
"exp":  1519123284,
"iat":  1519036884,
"at_hash":  "X2G33w55vEm39VwyOMMjzg",
"email":  "joel.speed@pusher.com",
"email_verified":  true,
"name":  "Joel Speed"

```

有效负载包含识别发起 OIDC 登录流的用户的信息。它通常包含他们的姓名和电子邮件，但也可能包括额外的信息，如他们的组成员。

![](img/1cf2a34dda4bf83c9f560085279ba425.png)

生成这些令牌的正常过程与 [OAuth 2.0](https://oauth.net/2/) 中的过程非常相似:

1.  用户点击网站上的登录按钮，
2.  网站将他们重定向到身份提供者，
3.  浏览器加载身份提供者登录屏幕，
4.  用户使用他们的用户名和密码登录，
5.  身份提供商使用查询字符串中的身份验证代码将它们重定向回网站，
6.  浏览器在查询字符串中加载带有验证码的网站，
7.  网站服务器将代码交换为 ID 令牌。

一旦服务器有了这个令牌，它可以使用它来验证用户本身，或者它可以将它提供给用户，以便他们可以将它提供给信任身份提供者的其他服务。

Kubernetes 本身不提供任何用于 OIDC 认证的登录网站。只有当你从其他途径获得令牌时，它才会消耗这些令牌。这可能会让您想知道 Kubernetes 和身份提供者之间的信任关系是在哪里形成的。

如前所述，令牌的第三部分是签名，由 OIDC 提供者生成的每个 ID 令牌都用加密密钥(通常是 RS256，由提供者定期生成和轮换)进行签名。通过向 Kubernetes 提供 OIDC 提供商的 URL，Kubernetes 可以检索这个密钥的公开部分，并验证令牌确实是由 OIDC 提供商签名的。此时，Kubernetes 将接受令牌，并信任令牌关于用户身份的声明。

## OIDC 的局限性

虽然 OIDC 离“好”的登录体验更近了一步，但它也有其局限性。

id-token 一旦生成就不能撤销。与颁发 auth 证书非常相似，id-token 有一个截止时间，它将对用户进行身份验证，直到该时间到来。这意味着令牌通常只发放 1 小时，但一些提供商确实支持刷新令牌的请求。可以使用刷新令牌(通常是无限期的)来授予新的 id 令牌并继续使用服务。

另一个问题是缺乏支持，Kubernetes 文档只列出了三个提供商，如果你没有使用 Salesforce、Azure AD 或 Google 中的一个，那么就没有内置的 SSO 体验。

## 介绍 Dex

在调查 OIDC 的时候，我偶然发现了 CoreOS 的一个开源产品，它可以帮助解决这些问题。

[Dex](https://github.com/coreos/dex) 在认证链中充当中间人。它成为 Kubernetes 的身份提供者和 ID 令牌的发行者，但它本身没有任何身份感。相反，它允许您配置上游身份提供者来提供用户的身份。

和任何 OIDC 提供商一样，Dex 支持从 GitHub、GitLab、SAML、LDAP 和微软获取用户信息。它的提供者插件极大地增加了与现有用户管理系统集成的可能性。

Dex 带来的另一个优势是能够控制 ID 令牌的发布，例如指定生命周期。它还使得强制您的组织重新进行身份认证成为可能。使用 Dex，您可以轻松地撤销所有令牌，但是无法撤销单个令牌。

Dex 还为用户处理刷新令牌。当用户登录 Dex 时，他们可能会被授予一个 id 令牌和一个刷新令牌。当 id-token 过期时，kubectl 之类的程序可以使用这些刷新令牌来重新认证用户。因为这些令牌是由 Dex 发布的，所以这允许您通过撤销特定用户的刷新令牌来停止他们的刷新。这在丢失笔记本电脑或手机的情况下非常有用。

此外，通过使用像 Dex 这样的中央认证系统，您只需要配置一次上游提供者。我们有一个设置，我们的上游身份提供者只知道 Dex。然后，Dex 有多个客户端对内部网站的用户进行身份验证，特别是我们集群上的 Kubernetes APIs。

这种设置的一个优点是，如果任何用户想要向 SSO 系统添加新的服务，他们只需要向我们的 Dex 配置打开一个 PR。此设置还在上游身份提供者中为用户提供了一键“撤销访问”功能，以撤销他们对我们所有内部服务的访问。同样，这在出现安全漏洞或笔记本电脑丢失时非常有用。

通过使用 Dex 作为 Pusher 的中间身份提供者，我们现在可以对用户身份令牌的发布和撤销进行细粒度的控制。然而重要的是，用户不需要管理另一个身份。

## 结论

当审查我们的选择时，我和我的团队决定我们确实将使用 OIDC 进行我们的 Kubernetes 认证。我们喜欢这个想法，我们可以使用我们的 G 套件帐户，并认为这对我们的工程师来说比在他们到达时颁发证书更容易。我们还喜欢 Dex 提供的控制，它不仅允许我们将令牌生命周期设置得非常短，还允许我们控制工程师会话，如果需要，还允许我们将用户从集群中注销。

OIDC 让我们更接近于为我们的工程师提供用户友好的登录体验，并允许我们开始限制他们使用 RBAC 访问。

在我的下一篇文章中，我将更详细地解释 Pusher 中设置的特定 SSO。我将详细介绍用户如何生成他们自己的 ID 令牌，以及他们在命令行和 web 浏览器中的身份验证体验。然后，我将更详细地解释如何在您自己的组织中复制这种经验。

<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 68 31" version="1.1"><title>Group</title> <desc>Created with Sketch.</desc></svg>