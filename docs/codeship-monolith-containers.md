# 在 Docker 容器中运行单片应用程序的情况

> 原文：<https://thenewstack.io/codeship-monolith-containers/>

劳拉·弗兰克

劳拉是 Codeship 公司的工程总监，也是一名码头工人。她的主要关注点是加强 Codeship 的 Docker 基础设施和改善整体 CI/CD 体验。在加入 Codeship 和 Docker 之前，她负责 HPE 的公共云产品和 OpenStack 项目。

为了有一个复杂的功能系统，你首先需要有一个简单的功能系统。你的整体应用程序并不是一开始就是一个整体；这是一个越来越复杂的简单解决方案。大多数采用多服务方法的项目都会失败。当你甚至不知道简单的解决方案是什么样的时候，就不可能为大量的复杂性做计划。

当您评估您的迁移项目可能采取的路径时，很容易陷入瘫痪状态。当你听到 Docker 被吹捧为部署和运行微服务的伟大工具时，这一切就开始了。因此，如果你不使用微服务，你很容易被说服，你不能开始使用 Docker。

虽然 Docker 是一个支持微服务工作流的工具，但它也是所有类型的架构和应用程序的良好解决方案。通过将您的应用程序打包到 Docker 映像中，您可以使您的开发和部署工作流现代化，以便更频繁地发布代码，并确保您的客户使用您提供的最佳产品。

## 从头开始

Docker 不再是只为早期用户保留的闪亮新东西。事实证明，它在企业市场上有持久的影响力，像 Visa 和易贝这样的大客户在 Docker 上运行生产工作负载。但是大多数公司不会只在一个新项目中使用 Docker。当我们与客户讨论采用 Docker 的途径时——尤其是我们自己的 [Codeship Pro](https://codeship.com/features/pro) 用户——我们建议的第一步是简单地获取他们已经在运行的容器映像。从那里，必要的抽象变得更加清晰。

下面是开始用 Docker 运行应用程序时*不需要的东西:*

*   完整的微服务架构。
*   一个完全完美的 CI/CD 管道(尽管您需要测试，以支持自信的部署和重构)。
*   完美协调的配器系统。
*   容器中的持久数据。
*   适用于各种环境的超级优化的多阶段映像。

所有复杂的系统都要先从简单枯燥的东西开始。小的、渐进的进化是一个很好的方法。获取在容器中运行的应用程序的主服务，或者只获取服务。从构建映像开始，因为没有它你什么都做不了。“管用！”已经足够好了。依靠像 [Image2Docker](https://github.com/docker/communitytools-image2docker-linux) 这样的工具来帮助 Dockerfile 创作，或者从最新的 [Ubuntu LTS](https://hub.docker.com/_/ubuntu/) 版本这样经过反复测试的基础图像开始。

只需使用您之前使用的相同数据库。不一定要装在容器里。接下来，添加一些警报和监控。在 Codeship，我们喜欢 [Librato](https://www.librato.com/server-monitoring/docker) 。

通往[微服务](/category/microservices/)的道路通常与容器化的道路相连，但重要的是要记住，这些转变并不一定相互绑定。微服务可以，而且通常应该晚一点。虽然 Docker 确实经常促进这种转变(因为团队希望利用 Docker 工具集),但是这些变化相互独立地发生也不是不可能的。

没有 Docker 也可以做微服务。你可以在 Docker 中运行 monoliths！没有人会告诉你你做错了。

## 拥抱中性的变化

您在容器化过程中做出的每个决定都应该对您的应用程序产生中性到积极的影响。中立不是一件坏事。事实上，隔离您引入到系统中的变更量可以帮助您更快地达到目标，因为转换路径被简化了。

我的意思是:也许你正在推迟容器化你的单片应用程序，因为你希望它是高度可用的，你希望避免一个容器作为单点故障的情况。但是运行相同代码的单个虚拟机也是单点故障。在一个容器中运行它的决定是中性的，甚至是中性的积极趋势。你在用一个单点失败换取另一个单点失败。但是通过完成这个练习，您正在推动您的应用程序和您的团队向在容器中运行高可用性应用程序的目标更近一步。

> "一个有效的复杂系统总是被发现是从一个有效的简单系统进化而来的."—约翰·高尔

类似地，您可能希望从一个单节点 Swarm 集群(也称为“小 Swarm”)开始，其中单个节点是一个管理器，运行工作负载任务。这是一个中性的变化——仍然是一个单点故障——但它是积极的，因为它为您的应用程序的高可用性扩展做好了准备。您的团队获得了操作 Swarm 集群的经验，而不必深入理解多节点集群所增加的复杂性。

积极的变化是显而易见的，因为你应该有一些具体的衡量标准。只有当你已经做出了一个中性的改变来促进这些改变时，才会发生有重大积极影响的改变。[优化您的 docker 文件以减小图像大小](https://blog.codeship.com/reduce-docker-image-size/)，或使用多阶段构建等新功能，只有在您首次制作 docker 文件时才能实现。以图像大小为例，跟踪影响很简单，因为这种变化是以字节为单位来衡量的。这个小小的变化会波及到你的整个系统；然后，它减少了映像构建时间，减少了推和拉的时间，并且不可避免地导致了更快的发布周期。

基于持续集成/持续部署(CI/CD)的工作流也是一个容易衡量的积极变化。通过在部署之前增加对错误和故障的可见性，您的团队可以更有效地解决缺陷，减少客户面临的问题。您可以通过正常运行时间、减少的事故数量或更少的呼叫来衡量这一点。部署的[速度](https://codeship.com/customers/travelperk)也将增加，这意味着你能够以更高的频率发布代码。构建时间很容易衡量。随着您继续优化和发展您的 Docker 映像、您的测试套件和您的 CI/CD 管道，您的目标将是看到软件质量的提高，同时缩短构建和部署时间。

但是要密切关注一个可能产生负面影响的决策，因为它可以把自己伪装成中立或者仅仅是“必要的技术债务”。例如，在没有监控和度量的情况下，不要在生产中使用容器。

负面变化是指:

*   降低系统的可见性，尤其是当组件面向客户时。
*   增加了不允许未来积极变化的复杂性。
*   在系统中引入易失性，比如不要在 docker 文件中固定版本号。

## 规划进化的下一阶段

著名的系统理论家[约翰·高尔写道](https://signalvnoise.com/posts/1414-a-complex-system-that-works-is-invariably)，“一个有效的复杂系统总是被发现是从一个有效的简单系统进化而来的。”这种模式尤其适用于您的容器化应用程序。通过关注中性或积极的变化，可以更容易地建立一个简单的解决方案，可以增加复杂性。

但是如果你没有一个明确的目标，跑得再快也不会让你到达你想去的地方。与任何系统演进一样，在开始之前确定战略优先级和度量是很重要的，并且随着新模式的引入和新特性的构建，与您的团队一起不断地重新审视它们。如果你不能或者不想度量某个东西，它很可能不值得构建。

完美的高可用性应用程序并不存在；这是一组不断移动和变化的门柱。Docker 是你的架构进入下一个发展阶段的重要的第一步，它提供了一个丰富的工具生态系统来支持开发人员解决类似的问题。由于新开发人员可以使用像 [Docker Compose](http://docs.docker.com/compose) 这样的工具让[快速启动并运行](https://blog.codeship.com/orchestrate-containers-for-development-with-docker-compose/)，你还可以让你的团队更容易入职。

关于将你的传统应用迁移到 Docker 有无数的演讲和[博客帖子](https://blog.codeship.com/?s=docker)，甚至在 DockerCon 上有一个专门的轨道，演讲者可以分享技巧并指导你完成常见的场景。

Docker 并不是会突然让你的应用程序完美运行的神奇尘埃，甚至也不是可以让你轻松地将你的整体分解成更小的服务的东西。事实上，容器化的过程可能会暴露出应用程序更深层次的架构问题。这就是从小处着手如此重要的原因。Docker 可以帮助您更早地发现这些问题，并使您能够隔离和简化您的开发和部署实践，以不断朝着弹性高可用性应用程序的目标前进。

通过将您的应用程序打包到 Docker 映像中，您可以使您的开发和部署工作流现代化，以便更频繁地发布代码，并确保您的客户使用您提供的最佳产品。你应该在 Docker 上运行你的遗产巨石柱。你应该想。

<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 68 31" version="1.1"><title>Group</title> <desc>Created with Sketch.</desc></svg>