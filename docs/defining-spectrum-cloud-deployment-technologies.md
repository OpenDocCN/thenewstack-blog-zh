# 定义云部署技术的范围

> 原文：<https://thenewstack.io/defining-spectrum-cloud-deployment-technologies/>

“云计算”在过去十年里一直是一个包罗万象的短语，用来描述任何远离硬件服务器的事物。然而，这个术语最近变得模糊不清，因为在利用云的许多不同方式上，您的选择越来越多样化。

我们已经远离了对内部部署和云的简单划分。如今，它是关于内部部署还是一系列不同的云选项。事实上，对于新手和老手来说，云可能是一个令人困惑的地方，每隔几个月就会出现新的选项，并且前景总是朝着更新更好的方向转变。

但是如何在好、更好、最好之间做出选择呢？让我们比较一下目前可用的各种[云部署技术](https://www.twistlock.com/resources/continuum-cloud-native-topologies/)，找出共同点以及它们之间的区别。

## 云中的裸机

云中的裸机服务器是硬件服务器最接近的替代品。裸机云提供真正的硬件服务器体验，但服务器不是托管在您自己的数据中心，而是位于供应商提供的云中。供应商管理服务器的维护，并让您完全控制配置和底层节点的全部容量。虽然一些提供商如 [IBM](https://www.ibm.com/ms-en/marketplace/bare-metal-server) 和 Rackspace 提供裸机云解决方案，但它们仍然是一个边缘选项，虚拟机(VM)仍然占云市场的大部分。

## 云中的虚拟机

虚拟机试图抽象出底层硬件服务器，并将其作为一个可在多个虚拟化实例间共享的资源池。虚拟机带来了更高的服务器密度，因为许多虚拟机可以打包到一台硬件服务器上。它可以在一台服务器上实现更高的应用密度和多样性。作为每个虚拟机基础的硬件虚拟机管理程序将应用程序彼此严格隔离。虚拟机是所有主要云提供商中使用最广泛的云计算实例类型，如果不是因为容器的兴起，它仍然不会受到挑战。

## “Tweener”虚拟机管理程序

在我们讨论容器之前，让我们先来看看一个介于两者之间的云解决方案，不幸的是，它最终不适合——轻量级或基于虚拟机管理程序的容器。这个选项的想法是提供两个世界的最佳之处:容器的敏捷性和极简设计，以及管理程序的强化健壮隔离(非常轻)。随着容器革命的到来，这个领域引起了相当大的兴趣，许多人想知道这是否是完美的平衡。

一些值得注意的选项包括 Canonical 的 [LXD](https://linuxcontainers.org/lxd/) ，VMware 的 VSP here Integrated Containers(VIC)，英特尔的 Clear Containers 和 Hyper 等其他利基选项。虽然这些解决方案清楚地阐述了他们试图解决的问题，但他们无法将自己与虚拟机充分区分开来，因为他们仍然需要一个非共享的内核来支持每个实例中的虚拟机管理程序。这仍然意味着要支付虚拟机管理程序税，尽管没有虚拟机那么多，但与它更灵活的表亲——容器相比相差甚远。

## 流行的容器

 [吐温·泰勒

吐温在谷歌开始了他的职业生涯，在那里，他参与了 AdWords 团队的技术支持工作。他的工作包括审查堆栈跟踪，解决影响客户和支持团队的问题，以及处理升级。后来，他建立了品牌社交媒体应用程序和自动化脚本，以帮助初创公司更好地管理他们的营销业务。如今，作为一名技术记者，他帮助 IT 杂志和初创公司改变团队构建和发布应用程序的方式。](https://www.paloaltonetworks.com/prisma/cloud) 

随着 Docker 容器的推出，云计算世界在 2013-14 年发生了翻天覆地的变化。虽然容器最初遇到了一些反对者，特别是因为它们的安全漏洞，但开发者采用的浪潮清楚地表明，这些漏洞被堵塞只是时间问题。集装箱成了一股不可忽视的力量。很快，IT 开始看到容器的价值，以及它们如何以虚拟机无法做到的方式支持 DevOps 模型。

在过去几年中，各种规模的组织都在将其工作负载从云虚拟机转移到云中的容器。真正将容器采用提升到在生产中运行容器化应用的水平的是容器编排工具的出现。Mesosphere 是第一个，紧接着是 Kubernetes 的推出，最后是 Docker 自己的 Swarm。2017 年，Kubernetes 显然已经登上了容器编排的宝座，今天它正在享受全行业的支持，并与所有云供应商集成。一系列容器即服务(CaaS)解决方案已经将自己重新命名为 Kubernetes 即服务(KaaS)。

有人试图以替代容器运行时格式的形式避免锁定 Docker 公司，如 CoreOS 的 [rkt](https://coreos.com/rkt/) 和开放容器倡议的 CRI-O。然而，Docker 仍然是领先的容器运行时，不太可能被取代。也就是说，Kubernetes 的崛起本身在一定程度上表明了生态系统对锁定的厌恶，因为它已经投票决定脱离 Docker 自己的 orchestrator。围绕 Docker 的标准化和对多样化生态系统的支持之间的这种紧张关系是一个积极的迹象，这表明容器还会有更多年的增长和成熟，因为它有望成为领先的云部署解决方案，从虚拟机手中接过衣钵。

## 无服务器容器

有了这个选项，我们仍然停留在容器的范围内。然而，改变的是部署模式。随着容器解决方案的成熟，我们现在有了一种新的服务，可以启动容器，而不需要您提供或管理任何底层服务器。

[AWS Fargate](https://aws.amazon.com/fargate/) 和 [Azure Container Instances](https://azure.microsoft.com/en-us/services/container-instances/) 是这个领域的领跑者。虽然对于开发人员来说，容器体验是不折不扣的，但从运营的角度来看，这个选项带来了新的轻松程度。它让你指定你想要启动的容器的数量，你想要为每个容器提供多少资源，然后点击“go”按钮，剩下的交给云平台。

您为使用的资源按毫秒付费，不必担心优化资源利用率，因为这一切都是在幕后为您完成的。在撰写本文时，这个选项仍处于初级阶段，Azure 的解决方案过于简单，并且没有与平台的其他部分很好地集成。作为一个解决方案，AWS Fargate 更加强大，但它处于其他竞争对手 AWS 服务的中间，如 ECS、EKS 和 AWS 近年来最大的成功之一 Lambda。

## 无服务器绝不是少

无服务器计算提供了最现代的云应用交付方法。这是最不干涉的选择，然而，就你能用它做什么而言，它还是很强大的。AWS Lambda 是当今市场上领先的无服务器计算解决方案，但也有来自 Azure 和 Google Cloud stable 的竞争产品(不要忘记 Oracle 最近收购的 Fn)。

无服务器平台允许你以函数的形式上传你的代码，让系统提供资源来执行函数。类似于 Fargate，你按使用付费。在计算能力方面，有很多可用的，因为亚马逊内部使用 AWS Lambda 来支持一些更大的应用程序。以极小的成本拥有任何初创公司都可以使用的运行亚马逊应用程序的相同能力是一个强大的命题，但它已通过 Lambda 等无服务器计算解决方案成为现实。

除了极端突发的计算和内存存储，在集成方面，Lambda 与 AWS 生态系统的其余部分深度集成，能够利用最重要的 AWS 服务进行监控，如 CloudWatch，安全服务如 IAM 和[存储服务如 S3 和 EBS](https://cloud.netapp.com/blog/ebs-efs-amazons3-best-cloud-storage-system) ，等等。赋予 Lambda 翅膀的一个集成是与 AWS API Gateway 的集成。它们一起可以将全新的功能添加到遗留的企业应用程序中，而不必彻底改造或重新设计整体架构。

此外，Lambda 是持续几秒钟的极端短期工作负载的绝佳选择。您可以使用 Lambda 对偶尔摄入的数据进行分析，或者在流量高峰时将繁重的媒体处理任务卸载给 Lambda，而不是仅仅为了这个目的而构建新的容器。

要记住的一个缺点是，如果你长期以来一直致力于 Lambda，那么锁定是不可避免的。由于组件、术语和集成完全不同，很难简单地照搬另一家提供商的竞争产品。要实现相同的功能，需要从头开始进行彻底的重构。也就是说，无服务器计算将会继续存在。它带来了强大的功能，同时也是所有云部署解决方案中最容易使用的。

## 结论

目前有[多种云部署技术](https://www.twistlock.com/resources/continuum-cloud-native-topologies/)。纯粹的选择会让人不知所措。然而，有明确的指标表明哪种选项最适合哪种类型的工作负载。无论您喜欢熟悉的虚拟机、Docker 容器的灵活性，还是无需服务器的计算方法，都没有对错之分。选择完全取决于您想要运行什么样的工作负载。有一点很清楚，这些选项中没有一个会是您需要的唯一解决方案，当组织希望充分利用云时，会有一种混合搭配的方法。因此，选择云部署技术，但要事先了解你要购买什么。

[扭锁](https://www.paloaltonetworks.com/prisma/cloud)是新堆栈的赞助商。

通过 Pixabay 的特征图像。

<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 68 31" version="1.1"><title>Group</title> <desc>Created with Sketch.</desc></svg>