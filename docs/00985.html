<html>
<head>
<title>Optimizing Data Queries for Time Series Applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优化时序应用程序的数据查询</h1>
<blockquote>原文：<a href="https://thenewstack.io/optimizing-data-queries-time-series-applications/#0001-01-01">https://thenewstack.io/optimizing-data-queries-time-series-applications/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">


<p class="translated">现在我们已经了解了<a href="https://thenewstack.io/time-series-data-care/" class="local-link">什么是时间序列数据</a>以及<a href="https://thenewstack.io/use-time-series-database/" class="local-link">为什么我们要将它</a>存储在<a href="https://www.influxdata.com/time-series-database/" class="ext-link" rel="external ">时间序列数据库</a>中，我们已经到达了一个新的挑战。与任何应用程序一样，我们希望确保我们的数据库查询是智能的和高性能的，所以让我们来谈谈如何避免一些常见的陷阱。</p>
<h2 class="translated">索引</h2>
<a href="https://www.influxdata.com/" class="clearfix infoBlock " target="_blank">

<div class="infoBlockTextBlock">
<p class="infoBlockTitle translated">凯蒂·法默</p>
<p class="infoBlockText translated">凯蒂和她的丈夫以及两条狗住在加州的奥克兰(其中至少有一条会和她聊一些有趣的科技话题)。她喜欢试验代码，破坏东西，并试图修复它。她在科罗拉多州丹佛市的图灵软件与设计学院学习编码，这给了她一个绝好的机会，在她知道如何修复之前就把东西弄坏了。</p>
</div>
</a>
<p class="translated">索引是一种经常被推荐但很少被理解的优化解决方案，它适用于大多数数据库。无论您使用的时间序列数据库是建立在Cassandra或MySQL之上还是其独特的架构之上，索引都会影响您的查询。本质上，索引是一种存储特定列中的值的数据结构，这意味着当我们通过索引字段进行搜索时，我们有一个便捷的值的快捷方式。当我们通过未索引的字段搜索时，我们必须发现值的完整路径，没有捷径或魔术。搜索未索引的领域就像不得不看着佛罗多未经编辑地走过中土世界——这需要很长时间。</p>
<p class="translated"><img decoding="async" loading="lazy" class="aligncenter size-full wp-image-4307769" src="../Images/e969ae7e903425f593a2b2f1c0b303ac.png" alt="" data-id="4307769" data-original-src="https://storage.googleapis.com/cdn.thenewstack.io/media/2018/03/f1320886-halpsofar.png"/></p>
<p class="translated">虽然索引并不是时序数据库独有的，但是我们必须记住，索引是一种数据结构，如果我们有太多的索引列或字段，它就会变得过大。过大的索引结构最终会消耗内存并减慢进程，从而抵消其优势。这里的时序问题是，没有关于应该索引哪些片段的约定，所以我们需要时刻注意我们的模式。</p>
<h2 class="translated">查询范围</h2>
<p class="translated">当一个查询让我沮丧时，我通常会跳到命令行。我在那里很开心。当我第一次发现时间序列数据库时，我就是这么做的。我跳到我的<a href="https://www.influxdata.com/time-series-platform/influxdb/" class="ext-link" rel="external "> InfluxDB </a>命令行工具，键入:</p>
<p class="translated">从“cpu”中选择*</p>
<p class="translated">我的生活在我眼前闪过。小批量用户数据的回忆让我热泪盈眶。我的终端变成了犯罪电视节目中“黑客”展示的那种屏幕。</p>
<p class="translated"><img decoding="async" loading="lazy" class="aligncenter size-full wp-image-4307770" src="../Images/862af90566765343705ac42f81fc0214.png" alt="" data-id="4307770" data-original-src="https://storage.googleapis.com/cdn.thenewstack.io/media/2018/03/8d8973f9-sudohack.png"/></p>
<p class="translated">时间序列数据的一个与众不同的特点是，数据量越大越有价值——我们存储了数百万个点。使用* (all)运行查询可能会在检索点时锁定数据库。</p>
<p class="translated">有几个选项可以在改进查询的同时限制查询。</p>
<ol>
<li class="translated">使用时间范围。许多时间序列应用程序查询从一个窗口中聚合数据，因此要充分利用这一点。</li>
<li class="translated">添加子查询。这将通过添加参数来限制您的查询范围，并确保您只获得相关的结果。</li>
</ol>
<p class="translated">确定查询范围的关键是过滤它们——尽可能具体，以避免应用程序、终端和头脑中的数据过载。</p>
<h2 class="translated">保留策略</h2>
<p class="translated">在时间序列数据的世界里，数据点就像我的保鲜盒抽屉里的袋装沙拉一样老化:我可能会保存它超过我应该保存的时间，但最终我会需要扔掉它。大量的点使得无限期地存储时间序列数据变得困难，并且即使磁盘空间允许巨大的数据量，查询也必须在巨大的数据集中运行。</p>
<p class="translated">假设您忽略了我之前的一些建议，您需要运行一个没有时间窗口或子查询的查询。您可以通过设置删除过期数据的流程来控制数据量。这是另一个部分，其逻辑依赖于您使用的数据库，但这是一个常见的时间序列问题，因此互联网上有大量的解决方案供您选择数据库。删除过期数据，为自己节省一些…时间。</p>
<p class="translated"><img decoding="async" loading="lazy" class="aligncenter size-full wp-image-4307771" src="../Images/cd956973e7a7031f515b45622d01edb9.png" alt="" data-id="4307771" data-original-src="https://storage.googleapis.com/cdn.thenewstack.io/media/2018/03/595ab37c-yeahhh.png"/></p>
<h2 class="translated">基数</h2>
<p class="translated">即使我们的查询是完美的，高基数也会降低我们的速度。列或系列中唯一值的数量决定了基数，高基数意味着大量的唯一值。当我们希望查询越来越多的属性组合时，基数往往会增加，这导致数据库花费时间:在一个系列中查找适当的值，对这些值执行任何必要的函数(即，对值求和)，对每个相关的、唯一的系列重复，然后根据查询要求组合它们。随着索引和基数的增长，运行查询的开销也在增长。</p>
<p class="translated">在一个列数据库中，我们可以通过确保我们有更少的系列和更多的点而不是更多的系列和更少的点来提高性能。时间序列中的压缩技术在长时间的值上运行更有效，所以如果我们想从数据库中获得最大的收益，我们需要遵循它的规则。</p>
<p class="translated">在建立在关系数据库上的时间序列数据库中，基数对索引的影响比其他任何东西都大，所以我们需要注意索引的大小，这样它就不会耗尽我们的资源。</p>
<h2 class="translated">结论</h2>
<p class="translated">你在这里经历了一些沉重的事情。记得深呼吸，去一个快乐的地方处理所有的信息。</p>
<div id="attachment_4307772" class="wp-caption aligncenter"><img aria-describedby="caption-attachment-4307772" decoding="async" loading="lazy" class="size-full wp-image-4307772" src="../Images/b457c2e54a9f66afc86d88aefb511afa.png" alt="" data-id="4307772" data-original-src="https://storage.googleapis.com/cdn.thenewstack.io/media/2018/03/d707d0ef-becomethesheep.png"/><p id="caption-attachment-4307772" class="wp-caption-text translated">变成绵羊。</p></div>
<p class="translated">您的时间序列应用程序应该在效率和性能方面表现出色，您可以做到这一点。注意索引、查询范围、保留策略和基数可能不能解决所有问题，但是您对数据了解得越多，就越能更好地设计查询。我们离时间序列大师又近了一步。</p>
<p class="attribution translated">InfluxData 是新堆栈的赞助商。</p>
<p class="attribution translated">凯蒂·法默的插图。</p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
<title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>

</div>
</div>    
</body>
</html>