<html>
<head>
<title>How To Do Microservices with Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Node.js做微服务</h1>
<blockquote>原文：<a href="https://thenewstack.io/microservices-node-js/#0001-01-01">https://thenewstack.io/microservices-node-js/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">

<div class="editors-note"><p class="translated">编者按:</p><a href="https://www.linkedin.com/in/matteocollina" target="_blank">Matteo Collina</a><p class="translated">nearForm的软件架构师将在</p><a href="http://events.linuxfoundation.org/events/node-interactive" target="_blank">Node Interactive</a><p class="translated">下周在俄勒冈州的波特兰。我们问他对微服务优势的看法，以及nearForm如何实现它们。</p></div>

<p/><div class="profileContainer"><section class="special"><div class="profileInfo"><p class="name translated">马特奥·科利纳</p><p class="content translated">Matteo拥有9年的软件行业经验，是全球Node.js、物联网和开源软件社区的知名人物。他在2010年开始使用Node.js，到目前为止，已经发布了近150个Node.js模块。他还是《JavaScript:最佳实践》一书的合著者(FAG米兰，2013)。</p></div></section></div><p class="translated">曾几何时，我在父亲的腿上学编程(没错，那时候我还小)。那时候，我并不太担心建筑。我只是想写视频游戏，这样我就可以玩了。后来，我在大学学习软件工程、数据库和编程，多年来，我的教授们多次重复一个例子。</p><p class="translated">第一年，他们让我写一个学生类对象。在我的工程课程中，当我们学习统一建模语言(UML)时，他们让我为大学的IT系统建模。在我的数据库课程中，我们讨论了实体-关系模型和同一个大学IT系统的相关查询。下面的例子使用了这个系统。(所有开发人员都知道，UML是有史以来最漂亮的编程语言……)</p>
<div id="attachment_838135" class="wp-caption aligncenter"><a href="https://thenewstack.io/wp-content/uploads/2015/12/Figure1.png" class="local-link"><img aria-describedby="caption-attachment-838135" decoding="async" loading="lazy" class="wp-image-838135 size-large" src="../Images/e9153fb06cf497b1b08fafd1872147aa.png" alt="The student class." data-original-src="https://thenewstack.io/wp-content/uploads/2015/12/Figure1-1024x874.png"/></a><p id="caption-attachment-838135" class="wp-caption-text translated">学生班。</p></div>
<p class="translated">任何大学制度的第一个版本都是学生班。一个学生类包含一个名字，一个姓氏，一些电子邮件地址，它有保存自己的关键责任。我大学的教授不会因此给我一个好分数。事实上，我将不得不迭代到版本2，分离出一个电子邮件类(它负责发送电子邮件！)然后通过引入Person类迭代到版本3。</p>
<p class="translated">我们的Person类是任何模型-视图-控制系统(比如Ruby on Rails、Django、Loopback、Spring MVC)的关键组件:模型。模型可以被保存、加载和持久化；他们对开发人员隐藏数据库。我们开发人员不喜欢数据库，所以我们试图将它们包装在我们可以轻松使用的良好抽象中。在过去的二十年里，我们更喜欢用对象和类来建模我们的应用程序，但是我们应该提醒自己什么是对象。</p>
<p class="translated">在软件中，对象由状态和它们的行为组成。在大多数语言中，这些行为被实现为字段和方法。字段(或属性)包含状态，方法(或函数)执行依赖于对象内部状态的操作。一个类只是一个对象类型的规范:学生类的所有实例将共享相同的属性和方法。</p>
<p class="translated">对象为开发人员提供了五个主要工具:封装、访问器、抽象、继承和多态。封装极其重要，事实上我们根本不需要对象——我们可以只使用闭包。访问器对于访问封装的值非常有用。我相信当我还是一名Java开发人员时，我花了几周时间来编写访问器向导。</p>
<p class="translated">访问器对于提供计算值是必要的，但是通常很难分布(我们应该序列化值还是不应该？那是JSON.stringify挑的吗？).继承、抽象和组合导致了UML术语中的大量类图；然而，那些图很少传达类之间正在进行的交互，以及在那里捕获了什么业务逻辑。</p>
<div id="attachment_838137" class="wp-caption aligncenter"><a href="https://thenewstack.io/wp-content/uploads/2015/12/Figure2.jpg" class="local-link"><img aria-describedby="caption-attachment-838137" decoding="async" loading="lazy" class="size-full wp-image-838137" src="../Images/91ad8dca54d12d39ea30ef7c67ca9978.png" alt="Creating Java accessors in Eclipse." data-original-src="https://thenewstack.io/wp-content/uploads/2015/12/Figure2.jpg"/></a><p id="caption-attachment-838137" class="wp-caption-text translated">在Eclipse中创建Java访问器。</p></div>
<p class="translated">围绕对象这个概念实现了几个系统之后，就可以确认对象真的好了。然而，对类之间的交互进行建模会导致系统变得非常复杂难以理解。事实上，围绕类的推理使得分布式系统极其复杂；它们很难移除，并且很难提供对运行在不同内存空间(或进程)上的实例的引用。过去，我们开发了Java RMI、CORBA、SOAP(也称为死星)以及某种程度上甚至REST。</p>
<div id="attachment_838138" class="wp-caption aligncenter"><a href="https://thenewstack.io/wp-content/uploads/2015/12/Figure3.jpg" class="local-link"><img aria-describedby="caption-attachment-838138" decoding="async" loading="lazy" class="size-large wp-image-838138" src="../Images/5fec11a96eb265a1f71580cc301b548c.png" alt=" A gigantic class diagram" data-original-src="https://thenewstack.io/wp-content/uploads/2015/12/Figure3-1024x642.jpg"/></a><p id="caption-attachment-838138" class="wp-caption-text translated">一个巨大的类图</p></div>
<p class="translated">我在上一段中提到的所有远程技术都有相同的基本原理:有一个公共API可以通过网络获得，客户端向它发送消息。API有好有坏。好的API是文档的一种形式，而坏的API是为了分发软件的唯一目的而创建的。我坚信，为了写代码而写代码，纯粹是技术债。这对我们的成品没有什么价值。事实上，我是一个懒惰的开发人员，我认为没有代码比任何代码都好(因为我们不需要维护它！).我建议大家<a href="https://vimeo.com/108441214" target="_blank" rel="noopener noreferrer external " class="ext-link">观看这个演讲</a>。</p>
<p class="translated">也许我们做错了。我们一直在设计模型和类，但也许我们应该对消息和交互建模。创造了术语“<a href="https://en.wikipedia.org/wiki/Object-oriented_programming" target="_blank" rel="noopener noreferrer external " class="ext-link">面向对象编程</a>的艾伦·凯(Alan Kay)说:“制造伟大且可增长的系统的关键更多的是设计其模块如何通信，而不是它们的内部属性和行为应该是什么。”</p>
<p class="translated"><a href="https://twitter.com/Cianomaidin/status/659016995363508224" class="ext-link" rel="external "><img decoding="async" loading="lazy" class="aligncenter size-full wp-image-840548" src="../Images/bc9f2dde3f40840046edf020439754f7.png" alt="CSVMdu2WcAAcR5I (2)" data-id="840548" data-original-src="https://thenewstack.io/wp-content/uploads/2015/12/CSVMdu2WcAAcR5I-21.jpg"/>T2】</a></p>
<p class="translated">设计消息交换而不是类可以让我们更清楚地表达代码的商业价值。事实上，上图代表了一个只有很少职责的库:以一般的方式存储、获取、更新和删除一个实体。过去，我用那个巨大的图书馆来坚持我的学生模型。</p>
<p class="translated">我们如何定义2015年和(即将)2016年的一个消息？我们可以想象它由地图、数组、字符串和数字组成——换句话说，是一个JSON。然而，JSON并不完整，因为它排除了二进制数据和数据流。JSON目前是通过网络发送数据的行业标准，但是我们可以使用msgpack之类的替代方法来处理二进制数据。这里显示了一个消息的例子:<br/></p>
<div id="crayon-642308db46351374797387" class="crayon-syntax crayon-theme-github-gist crayon-font-liberation-mono crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-always">
<p class="crayon-plain-wrap"/>
<div class="crayon-main">
<pre>{
<span class="crayon-h">  </span><span class="crayon-i">person</span>:<span class="crayon-h"> </span>{
<span class="crayon-h">    </span><span class="crayon-i">name</span>:<span class="crayon-h"> </span><span class="crayon-s">'Matteo'</span>
<span class="crayon-h">    </span><span class="crayon-i">surname</span>:<span class="crayon-h"> </span><span class="crayon-s">'Collina'</span>
<span class="crayon-h">  </span>}
}
</pre>
</div>
</div>

<p class="translated"><br/>事实上，我们可以使用Node.js回调样式轻松实现该消息的接收者:<br/></p>
<div id="crayon-642308db46358768866627" class="crayon-syntax crayon-theme-github-gist crayon-font-liberation-mono crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-always">
<p class="crayon-plain-wrap"/>
<div class="crayon-main">
<pre><span class="crayon-e">recipient</span>(<span class="crayon-i">message</span>,<span class="crayon-h"> </span><span class="crayon-e">function</span><span class="crayon-h"> </span>(<span class="crayon-i">err</span>,<span class="crayon-h"> </span><span class="crayon-i">result</span>)<span class="crayon-h"> </span>{
<span class="crayon-h">  </span><span class="crayon-i">console</span><span class="crayon-st">.</span><span class="crayon-e">log</span>(<span class="crayon-i">err</span>,<span class="crayon-h"> </span><span class="crayon-i">result</span>)
})
</pre>
</div>
</div>

<p class="translated">我们如何知道谁是接收者？我们可以设计一个类似于Java RMI或death* service registries的系统，但是这些方法在实践中都行不通。一个完全不同的解决方案是将该消息的意图编码在消息本身中:<br/></p>
<div id="crayon-642308db46359065514325" class="crayon-syntax crayon-theme-github-gist crayon-font-liberation-mono crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-always">
<p class="crayon-plain-wrap"/>
<div class="crayon-main">
<pre>{
<span class="crayon-h">  </span><span class="crayon-i">role</span>:<span class="crayon-h"> </span><span class="crayon-s">'person'</span>,
<span class="crayon-h">  </span><span class="crayon-i">cmd</span>:<span class="crayon-h"> </span><span class="crayon-s">'save'</span>
<span class="crayon-h">  </span><span class="crayon-i">person</span>:<span class="crayon-h"> </span>{
<span class="crayon-h">    </span><span class="crayon-i">name</span>:<span class="crayon-h"> </span><span class="crayon-s">'Matteo'</span>
<span class="crayon-h">    </span><span class="crayon-i">surname</span>:<span class="crayon-h"> </span><span class="crayon-s">'Collina'</span>
<span class="crayon-h">  </span>}
}
</pre>
</div>
</div>

<p class="translated"><br/>因此，我们已经定义了我们的信息。现在我们需要实现作用于消息并产生一些输出的逻辑。这是四人组的<a href="//books.google.com/books?id=6oHuKQe3TjQC&amp;redir_esc=y" target="_blank" rel="noopener noreferrer external " class="ext-link">命令模式的直接实现。我们的回调充当接收者，选择正确接收者的逻辑是调用者。我们可以使用一个巨大的开关/case或者一个巨大的if/else来实现。但是我们可以做得更好:我们可以使用模式匹配:</a></p>
<div id="attachment_838142" class="wp-caption aligncenter"><a href="https://thenewstack.io/wp-content/uploads/2015/12/Figure7.png" class="local-link"><img aria-describedby="caption-attachment-838142" decoding="async" loading="lazy" class="size-large wp-image-838142" src="../Images/fd18d8f7560421a652751782e5db1e8a.png" alt="Command line pattern in UML." data-original-src="https://thenewstack.io/wp-content/uploads/2015/12/Figure7-1024x341.png"/></a><p id="caption-attachment-838142" class="wp-caption-text translated">UML的命令行模式。</p></div>
<p class="translated">模式匹配是函数式和声明式语言中常用的一种技术；比如Erlang和Prolog中的core。非函数式语言中的模式匹配很棘手，但是在nearForm，我们开发了两个库来做这件事:patrun和bloomrun。下面是一个如何使用bloomrun的示例。<br/></p>
<div id="crayon-642308db4635a557295075" class="crayon-syntax crayon-theme-github-gist crayon-font-liberation-mono crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-always">
<p class="crayon-plain-wrap"/>
<div class="crayon-main">
<pre><span class="crayon-i">var</span><span class="crayon-h"> </span><span class="crayon-m">i</span><span class="crayon-h"> </span>=<span class="crayon-h"> </span><span class="crayon-e">bloomrun</span>()
 
<span class="crayon-m">i</span><span class="crayon-st">.</span><span class="crayon-e">add</span>({<span class="crayon-h"> </span><span class="crayon-i">cmd</span>:<span class="crayon-h"> </span><span class="crayon-s">'save'</span><span class="crayon-h"> </span>},<span class="crayon-h"> </span><span class="crayon-e">function </span><span class="crayon-e">save</span><span class="crayon-h"> </span>(<span class="crayon-i">arg</span>,<span class="crayon-h"> </span><span class="crayon-i">cb</span>)<span class="crayon-h"> </span>{
<span class="crayon-h">  </span><span class="crayon-e">alert</span>(<span class="crayon-s">'saving '</span><span class="crayon-h"> </span>+<span class="crayon-h"> </span><span class="crayon-i">JSON</span><span class="crayon-st">.</span><span class="crayon-e">stringify</span>(<span class="crayon-i">arg</span>))
<span class="crayon-h">   </span><span class="crayon-e">cb</span>(<span class="crayon-i">null</span>,<span class="crayon-h"> </span><span class="crayon-i">true</span>)
})
 
<span class="crayon-e">var </span><span class="crayon-i">msg</span><span class="crayon-h"> </span>=<span class="crayon-h"> </span>{
<span class="crayon-h">  </span><span class="crayon-i">cmd</span>:<span class="crayon-h"> </span><span class="crayon-s">'save'</span>,
<span class="crayon-h">  </span><span class="crayon-i">person</span>:<span class="crayon-h"> </span>{<span class="crayon-h"> </span>
<span class="crayon-h">    </span><span class="crayon-i">name</span>:<span class="crayon-h"> </span><span class="crayon-s">'matteo'</span>
<span class="crayon-h">  </span>}
}
 
<span class="crayon-m">i</span><span class="crayon-st">.</span><span class="crayon-e">lookup</span>(<span class="crayon-i">msg</span>)(<span class="crayon-i">msg</span>,<span class="crayon-h"> </span><span class="crayon-i">console</span><span class="crayon-st">.</span><span class="crayon-i">log</span>)
</pre>
</div>
</div>

<p class="translated"><br/>我们将这种编写软件的方式称为微服务，我们为它编写了自己的框架:Seneca.js. Seneca具有多种传输方式，从裸TCP到总线。它允许你构建一个整体，然后将它拆分成多个进程，而无需编写任何支持远程访问的代码。</p>
<p class="translated">在Seneca中，我们可以开始编写一个简单的脚本来调用它自己(参见这里的代码<a href="https://github.com/mcollina/we-are-not-object-oriented-anymore-demo/blob/28ab930bda8f1c24cb972dbb6b9dc1bdd16a1d59/devices.js" class="ext-link" rel="external "/>)。这是一段简单的代码，它将“设备”——有名称和属性的东西——存储在一个假的内存数据库中。不需要复杂的ORM。这段代码并不真正可重用，所以我们可以把它拆分成一个Seneca插件(参见代码<a href="https://github.com/mcollina/we-are-not-object-oriented-anymore-demo/blob/plugin/devices.js" target="_blank" rel="noopener noreferrer external " class="ext-link">这里</a>和<a href="https://github.com/mcollina/we-are-not-object-oriented-anymore-demo/blob/plugin/standalone.js" target="_blank" rel="noopener noreferrer external " class="ext-link">这里</a>)。事实上，我们可以使用Seneca的远程功能在网络上公开它并远程调用(参见此处的<a href="https://github.com/mcollina/we-are-not-object-oriented-anymore-demo/blob/standalone/client.js" target="_blank" rel="noopener noreferrer external " class="ext-link">和此处的</a>和<a href="https://github.com/mcollina/we-are-not-object-oriented-anymore-demo/blob/standalone/standalone.js" target="_blank" rel="noopener noreferrer external " class="ext-link"/>)。更重要的是，由于<a href="https://www.npmjs.com/package/chairo" class="ext-link" rel="external "> Chairo </a>，它与<a href="http://hapijs.com/" class="ext-link" rel="external ">哈比神</a>高度集成，因此我们可以通过标准的REST调用<a href="https://github.com/mcollina/we-are-not-object-oriented-anymore-demo/blob/hapi/server.js" target="_blank" rel="noopener noreferrer external " class="ext-link">来提供微服务，从而改善与其他团队的沟通</a>。</p>
<p class="translated">最后，我们可以使用lout <a href="https://github.com/mcollina/we-are-not-object-oriented-anymore-demo/blob/master/server.js" target="_blank" rel="noopener noreferrer external " class="ext-link">自动创建API文档</a>:<br/><a href="https://thenewstack.io/wp-content/uploads/2015/12/Figure41.png" class="local-link"><img decoding="async" loading="lazy" class="aligncenter size-large wp-image-838145" src="../Images/fdb73d867a5a3fc454c3d7b92cea7333.png" alt="Figure4" data-original-src="https://thenewstack.io/wp-content/uploads/2015/12/Figure41-1024x310.png"/></a><a href="https://thenewstack.io/wp-content/uploads/2015/12/Figure5.png" class="local-link"><img decoding="async" loading="lazy" class="aligncenter size-large wp-image-838146" src="../Images/c7aee67fbf06e8c9e1e84fa8aa34eab2.png" alt="Figure5" data-original-src="https://thenewstack.io/wp-content/uploads/2015/12/Figure5-1024x536.png"/></a><br/>在FullStack伦敦和MuCon大会上，我做了一个现场演示，大家可以在这里观看<a href="https://skillsmatter.com/skillscasts/6819-we-are-not-object-oriented-anymore-or-why-the-node-callback-style-is-awesome#showModal?modal-signup-complete" target="_blank" rel="noopener noreferrer external " class="ext-link"/>。此处有滑梯板<a href="https://github.com/mcollina/we-are-not-object-oriented-anymore-demo" target="_blank" rel="noopener noreferrer external " class="ext-link">。</a></p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
<title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>
</div>
</div>    
</body>
</html>