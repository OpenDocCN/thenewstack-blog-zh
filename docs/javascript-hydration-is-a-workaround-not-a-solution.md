# JavaScript 水合是一种变通方法，而不是解决方案

> 原文：<https://thenewstack.io/javascript-hydration-is-a-workaround-not-a-solution/>

在 web 开发中，[水合](https://www.builder.io/blog/why-progressive-hydration-is-harder-than-you-think)是一种向服务器呈现的 HTML 添加交互性的技术。这是一种技术，通过将事件处理程序附加到 HTML 元素，客户端 JavaScript 将静态 HTML 网页转换为动态网页。

然而，将事件处理程序附加到文档对象模型(DOM)并不是水合过程中最具挑战性或最昂贵的部分。

在这篇文章中，我将解释为什么我相信水合作用是开销。这不是解决办法；这是一种消耗内存和减慢启动速度的黑客行为，尤其是在移动设备上。出于本文的考虑，让我们将开销定义为可以避免但仍然导致相同最终结果的工作。

## 深入挖掘水合作用

 [美子·赫维里

miko he very 是 Builder.io 的首席技术官。作为首席技术官，miko 负责监督为 Builder.io 应用程序和软件提供支持的技术部门。在加入 Builder.io 之前，他为谷歌创建了开源平台，包括 Angular 和 AngularJS，并且是 Karma 的共同创造者。在谷歌的时候，他通过博客带来了一种测试文化。在专注于改善网络之前，他认为测试是成功的关键。](http://misko.hevery.com/about/) 

水合的困难部分是知道我们需要什么事件处理程序以及它们需要被附加到哪里。

*   **什么**:事件处理程序是一个包含事件行为的闭包。如果用户触发了这个事件，就会发生这种情况。
*   **WHERE** :需要附加什么(包括事件类型)的 DOM 元素的位置

更复杂的是，关闭 *APP_STATE* 和 *FW_STATE* 的闭包是什么:

*   *APP_STATE* :应用的状态。 *APP_STATE* 就是大多数人认为的状态。如果没有 *APP_STATE* ，你的应用程序就没有任何动态可以显示给用户。
*   *FW_STATE* :框架的内部状态。没有 *FW_STATE* ，框架就不知道要更新哪些 DOM 节点，或者框架应该什么时候更新它们。例如组件树和对渲染函数的引用。

那么我们如何恢复什么和在哪里恢复呢？通过下载并执行 HTML 格式的渲染组件。这是贵的部分。

换句话说，水合是通过急切地在浏览器中执行应用程序代码来恢复*应用程序状态*和*固件状态*的黑客行为，并且涉及:

*   正在下载组件代码。
*   执行组件代码。
*   恢复什么( *APP_STATE* 和 *FW_STATE* )以及在哪里获取事件处理程序关闭。
*   将 WHAT(事件处理程序闭包)附加到 WHERE(DOM 元素)。

让我们把前三个步骤称为恢复阶段。

恢复是框架试图重建应用程序的时候。重建是昂贵的，因为它需要下载和执行应用程序代码。

恢复速度与页面的复杂程度成正比，在移动设备上只需 10 秒钟。由于恢复是昂贵的部分，大多数应用程序的启动性能都不理想，尤其是在移动设备上。

恢复也是开销:它重建服务器已经收集的信息，作为服务器端呈现(SSR)或静态站点生成(SSG)的一部分。信息被丢弃，而不是发送给客户端。因此，客户端必须执行昂贵的恢复来重建服务器已有的内容。如果服务器将信息序列化并随 HTML 一起发送给客户机，就可以避免恢复。序列化的信息将使客户机不必急于下载和执行 HTML 中的所有组件。

换句话说，服务器已经作为 SSR/SSG 的一部分执行的代码在客户机上的重新执行使得水合成为纯粹的开销。

## 可再生性:水合作用的无开销替代方案

为了消除开销，框架不仅要避免恢复，还要避免上面的第四步:将什么附加到哪里。

为了避免这种成本，你需要三样东西:

*   所有需要的信息都被序列化为 HTML 的一部分，包括什么、哪里、*应用状态*和*固件状态。*
*   一个依赖事件冒泡来拦截所有事件的全局事件处理程序，这样我们就不必急于在特定的 DOM 元素上单独注册所有事件。
*   可以延迟恢复事件处理程序(什么)的工厂函数。

上面的设置是可恢复的，因为它可以从服务器停止的地方恢复执行，而无需重做服务器已经完成的任何工作。通过懒洋洋地创建 WHAT 作为对用户事件的响应，我们可以避免做水合过程中发生的所有不必要的工作。所有这些都意味着没有开销。

## 内存使用

DOM 元素在元素的生存期内保留事件处理程序。水合作用急切地创建所有的监听器，所以它需要在启动时分配内存。

另一方面，可恢复框架直到事件被触发后才创建事件处理程序。所以，它们消耗的内存会比补水少。此外，事件处理程序在执行后被释放，返回内存。

在某种程度上，释放记忆是水合作用的反义词。这就好像框架懒洋洋地水合一个特定的什么，执行它，然后再去水合它。处理程序的第一次和第 n 次执行没有太大区别。

## 性能差异

为了将这个想法付诸实践，我们构建了一个围绕“可恢复性”设计的框架，实现了快速启动。为了向您展示可恢复性的影响，我们构建了一个运行在 Cloudflare edge 上的[待办事项应用程序演示](https://todo-cloudflare-misko.sethealth.workers.dev)。该页面在大约 50 毫秒内准备好进行交互

我们还使用了可恢复策略(和 Qwik)来重做我们的网站， [builder.io](http://www.builder.io/) 。使用 Qwik(和我们的另一个解决方案， [Partytown](https://partytown.builder.io/) )，我们能够[减少我们网站中 99%的 JavaScript 代码，并获得 100/100 的页面速度分数](https://www.builder.io/blog/how-we-cut-99-percent-js-with-qwik-and-partytown)。(您仍然可以访问使用水合作用的[旧页面，亲自比较和体验性能差异。)](https://www.builder.io/?render=next)

## 结论

简而言之，水合作用是开销，因为它重复工作。服务器构建 WHERE 和 WHAT ( *APP_STATE* 和 *FW_STATE* )，但是信息被丢弃，而不是为客户端序列化。然后，客户端会收到没有足够信息来重建应用程序的 HTML。信息的缺乏迫使客户急切地下载应用程序并执行它来恢复位置和内容。

另一种方法是可再生性。可重用性侧重于将所有信息(地点和内容)从服务器传输到客户端。只有用户交互会强制客户端下载代码来处理特定的交互。客户端没有从服务器复制任何工作；因此，没有开销。

<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 68 31" version="1.1"><title>Group</title> <desc>Created with Sketch.</desc></svg>