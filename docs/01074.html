<html>
<head>
<title>The Slow Climb of Postgres and the Value of Persistence</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Postgres的缓慢攀升和坚持的价值</h1>
<blockquote>原文：<a href="https://thenewstack.io/the-slow-climb-of-postgres-and-the-value-of-persistence/#0001-01-01">https://thenewstack.io/the-slow-climb-of-postgres-and-the-value-of-persistence/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">


<p class="translated">那些无畏的人试图给世界带来新的创新，或者新的创业，应该记住坚持不懈的力量。即使一项技术很成功，创造者仍然必须面对许多障碍来保持和发展它的成功。</p>
<p class="translated">本周在波斯顿举行的PostgresVision会议的与会者肯定听到了对这个想法的一个很好的证明，因为数据库先驱<a href="https://thenewstack.io/dr-michael-stonebraker-a-short-history-of-database-systems/" target="_blank" class="local-link">迈克尔·斯通布雷克</a>博士讲述了他如何帮助PostgreSQL数据库进入世界，这是一个15年的旅程，充满了令人惊讶的高潮和低谷。</p>
<p class="translated">早在十年前，Stonebraker就已经帮助诞生了第一个<a href="/dr-michael-stonebraker-a-short-history-of-database-systems/" target="_blank">世界上第一个关系数据库Ingres，但是他在20世纪80年代早期回到了实验室创建Postgres(后来修改为“PostgreSQL”以反映其SQL能力)。安格尔是如此的成功。他解释说，事实上，用户希望将他们更随意的数据类型和操作符添加到它的模式中，用于地理定位等用例。Ingres对此问题最初解决方法是封装逻辑(通常非常慢)应用程序逻辑。</a></p>
<div id="attachment_7925361" class="wp-caption alignright"><a href="https://cdn.thenewstack.io/media/2019/06/a21a86d9-stonebraker-slide.jpg" class="local-link"><img aria-describedby="caption-attachment-7925361" decoding="async" loading="lazy" class="wp-image-7925361 size-medium" src="../Images/aba976283c8a91d12a66b6a4eca3169a.png" alt="" data-id="7925361" data-original-src="https://cdn.thenewstack.io/media/2019/06/a21a86d9-stonebraker-slide-300x225.jpg"/></a><p id="caption-attachment-7925361" class="wp-caption-text translated">单击以嵌入。</p></div>
<p class="translated">因此，1984年首次推出的Postgres的想法是提供一个支持“高级数据类型”(ADTs)的关系数据库系统。ADT为关系数据库的更广泛使用奠定了基础，这一新功能——建立在对象关系映射的基础上——节省了开发人员大量的时间。Postgres也是早期的数据库系统，在需要更新时不会覆盖数据，相反，只是添加一个新条目并在以后删除旧条目，这为捕获可验证的交易历史打开了大门。</p>
<p class="translated">但是Postgres并没有立即获得成功，不管它的价值有多明显。首先，Stonebraker和他的团队有了一个看似不错的想法，用当时最好的语言LISP编写这个新数据库。然而，LISP被证明是一个糟糕的选择，因为它的性能很慢——这不是你想要的数据库特性。因此，重新编写一个性能更好的C语言是必要的。</p>
<p class="translated">他们还遇到了一个潜在的致命难题。早期用户想要的不仅仅是Postgres开发者创造的粗糙的ADT。他们希望复杂的ADT能够与他们使用的商业应用程序协同工作，比如Arcinfo的地理测绘软件。但是当他们接触Arcinfo等公司并寻求帮助时，他们被告知Postgres的用户群还没有大到足以保证这样的努力。商业ADT的缺乏会使Postgres靠边站，然而软件供应商对为他们自己的产品创建ADT不感兴趣，不管它们对Postgres最终用户有多有用。</p>
<div id="attachment_7925362" class="wp-caption alignleft"><a href="https://cdn.thenewstack.io/media/2019/06/493079ed-bruce-momjian.jpg" class="local-link"><img aria-describedby="caption-attachment-7925362" decoding="async" loading="lazy" class="wp-image-7925362 size-medium" src="../Images/586e2754806c760c0d7b208c45379bbf.png" alt="" data-id="7925362" data-original-src="https://cdn.thenewstack.io/media/2019/06/493079ed-bruce-momjian-300x225.jpg"/></a><p id="caption-attachment-7925362" class="wp-caption-text translated">如今，Postgres的核心由Bruce Momjian等人维护。</p></div>
<p class="translated">数据库设计者似乎陷入了困境，至少在另一个用例出现之前是如此，它支持当时刚刚兴起但迅速发展的互联网，并为Postgres提供了丰富的用户基础。1996年，Stonebraker出售了他成立的公司Illustra，将数据库系统商业化，并继续为其他用例创建其他数据库，如面向分析的<a href="https://www.vertica.com/" target="_blank" rel="noopener noreferrer external " class="ext-link">Vertica</a>。</p>
<p class="translated">如今，Postgres是目前第四大使用最广泛的数据库系统，<a href="https://db-engines.com/en/ranking" target="_blank" rel="noopener noreferrer external " class="ext-link">根据DB-Engines排名</a>，仅领先于NoSQL MongoDB。<a href="https://www.enterprisedb.com/" target="_blank" rel="noopener noreferrer external " class="ext-link"> EnterpriseDB </a>，为开源数据库提供商业支持(也是Postgres Vision的组织赞助商)，赞助了一个独立执行的基准测试来比较Postgres和MongoDB，后者<a href="https://hackernoon.com/mongodb-transactions-5654cdb8fd24" target="_blank" rel="noopener noreferrer external " class="ext-link">刚刚增强了多事务处理能力</a>。</p>
<p class="translated">尽管MongoDB的性能很快，但基准测试公司<a href="https://www.ongres.com/es/" target="_blank" rel="noopener noreferrer external " class="ext-link"> Ongres </a>发现MongoDB很难达到Postgres 的事务性能。超过16个线程之后，<a href="https://twitter.com/Joab_Jackson/status/1143940847748177920" target="_blank" rel="noopener noreferrer external " class="ext-link"> Postgres完全将MongoDB甩在了身后</a>。</p>
<p class="translated">“PostgreSQL 11被发现在几乎每个基准测试中都比MongoDB 4.0快，”报告总结道。“吞吐量更高，从几十个百分点到一些基准的一个甚至两个数量级不等。根据基准测试，PostgreSQL的延迟也较低。”</p>

<p/>
<p> </p>
<p class="translated">为Postgres提供多主机功能仍需努力，这将使其真正可跨多个服务器扩展。尽管如此，对于已经有35年历史的软件来说，它在今天的商业堆栈中的存在并不算太寒酸。</p>
<p class="translated">斯通布莱克说，好主意从来都不是来自“在山顶与自然交流”。它们来自与用户的交谈，许多用户。意外之喜总是有帮助的(反意外之喜总是有害的)，但这不是你能控制的。</p>
<p class="translated">最重要的是，Stonebraker提醒我们，成功来自坚持，经历了不可避免的低谷和高潮。</p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
<title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>

</div>
</div>    
</body>
</html>