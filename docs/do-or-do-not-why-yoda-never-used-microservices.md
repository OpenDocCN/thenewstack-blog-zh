# 做...或者不要:为什么尤达从不使用微服务

> 原文：<https://thenewstack.io/do-or-do-not-why-yoda-never-used-microservices/>

微服务本应是一种福气，但对许多人来说，它们是一种负担。一些开发者甚至在经历了负面的经历后离开了他们。对于生产中的这种分布式、粒度软件模型来说，操作复杂性是一个令人头疼的问题。有没有可能在保留微服务优势的同时解决微服务的问题？

微服务缩短开发周期。改变一个完整的代码库是一件复杂的事情，会有意想不到的后果。这就像拆开一件毛衣，这样你就可以改变它的设计。将这个庞然大物分解成许多由两个披萨团队管理的更小的服务可以让软件更容易开发、更新和修复。正是它帮助亚马逊从一个小型电子商务机构成长为今天的巨兽。

微服务也带来了新的挑战。它们的分布式本质使开发人员面临复杂的状态管理问题。

## 尤达法则

理想情况下，开发人员根本不应该处理状态管理。相反，平台应该把它作为核心抽象来处理。数据库事务管理就是一个很好的例子；许多数据库平台支持原子事务，原子事务将单个事务分成一组更小的操作，并确保它们要么全部发生，要么都不发生。为了实现这种行为，数据库使用了事务隔离，它限制了事务中每个操作的可见性，直到整个事务完成。如果操作失败，使用数据库的应用程序只能看到事务前的状态，就好像什么操作都没有发生一样。

这种事务性使开发人员能够专注于他们的业务逻辑，而数据库平台处理底层状态。数据库事务不会半途而废，然后让开发人员来解决问题。例如，如果对应方的账户没有被记入贷方，账户就不会被记入借方。正如尤达所说:“做或不做。没有尝试。”欣赏 ACIDSQL 数据库，他会的。

“唷，”你想。“谢天谢地，我不必为了计算出事务状态而编写代码来解开未完成的操作。”可惜微服务开发者还活在那个时代。这也是为什么尤达从来不用 Kubernetes。

## 我对此有不好的预感

在微服务架构中，单个业务流程与多个服务交互，每个服务都自主运行和失败。没有一个单一的引擎在出现故障时管理和维护状态。

独立服务之间缺乏事务性，这让开发人员背黑锅。他们不仅要关注自己应用程序的功能，还必须通过管理出错时发生的事情来处理应用程序的弹性。曾经被抽象化的东西现在成了他们的问题。

在实践中，微服务架构可能很快出错，级联故障会导致性能和可靠性问题。例如，一个开发团队更新的服务可能导致其他服务失败，如果它们没有被更新来处理那些新的错误。

微服务脆弱的复杂性是一个挑战，部分原因是[最薄弱环节效应](https://www.sciencedirect.com/topics/materials-science/weak-link#:~:text=The%20%E2%80%9Cweakest%20link%20hypothesis%E2%80%9D%20implies,application%20of%20a%20specific%20load.)。一个应用程序的整体可靠性取决于它最不可靠的微服务。使用异步原语，整个事情变得更加困难。如果微服务的响应时间不确定，状态管理会更加困难。

## 看看那东西的大小

这个问题的另一个方面是，自己管理状态的伸缩性不好。用户拥有的微服务越多，管理他们的状态就变得越耗时。公司经常有成千上万的微服务投入生产，数量超过了他们的开发者。这是我们作为优步早期开发者所注意到的。优步有 4000 个微服务，甚至可以追溯到 2018 年。我们花了大部分时间编写代码来管理这个环境中的微服务状态。

开发人员已经采取了几种方法来解决自行开发的状态管理。一些人使用隐藏在 API 后面的 Kafka 事件流来对基于微服务的消息进行排队，但缺乏诊断使根本原因分析成为一场噩梦。其他人使用数据库和计时器来跟踪系统状态。

监控和跟踪可以有所帮助，但只能在一定程度上有所帮助。监控工具可以监控平台服务和基础设施的健康状况，而跟踪可以更轻松地解决瓶颈和意外异常。有许多可供选择。例如，Prometheus 提供了开发人员可以查询的开源监控，而它的兄弟 Grafana 添加了可视化功能来跟踪系统行为。

这些解决方案可能是有用的，至少为基于微服务的系统提供了一些可观察性。然而，监控工具对状态管理的任务没有帮助，把这个负担留给了开发人员。这就是为什么开发人员花费太多时间编写状态管理代码，而不是高度差异化的业务逻辑。在一个理想的世界中，其他东西会为他们抽象出状态管理。

## 使用微服务状态管理平台，Luke

简化微服务中状态管理的答案是将其作为分布式系统的核心抽象来提供。

在优步花费了太多时间手动管理微服务状态后，我们开发了一个声明管理平台。我们希望有一款产品能够让我们定义调用不同微服务的工作流(使用开发人员选择的语言)，然后执行它们，而不用担心事后的问题。

在我们最初称为 Cadence 的解决方案中，工作流自动维护状态，同时等待潜在的长时间运行的微服务做出响应。它的并发性还使工作流能够同时继续执行其他不相关的操作。

该系统在不需要开发者干预的情况下管理状态中断。例如，在硬件故障的情况下，状态管理平台将在另一台处于相同状态的机器上重启工作流，而开发人员无需做任何事情。

## 去吧。不要不做。

微服务的专用状态管理平台为我们提供了与原子数据库事务中相同的抽象。开发人员可以确定一个工作流将运行一次，直到完成。Temporal 会处理任何故障，并在引擎盖下重新启动。现在，基于微服务的应用程序只需几行代码就可以保证一个账户的扣款自动记入另一个账户。他们两全其美。

这解决了微服务和超级充电开发人员生产力的一个长期问题，特别是现在他们除了开发之外通常还负责他们应用程序的操作。最后，希望获得微服务好处的开发人员可以享受这些好处，而不必走到黑暗的一面。

<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 68 31" version="1.1"><title>Group</title> <desc>Created with Sketch.</desc></svg>