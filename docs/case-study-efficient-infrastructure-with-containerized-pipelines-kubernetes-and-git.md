# 案例研究:集装箱管道、Kubernetes 和 GitOps 的高效基础设施

> 原文：<https://thenewstack.io/case-study-efficient-infrastructure-with-containerized-pipelines-kubernetes-and-git/>

[GitLab](https://about.gitlab.com/) 赞助本帖。

 [尼科·梅森扎尔

Nico 在 panagenda 担任高级顾问。作为一名当选的 IBM 拥护者和 Docker 社区领导者，他热衷于 Kubernetes、CI/CD、自动化、DevOps、云和私有云等主题。Nico 经常在欧洲和美国的会议和用户组活动中发言。请关注他内容丰富的博客，了解最新的技术发展和趋势。](https://www.linkedin.com/in/nicomeisenzahl/) 

直到几年前，基础架构配置在很大程度上还是一项手动任务。订购新硬件、将它们安装到机架中，以及安装和配置操作系统和软件，都需要人力。现在，在云原生世界中，我们只需点击几下鼠标，就能在几秒钟内完成计算。即使是裸机也不需要太多额外的启动时间。我们还可以构建高级网络、定义防火墙规则，甚至运行我们的容器，而无需考虑底层软件和硬件堆栈。所有这些都可以在公共云、私有云或混合云中完成，这并不重要。

我们还开始通过使用 CI/CD ( [持续集成](https://en.wikipedia.org/wiki/Continuous_integration) / [持续交付](https://en.wikipedia.org/wiki/Continuous_delivery) )等实践来自动化我们的整个软件开发生命周期，以便能够跟上我们快速变化的世界。然而，我们很快意识到我们的基础设施，如我们所知，无法跟上步伐，无法在要求的时间框架内满足需求。因此，我们开始采用开发最佳实践来加快运营。

这就是 [基础设施即代码](https://en.wikipedia.org/wiki/Infrastructure_as_code) (IaC)的由来。我们开始实施 IaC，以便能够将我们的整个基础设施定义为可编程代码。这使得我们能够像以前处理代码一样处理我们的基础设施定义。我们能够:

*   在版本控制系统中存储和版本化我们的代码。
*   用代码构建我们的基础设施。
*   代码中的文档。
*   使用拉(合并)请求来管理代码更改。

回滚和不可变的基础设施不再是火箭科学。

有了 IaC，我们开始使用不同的工具和 CLI 来支持我们的基础设施代码更改。然后我们发现了一个新的约束:我们的部署工具链不能伸缩。为了能够管理不同种类的基础设施，我们需要各种工具和 CLI。

## 自动化部署管道已到达

为了能够部署我们的基础设施，我们最终需要许多本地依赖项。“我们需要等待我们的同事，因为他们拥有部署这种变化所需的所有工具”，不幸的是，我们开始更经常听到这样的话。我们更快交付基础设施变更的主要目标被打乱了。这就是为什么我们开始在考虑 CI/CD 实践的情况下使用自动化和管道。

自动化帮助我们回到正轨，交付变更，并添加符合我们时间表需求的新基础设施。自动化部署管道也有助于通过将我们工具链的所有依赖项转移到一个集中的托管部署环境中，而不是我们自己的托管本地机器中，来消除任何本地依赖项。有了自动化部署管道，我们不再有任何限制—任何人都可以随时部署我们基础架构中的变更。

然而，结果是，我们也获得了需要定义和管理的管道。因此，我们决定使用 Git 作为我们管理所有基础设施的唯一来源。我们现在使用 Git 以可观察和可验证的方式创建、管理或删除我们的基础设施。但是，此外，Git 还使我们能够存储任何依赖项，例如部署管道和任何其他相关的代码和定义。我们最终能够创建完全自动化和集成的部署管道，并且只有一个真实的来源。

但真正的问题是:我们满意吗？也许不是我们所有人。由于我们已经将所有可能的依赖关系合并到一个或两个工作节点中，这意味着我们现在要处理运行所有工作负载的大型复杂环境。例如，许多不同的工具链可能需要在不同的版本中可用，并且这些版本可能具有不同的依赖关系。你几乎可以称它为一块巨石。有没有一种方法可以帮助我们摆脱这些巨大的巨石？是的，是集装箱化。

## 然后，集装箱管道

正如我们所知，一个管道被分成不同的链节，称为阶段。这些阶段可以包含一个或多个作业。作业描述了为实现预期结果而需要执行的命令。命令可以是二进制或复杂的工具链调用。与复杂性无关，工具及其依赖项需要在管道工作节点上可用。根据您的项目，您可能还需要为多个已安装的版本选择正确的版本和路径。

集装箱管道具有以下优势:

*   管道作业之间的隔离。
*   管道作业之间没有依赖问题。
*   不变性，每个管道作业运行时都是完全相同的。
*   易于扩展。

在容器化的管道中，每个作业都将在一个容器中运行，基于一个映像，该映像包括单个项目所需的所有依赖项和特定版本的工具链。其中一个好处是，在一个项目中的不同作业之间，甚至在同一个节点上运行的不同项目管道之间，都不会有冲突。您还可以在您的任何管道工作节点上运行这个特定的管道作业，因为所有需要的依赖项都被放在容器映像中。

![](img/0a01946581e179a0d78808f251b6b973.png)

照片由 Sergio Souza 通过 Unsplash 拍摄。

这是一个简化的容器化管道的样子(为了清楚起见，这个例子跳过了不同的管道阶段):

让我们假设我们想要建立一个管道，用于在公共云上建立一个托管的 Kubernetes 集群，并管理一些基本的 Kubernetes 资源，例如 [一个 Pod 安全策略](https://kubernetes.io/docs/concepts/policy/pod-security-policy/) 和 [基于角色的访问控制(RBAC)](https://kubernetes.io/docs/reference/access-authn-authz/rbac/) ，它们应该在任何生产环境中都存在。

我们将使用 Terraform 来创建托管的 Kubernetes 集群( [使用 Terraform](https://www.terraform.io/) 作为示例，但是也可以使用其他工具)。这意味着我们的管道作业映像只需要一个依赖项:Terraform CLI。在这个例子中，我们使用 [GitLab CI](https://about.gitlab.com/product/continuous-integration/) ，它自动从它的 Git 存储库中检出我们的最新代码(取决于您的 CI/CD 工具链，您可能需要自己提供这个)。我们的管道作业映像的 Dockerfile 示例可以是:

```
FROM alpine:latest
ENV TF_VERSION=0.12.0-r0
RUN apk add  --update  --no-cache ca-certificates terraform=$TF_VERSION
ENTRYPOINT  ["terraform"]
CMD  ["--help"]

```

对于我们的第二个管道作业，我们只需要第二个容器映像来提供 kubectl CLI，以允许我们与我们的 Kubernetes 集群通信并管理资源。 [GitLab CI](https://about.gitlab.com/product/continuous-integration/) 通过使用其 Kubernetes 集成在运行时自动提供所有需要的凭证(基于您的 CI/CD 工具链，您可能需要在运行时挂载您的凭证来访问您的集群)，使这一步变得更加简单。

如您所见，每个管道作业都使用其专用的容器映像，其中包含单个作业所需的需求。

## 添加 Kubernetes 和 GitOps

说到 Kubernetes，在 Kubernetes 上运行容器化管道还有另外一个积极的副作用:容器化管道通过将所有依赖项打包到容器映像中，使我们更容易在不同的环境中运行管道作业。在 Kubernetes 上运行它们将进一步增强这种优势！Kubernetes 将对下面的一切进行抽象，这将使我们能够更容易地在任何地方运行我们的管道，同时也帮助我们将工作负载整合到更少的环境中。

最后，简要说明一下 GitOps:自动化，as‌ ‌well‌ ‌as‌ ‌Git 作为 a‌ ‌single‌ ‌source‌ ‌of‌ ‌truth，是关键。GitOps 真正与众不同的地方是使用了“拉”CD 模型，这意味着更改不再通过管道进行。

此外，环境本身会做出改变，并确保达到期望的状态。这是通过使用能够分析其环境并知道如何达到期望状态的代理来实现的。由于这些代理，GitOps 目前只是 Kubernetes 的一个话题。

总结一下:去年，我们提供基础架构的方式发生了很大变化。这样做的好处是提高了我们的效率和透明度，并将在未来继续改进和发展我们的流程。您也可以尝试这些新技术，并告诉我您的想法——正如我在上面所描述的，随着 Git 和 Kubernetes 的成熟，使用这些技术是可能的，并且变得越来越简单。

有关基础设施最佳实践的更多案例研究讨论，请参加 10 月 9 日在伦敦举行的 GitLab Commit。GitLab 的首次用户活动将通过战略和技术讨论、经验教训、开发生命周期的幕后观察等展示 DevOps 的强大功能。

通过 Pixabay 的特征图像

<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 68 31" version="1.1"><title>Group</title> <desc>Created with Sketch.</desc></svg>