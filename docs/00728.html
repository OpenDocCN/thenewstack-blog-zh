<html>
<head>
<title>Solving Kubernetes Configuration Woes with a Custom Controller</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用定制控制器解决Kubernetes配置难题</h1>
<blockquote>原文：<a href="https://thenewstack.io/solving-kubernetes-configuration-woes-with-a-custom-controller/#0001-01-01">https://thenewstack.io/solving-kubernetes-configuration-woes-with-a-custom-controller/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">


<p class="translated"><a href="https://pusher.com/" class="clearfix infoBlock " target="_blank"><div class="infoBlockTextBlock"><p class="infoBlockTitle">Joel Speed</p><p class="infoBlockText">Joel是Pusher的云基础设施工程师，致力于构建他们的内部Kubernetes平台。他已经在DevOps工作了四年多。最近，他一直专注于扩展Kubernetes的项目，构建准入和定制资源控制器，以改善开发人员在该平台上的体验。Joel热衷于自动伸缩、部署管道、认证和授权。他还为Pusher工程团队制造并维护了一个聊天机器人Marvin。</p> </div> </a></p><p class="translated">两年前，<u> <a href="https://pusher.com" target="_blank" class="ext-link" rel="external ">推手</a> </u>开始搭建一个基于Kubernetes的内部平台。当我们从单一产品过渡到多产品公司时，我们希望帮助我们的产品团队花更少的时间来担心基础设施等共同的问题，并能够将更多的精力放在为我们的产品编写业务逻辑上。</p>
<p class="translated">在此期间，我们的平台团队已经解决了许多Kubernetes无法开箱即用解决的问题。直到最近，我们还没有解决配置的问题。不幸的是，在普通的Kubernetes集群中，与大多数资源不同，对配置(存储在ConfigMaps和Secrets中)的更改不会触发集群内运行的应用程序状态的任何更改。</p>
<p class="translated">在我们的平台上运行的许多应用程序，无论是第一方还是第三方，都不能动态地重新加载它们的配置。当它们的配置被更新时，尽管装载到容器中的文件可能被更新(如果它们来自配置图)，但是应用程序不观察变化，并且仅在过程被重启时加载新的配置，或者更典型地，新的pod被创建并且现有的pod被终止。</p>
<p class="translated">由于Kubernetes通常会为您协调所需的状态，所以一个典型的用户可能会认为更新配置映射或密码会使应用程序加载新的配置。因为情况并非如此，所以用户很容易更新配置图或密码，而不替换安装配置的pod，从而使运行配置不同于更新的期望配置。</p>
<h2 class="translated">我们的配置问题是什么？</h2>
<p class="translated">通常在Kubernetes中，当你更新你想要的状态时，会有一些控制循环来查看世界的状态，并调整状态使其符合你想要的变化。当您为部署中的Pod更新模板时，部署控制器将用新的Pod替换所有现有的Pod，以匹配更新的规范。</p>
<p class="translated">Kubernetes中的配置存储在配置映射和机密中。这些通过文件挂载或环境变量挂载到pod中，以允许容器进程读取数据。然而，这种方法有一个问题。配置映射和机密都没有版本，也没有控制循环。虽然更新配置映射会更新Pod内的已挂载文件，但更新机密不会触发集群内的任何更改。</p>
<p class="translated">推料器平台上的产品依赖于一个称为桥的关键部件。网桥是我们入口层的一部分，将流量路由到后端服务，并在此过程中处理大量推送协议逻辑。不幸的是，网桥不能动态地重新加载它的配置。</p>
<p class="translated">该组件对于我们在该平台上运行的所有产品(Chatkit、Beams、TextSync)的运行至关重要，当它关闭时，其他一切都会随之关闭。</p>
<p class="translated">在过去的两年里，我们在这个平台上没有发生太多的事件(诚然，我们才发布了几个月)，但是当我们遇到中断时，事后分析几乎总是会得出相同的结论。桥内运行的配置不是它装载的配置映射内的配置。</p>
<p class="translated">大多数事件都是由一个基础架构团队对Kubernetes集群进行更改而引发的。我们不变地运行我们所有的机器，因此，当我们想要做出改变时，我们替换集群中的每个节点，并且依次替换每个单元。新的pod将从此时存在的任何配置开始。</p>
<p class="translated">我们发现，尽管我们有适当的程序，但在配置更新时，我们组件的pod并不总是被替换，在某些情况下，pod仅在应用了损坏的配置后大约两周才被替换。如果您曾经遇到过同样的情况，您将会理解不知道发生了什么变化，并且在没有版本控制的情况下，无法回滚是多么可怕的事情。</p>
<h2 class="translated">我们如何解决这个问题</h2>
<p class="translated">我们目前正在使用我们的GitOps项目<u> <a href="https://github.com/pusher/faros" class="ext-link" rel="external "> Faros </a> </u>来自动化我们的部署管道。我们的平台服务团队有许多服务不能动态地重新加载配置，并提出了对项目的关注。为了能够在git merge上同步配置更新，他们需要保证配置更新将被实际部署，并且在配置被破坏的情况下，有人将被通知git恢复他们刚刚部署的更改。</p>
<p class="translated">这就是我们的新项目<u> <a href="https://github.com/pusher/wave" class="ext-link" rel="external "> Wave </a> </u>，一个使用<u> <a href="https://github.com/kubernetes-sigs/kubebuilder" class="ext-link" rel="external "> Kubebuilder </a> </u>构建的定制控制器的用武之地。Wave的作用是确保当一个配置图或密码被更新时，任何安装了所述配置图或密码的部署替换其所有的pod。Wave有效地推动了Kubernetes内置的<u> <a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" class="ext-link" rel="external ">部署</a> </u>控制器，并让它执行滚动更新，删除运行旧配置的pod，并使用更新的配置创建新的pod。</p>
<h2 class="translated">Wave是如何工作的？</h2>
<p class="translated">与其他Kubernetes控制器一样，Wave从Kubernetes API为部署对象订阅事件。这意味着，每当在任何部署上执行操作(创建/读取/更新/删除)时，Wave都可以处理部署，并查看是否需要进行任何更改。</p>
<p class="translated">Wave做的第一件事是检查部署上是否有<u> <a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/" class="ext-link" rel="external ">注释</a></u>(wave.pusher.com/update-on-config-change:为真)。如果注释不存在，Wave会忽略部署。这使得Wave成为一个选择加入的控制器，为了从Wave中受益，用户必须手动指定他们的部署由Wave管理。因此，部署到现有的Kubernetes集群是安全的，不用担心它会突然开始干扰不需要其更新触发功能的已部署工作负载。</p>
<p class="translated">其次，Wave解析部署，并查找对配置映射的引用和装载到部署创建的pod中的秘密。然后，它获取每个配置映射和装载的机密，并使用可再现的算法，创建当前配置的散列。哈希表示来自所有配置映射和已装载机密的配置，只有在添加新装载、取消装载或修改装载数据中的任何字段时才会发生变化。</p>
<p class="translated">然后将该散列作为注释放置在部署中的<u> <a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#pod-template" target="_blank" class="ext-link" rel="external "> Pod模板</a> </u>上。这就是我们利用内置Kubernetes部署控制器的地方。通过修改Pod模板的元数据，部署控制器将此视为更新，并开始处理部署更新策略。</p>
<p class="translated">总之，每当config被更新时，Wave计算的散列将改变，Wave将更新部署的Pod模板上的散列，然后部署控制器将读取更新策略，并通过创建新的副本集和新的Pod来开始新配置的展示。</p>
<p class="translated">由于Wave还订阅配置图和机密的事件，它可以使用<u> <a href="https://kubernetes.io/docs/concepts/workloads/controllers/garbage-collection/#owners-and-dependents" class="ext-link" rel="external ">所有者引用</a> </u>来跟踪哪些部署正在安装哪些配置图和机密，并且每当其中一个发生更新时，协调父部署以更新其散列。然而，我们不使用所有者引用的垃圾收集部分。一旦部署被标记为删除，Wave将删除所有所有者引用，否则部署拥有的配置映射和机密也将被删除。</p>
<h2 class="translated">下一步是什么？</h2>
<p class="translated">波尚未完成！目前只支持部署。将来，我们计划为Wave添加一个触发更新<u> <a href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/" class="ext-link" rel="external "> Daemonsets </a> </u>和<u><a href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/" class="ext-link" rel="external ">statefullsets</a></u>的功能。</p>
<p class="translated">我们已经将Wave部署到我们的系统中，并在我们的团队和更广泛的组织中实现了许多部署。自从开始使用它以来，我们已经更快地捕捉到损坏的配置(不再有生产事故),并且已经能够减少许多手动部署程序(部署配置，缓慢重启pod)。</p>
<p class="translated">这个项目解决了我们最长期的问题之一。我们现在部署时更有信心，并且知道对所需配置的更新将在应用后立即运行。</p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
<title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>
</div>
</div>    
</body>
</html>