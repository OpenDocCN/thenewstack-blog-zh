# Bindle 如何简化存储和分发云原生应用

> 原文：<https://thenewstack.io/how-bindle-makes-it-easy-to-store-and-distribute-cloud-native-apps/>

开源软件包管理器 Bindle 的聚合存储模型非常适合 WebAssembly，以至于它可以成为 T2 WASM 组件注册中心的基础。

云原生架构依赖于微服务，这些微服务将复杂的应用程序分解为更小的可组合部分，但仍然存在存储和安装这些单独部分的问题，这通常需要开发人员处理多个运行时、云服务和相关工件。

甚至 web 应用程序也有 HTML、CSS、JavaScript 组件——通常包括多个库和依赖项——以及任何需要的图像和其他媒体:应用程序是多个部分的集合。对于 [WebAssembly](https://webassembly.org/) 来说更是如此，其中应用程序二进制文件需要可移植到许多不同的系统。根据部署选择或应用程序将运行的系统上的可用资源，可能需要不同的组件。

如何轻松地表示复杂的相互依赖关系，例如一个可以配置为使用 MySQL、PostgreSQL 或 SQLite 作为数据库的应用程序，如果您选择 MySQL，则需要一个助手库；如果您在没有 GPU 的系统上部署，则需要一个 shim 库；同时，软件包不会太大，以至于在带宽紧张时部署不切实际？

这就是[Bindle](https://github.com/deislabs/bindle)package repository system(即将发布 0.9 版本)设计用来解决的常见场景，它使用聚合存储将相关对象分组进行分发，在聚合存储中，客户端可以只检索他们需要的包部分。

“我们知道，随着 WebAssembly 的成熟，WebAssembly 中的应用程序将由复合二进制文件构建而成，其中有一大堆不同的二进制文件存储在一起，可以在不同的配置中相互链接，我们构建了 Bindle 来实现这一点，”Bindle maintainer 和[Fermyon Technologies](https://www.fermyon.com/)CEO[Matt Butcher](https://www.linkedin.com/in/mattbutcher/)告诉新堆栈。

“该系统旨在以我们希望的方式在云原生生态系统中概念化应用。应用程序不应该被认为是二进制的:那是我们多年前思考应用程序的方式。现在，我们必须从不同微服务的聚合角度来考虑应用程序，甚至可能是一些文件和对象之类的东西。它们都必须以一种非常特殊的方式组合在一起，才能完成各自的工作，但它们实际上是几个不同的二进制文件。”

## 银器抽屉

butcher and Bindle maintainer[Taylor Thomas](https://www.linkedin.com/in/oftaylor/)用厨房里的银器抽屉来比喻，你可能会在那里放筷子、吸管、滤茶器以及刀叉和勺子，规则是“你需要两根筷子，可能还需要一把勺子”或“这把勺子只用于喝汤，这把勺子只用于喝茶”。

“银器抽屉的想法是，不管形状和大小，你都应该能够将所有这些东西存储在同一个东西中，并向系统解释这是我需要检索它的方式，这些是我得到的东西。”

Bindle(以绑在一根长棍子末端的手帕包裹的包裹命名，你可以想象它可以装下你需要的一切)处理一组相关的对象，每个“bindle”包裹都有一张发票:一张清单，解释 bindle 做什么，列出组成包裹的所有包裹。

大多数包管理器都倾向于将单个包作为压缩文件或整个存储库来分发。当 Bindle 客户端检索发票并读取包裹列表(可能是 WASM 模块、文本文件、JavaScript、CSS、图像、视频、垫片或依赖项的组合)时，它可以使用发票中的条件组和功能描述来挑选它需要的组件、依赖项和附加项，并仅下载这些组件、依赖项和附加项。

发票必须有版本号(Bindle 使用语义版本化，所以如果你搜索 v1.2，而 v1.2.4 是最新版本，你会得到提示，但是如果你知道你需要 v1.2.3，你可以明确地搜索它)。

条件组可以列出需求(应用程序需要一个自带的 shell，因此至少需要安装 Bash、Korn、Zsh 或 Busybox 中的一个)、可选的插件或依赖链(应用程序至少需要一个 web 服务器，如果安装了 NGNX，还必须安装一个特定的 NGNX 模块)。

“这就是我们分组的方式，”托马斯解释道，“有些东西我们一起使用，但彼此完全不同。”

您可以使用一个组来列出 SQLite、PostgreSQL 和 MySQL plus helper library 数据库选项，以及没有 GPU 时所需的 shim 库特性。人们不再下载六个组件，而是获得他们需要的两三个组件，从而节省了网络带宽和存储空间。如果其中一个包已经安装了，因为另一个包使用了相同版本的 Postgres，那么 Bindle 客户端将使用这个包，而不是再次下载它。

“使用 Bindle 你可以节省很多带宽，”他指出。“不必下载整个 tarballs，其中一半是你不需要的，现在你可以根据你的情况，只下载你需要的东西。”

这些发票可以根据应用的需要简单或复杂。

“你不必让你的应用程序适应现有的模式，”Butcher 解释说:“你可以按照你想要的方式存储应用程序，然后按照你以后需要的方式重新组装它。”

## **存储和部署**

他举了一个例子，他为一个有一只非常挑剔的猫的同事编写了一个游戏。[挑剔的胡须](https://www.finickywhiskers.com/index.html)应用程序有七个微服务打包成一个捆绑包:一个用于记分牌，另一个用于处理你点击的按钮，为猫提供不同类型的食物。"当我们刷新挑剔的 Whiskers 站点时，它会取出 bindle 并从中重新构建应用程序."

“这就是能够在 Bindle 中存储东西的灵活性。您可以将七种不同的微服务打包在一个大的应用程序中，并将其部署到[您需要的]任何地方。你可以存储一个二进制文件，你可以存储一个有几十个不同二进制文件的应用程序:如果你愿意，你可以在其中存储一个文件系统。事实证明，对我们来说，这是一种非常灵活的形式。”

“对我来说很惊讶，甚至没有人想过这样做，”托马斯告诉我们。“每个人都想把它想象成一个 tarball 或某种非常扁平的结构，Bindle 采用的方法是，你可能想用不同的部件组装东西。在 Cosmonic 内部，我们已经看到了很多例子，我们需要能够将一些不同的完全不同的组件进行版本化，然后将它们放在一起。”

Bindle 背后的想法可能听起来很熟悉，如果你遇到过 [Porter、](https://github.com/getporter/porter)一个由 Bindle 创造者的同事创建的打包工具，最近达到了 [1.0](https://getporter.org/blog/v1-is-here/) ，或者[云原生应用捆绑包](https://thenewstack.io/microsoft-cnab-simplifies-container-deployment-to-distributed-applications/) (CNAB)规范。“CNAB 是用来安装应用程序的，是用来把应用程序安装到任何地方的，而 Bindle 是用来存储这些东西的，”Thomas 解释道。“这两个项目来自同一个团队，因为我们从两个不同的角度思考这个问题:一个是应用程序的实际部署，另一个是如何存储它。”

Bindle 最初是作为一种存储和共享 WebAssembly 应用程序和二进制文件的方式设计的，尽管它被证明有更广泛的用途。Butcher 将 CNAB 描述为容器生态系统的一种类似方法，称 Bindle 为“我们与 registries 和 CNAB 合作所学到的——应该有一种更好的方法来存储基于微服务的应用程序，然后交付基于微服务的应用程序”。

托马斯建议，CNAB 和宾德尔可以一起工作。"你可以让 CNAB 从 Bindle 服务器获取它需要的工件."

WebAssembly 不是 Bindle 唯一有用的地方；“我们发现，还有许多其他东西与 WebAssembly 没有任何关系，但 web assembly 却派上了用场。”让实现细节因系统而异，并允许运行时决定下拉什么的原则适用于许多场景。

Bindle 可以为构建基础设施处理文件系统快照，在这些基础设施中，您需要特定编号的版本，或者您希望在无法控制可用硬件的边缘进行部署(并且不想为不同的硬件创建多个容器映像)。“我假设如果 Bindle 继续增长，我们将开始看到像 Bindle 这样的特定运行时感知的东西，以及如何利用它们，”Thomas 说。

“我们需要这个已经很久了。”

## **安全包注册表**

字节码联盟[的第一个特殊兴趣工作组](https://thenewstack.io/what-is-webassembly/)(构建 WebAssembly 标准共享实现的行业组织)是 SIG-Registries，它正在为 WASM 组件的包注册制定规范。“一个中心枢纽，让我们分享我们正在构建的不同 WebAssembly 应用程序和二进制文件，然后允许人们从中提取、组装自己的应用程序并上传，”Butcher 解释道，并将其与 npm 或 WASM 的 Docker Hub 进行了比较。

Bindle 已经被提议作为存储层，在它上面有一个 API 包，可能会成为参考实现。

使用 WebAssembly 组件模型，应用程序是由像乐高积木一样的小单元构建的。SIG-Registries 工作组的 Bailey Hayes 解释说:“一个组件单独依赖于许多其他组件:如果你得到一个组件，这不足以运行任何东西。Bindle 使得获取你需要的所有组件和嵌套依赖变得容易。“对于 SIG-registry，我认为我们将建立在 Bindle 已经提出的许多东西以及所有这些部分的工作方式之上。”

WebAssembly 的吸引力不仅在于代码可以在许多不同的地方运行，还在于性能和安全性的结合。WebAssembly 代码应该被设计为只具有它真正需要的功能和权限，这与提供更好的安全模型的沙盒一样多，因为组件可以做像打开套接字这样的事情，这实质上是在沙盒中打了一个洞。Hayes 说，导入组件意味着你依赖于它们的良好表现和良好编写，所以组件注册需要实现一个信任链。

“这是对我们过去如何进行注册的彻底反思，我们希望在未来如何进行，就像我们之前的许多其他 WebAssembly 标准一样，这都是关于将安全性作为首要原则。”

Bindle 是一个很好的选择，因为它被设计成默认安全的。Bindles 是不可变的:它们被加密散列和签名，无论是名称还是内容都不能改变。

“毫无疑问，当我从注册表中取出某个东西时，它与之前有人放入注册表中的东西完全相同，”Taylor 解释道。“它没有被篡改的意义，或者一个坏演员可以进来，把一件事重定向到另一件事。”

即将到来的 0.9 版本将要求所有的捆绑包都需要[签名](https://github.com/deislabs/bindle/blob/main/docs/signing-spec.md)；“从一开始就一直声明这将是计划，”托马斯指出，但将有一个 RC 版本，以确保它不会破坏像 Fermion，Cosmonic(托马斯和海耶斯工作的地方)和 Suborbital 这样的组织已经在使用 Bindle。

因为 Bindle 是为签名 Bindle 设计的，虽然他们需要做更多的工作，但这不会显著改变开发者的体验。“Bindle 密钥规范[意味着]基本的默认设置是让我至少获得最简单的安全级别，也就是说我信任这个主机，我必须知道我从那个主机下载的每一样东西实际上都是来自那个主机。”

Cosmonic 首席执行官 Liam Randall 指出，最重要的是，组织将能够在 WebAssembly 和 Bindle 中建立更具限制性的政策，但仍然给开发人员以灵活性。“您可以说‘只允许导入经过扫描或符合特定要求的模块’您可以拥有特定于组织的策略，向我显示符合我的策略的选择。在一个常规的开发管道中，也许你有一个组件的主要和次要编号，并且只有主要的得到一个安全评估，也许在 prod 中你只是想要那些，但是在 dev 中，你会想要其他选项。"

“我可以看一眼这些东西，然后说我想冒多大的风险，”海斯指出。

## **进入 Bindle 1.0**

Thomas 解释说，Bindle 的 1.0 版本可能不会跟随 0.9 版本，直到有足够的使用量来表明规范没有遗漏任何需要突破性变化的边缘情况。

“我们还没有设计注册表，它基本上是一个从头开始的存储系统。我们有一个背景，有人做过一些小事情，与 OCI 和生态系统的不同部分合作过，但因为这是一种全新的做事方式，我们知道我们可能会犯一些错误，所以我们不想太快打破规范。”

参与过 Helm 这样的项目后，Bindle 的维护者对语义版本和带宽兼容性有着严格的要求，对 1.0 唯一的突破性改变是与安全相关的。“这是我们遵循的规则，因为我们所有人都因为试图从一个所谓的 Kubernetes 次要版本升级到下一个 Kubernetes 次要版本而受到伤害，并且有三个 API 破坏了你，我们不想对人们这样做。”

这并不意味着 Bindle 现在不准备在生产中使用:像 Fermion 和 Cosmonic 这样的平台都是在 Bindle 上构建的(Cosmonic 将其用于 WebAssembly 和不是用 WebAssembly 构建的平台的一部分)。“它使用起来足够可靠，只是不是 1.0，因为我们想保留做出突破性 API 更改或突破性规范更改的权利。”

这对于一个规范来说尤其重要，Thomas 说这个规范的目标是“简单、直截了当和开放”,并且将针对平台可能需要设置和运行 Bindle 的不同方式以多种方式实现。已经有一个 F#实现和一个将 Bindle 实现为一组 wasmCloud actors 的提议。

泰勒认为，silverware drawer 隐喻的灵活性是 Bindle 如此强大的部分原因，因为它允许在探索 SIG-Registries 这样的项目时进行实验(最终可能会有比 Bindle 所需的更严格的包 API)。“人们可以尝试不同的事情，看看当我们把它变得僵化时，哪一套假设会成立。”

“它具有足够的延展性，可以随着标准移动，但同时内部结构非常坚固。”

Butcher 说，这来自于不得不不断重建工作系统的挫败感。“作为开发人员，我们倾向于为特定的问题构建解决方案，但技术发展如此之快，以至于经常是几年后我们就会说，哎呀，我们做了一个假设，而这个假设不再适合设计。”

“我已经做了 25 年的软件开发人员，我认为这个行业的经验告诉我，技术作为一个整体是向前发展的，但是单个技术的寿命非常短。因此，我们必须不断地重新审视假设:昨天看起来安全的假设，今天可能不安全，明天肯定会过时。作为一个行业，转向更灵活的解决方案将是一件重要的事情:如果我们想以某种方式打破不得不不断重新架构的陷阱，特别是低级稳定的东西，那么我们需要在设计中更好地考虑灵活性。”

<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 68 31" version="1.1"><title>Group</title> <desc>Created with Sketch.</desc></svg>