# Kubernetes 操作系统指南

> 原文：<https://thenewstack.io/a-guide-to-linux-operating-systems-for-kubernetes/>

[](https://www.linkedin.com/in/francissteve/)

 [他现在是 Talos 系统公司的首席执行官。](https://www.linkedin.com/in/francissteve/) [](https://www.linkedin.com/in/francissteve/)

因此，您同意 Kubernetes(或者考虑探索一些 Kubernetes 部署)。)这有很多很好的理由，您可能很清楚— [Kubernetes](https://thenewstack.io/category/kubernetes/) 负责容器管理，将工作负载调度到一个集群上，处理扩展和冗余，自动化部署和回滚。Kubernetes 是一个与基础设施无关的系统，通过使用声明性语句来描述系统和应用程序应该处于的状态，它将托管元素驱动到所需的状态。这使得功能强大且可扩展的系统更易于管理。当然，这种“易于管理”有一个学习曲线，但是在提供可伸缩性和基础设施可移植性的基础设施上获得现代基于容器的软件开发的好处是非常值得的。

虽然 Kubernetes 确实支持容器的操作可伸缩性和管理，但它不能直接帮助您管理 Kubernetes 本身所依赖的基础设施。Kubernetes 本身就是一个应用程序(或一组应用程序)，这些应用程序必须在某个地方运行。尽管您可能听说过，Kubernetes 不是一个操作系统，但仍然依赖于安装在节点上的 Linux(或 Windows)。Kubernetes 可以在 AWS 或 GCE 等云提供商或 VMware 等虚拟化平台上运行，也可以在 Docker 等工具上的笔记本电脑中运行，或者在裸机服务器硬件上运行，但所有这些都需要先安装操作系统。(有些，如 AWS EKS，消除了管理控制平面节点的需要，但仍然要求您为工作节点设置 Linux 服务器。)

在操作上，重点是 Kubernetes 及其运行的工作负载——这是理所应当的！—但这导致了 Kubernetes 部署中常见的一个问题。虽然 Kubernetes 可能会定期打补丁和升级，但底层操作系统的维护、更新、安全和操作往往会被遗忘或忽视——至少在进行安全审计之前是如此！！我经常听到 sre 和系统管理员说，必须管理 Linux 和 Kubernetes 会导致额外的工作。Kubernetes 需要打补丁、更新、保护、控制用户访问等等——就像普通的 Linux 操作系统一样。但是仅仅因为这些任务是在 Kubernetes 级别上完成的，并不意味着它们可以在 OS 级别上被忽略。然而，选择正确的底层操作系统发行版可以大大减少维护操作系统的工作量，并减轻不保持最新的影响。

因此，假设您需要首先安装 Linux 来运行 Kubernetes，并且会有来自底层操作系统的暗示——您应该运行哪个 Linux 发行版？有多种选项可供选择，但它们通常分为两种类型:容器优化的 OSs 或通用 OSs。

## 通用 Linux 操作系统

这些是“普通的”Linux。

大多数人都熟悉运行通用 Linux 操作系统，如 Ubuntu、Debian、CentOS、Red Hat Enterprise Linux (RHEL)或 Fedora。这是在 Kubernetes 集群下运行通用操作系统的主要优势之一——您的系统管理员将熟悉如何安装、更新和保护这样的 Linux 发行版。可以使用现有的工具集来启动服务器、安装操作系统并将其配置为基本安全级别。现有的补丁管理和安全检测工具应该可以在这些系统上很好地运行，即使在它们上面运行 Kubernetes。

然而…

通用 Linux 系统带来了…通用 Linux 管理开销。这意味着用户帐户管理、补丁管理、内核更新、服务防火墙、SSH 安全、禁用 root 登录、禁用未使用的守护程序、内核调整等都需要完成并保持最新。如前所述，这些任务中的许多可以用现有的工具(Ansible、Chef、Puppet 等)来完成，这些工具可能正在管理其他服务器——然而，更新清单或控制文件以便服务器概要文件适合 Kubernetes 的主节点和工作节点是……不平凡的，我们应该这样说。

另一个问题是操作系统变化与 Kubernetes 维护的协调。通常没有协调，所以安装后操作系统保持原样。随着时间的推移，Kubernetes 将(有希望)升级，但底层操作系统可能会保持静态，在各种软件包和安装的内核中慢慢积累已知 CVE(常见漏洞和暴露)的负担。

理想情况下，您希望自动化平台(如 Ansible 或 Puppet)与 Kubernetes 协调，以便在不中断 Kubernetes 操作的情况下升级节点的操作系统。这意味着系统需要:

*   封锁节点，这样就不会在节点上安排新的工作负载
*   清空节点，以便将所有正在运行的单元移动到其他节点
*   更新并修补节点
*   取消节点上的编码

当然，系统需要确保不要一次更新太多的节点，这样集群的工作负载容量不会受到负面影响(也不要更新太少的节点，这样大型集群的更新不会慢于补丁和更新的发布)。您可能希望协调操作系统更新和 Kubernetes 更新，以最大限度地减少重启和中断，但您还需要在短时间内支持更关键的操作系统更新。

通用 Linux 操作系统的最大优势在于员工对它的熟悉程度。这意味着他们不仅熟悉部署，还熟悉故障排除技术。他们可以使用(如果还没有的话，安装)他们的常规操作系统工具，如 tcpdump、strace、lsof 等。可以很容易地修改配置来纠正错误和测试替代方案(这既是一件好事也是一件坏事！)缺点是需要保持系统管理的开销，并且需要与 Kubernetes 基础设施和操作协调更新。

## 特定于容器的操作系统

国家标准与技术研究所(NIST)有一个很好的总结，定义了特定于容器的操作系统，总结了一些优点:

“特定于容器的主机操作系统是一种极简的操作系统，明确设计为仅运行容器，禁用所有其他服务和功能，并采用只读文件系统和其他强化措施。当使用特定于容器的主机操作系统时，攻击面通常比通用主机操作系统小得多，因此攻击和损害特定于容器的主机操作系统的机会较少。因此，只要有可能，组织应该使用特定于容器的主机操作系统，“根据" [NIST 特别出版物 800-190 应用程序容器安全指南](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-190.pdf)”

简而言之，操作系统运行的软件和软件包越少，受到攻击的可能性就越小，存在的漏洞也就越少。这使得特定于容器的操作系统从一开始就更加安全，即使不需要频繁打补丁。

特定于容器的操作系统也可能采用其他安全方法，比如将根文件系统(或者理想情况下所有文件系统！)只读，减轻了任何漏洞可能造成的影响。

特定于容器的操作系统通常不运行(或支持)包管理器。这降低了程序包的安装或更新导致冲突从而停止节点或服务运行的可能性。没有 Chef 和 Puppet 之类的管理工具也减少了配置更改或不完整运行对系统运行稳定性产生负面影响的机会。相反，应用了所有更新和配置的完整操作系统映像安装在备用引导机制中，并在下次重新引导时引导到，回退到先前已知正常工作的映像。这意味着节点的配置在任何时候都是确切已知的，并且可以从正在使用的版本控制系统恢复到任何版本。

一些特定于容器的操作系统更接近于通用的 Linux 发行版—例如，与常规的 Linux 发行版相比，VMware 的 [PhotonOS](https://vmware.github.io/photon/) 安装了少量的软件包，但是仍然包括软件包管理器、SSH 访问，并且不以只读方式挂载文件系统。人们有时会感到困惑的一点是，通用 Linux 系统的“云优化”版本仍然是通用 Linux 系统。例如，Ubuntu 发布了“云图像”，这是“由 Ubuntu 工程定制的，可以在公共云上运行。”然而，这些仍然是 Linux 的完整发行版，安装了所有的包——只是增加了一个 cloud-init 包，因此它们可以更容易地配置为在没有人工干预的情况下启动。

CoreOS 是第一个被普遍采用的特定于容器的操作系统，它普及了在容器中运行所有进程以获得额外的安全性和隔离的思想。CoreOS 取消了包管理器，并使用重新引导到两个只读/usr 分区中的一个来确保更新是原子性的，并且可以回滚。然而，CoreOS 自被 RedHat 收购后就已停产。

当前特定于容器的操作系统都采取最小化的姿态(在操作系统中安装非常少的包)；被锁定(在某种程度上)；在容器中运行进程(为了更好的安全性、稳定性和服务隔离)，并提供原子更新(通过引导到一个可引导分区，并更新另一个分区)。这些例子有:

*   谷歌的“[容器优化操作系统](https://cloud.google.com/container-optimized-os)”，支持只读根文件系统，但允许 SSH，并且只能在 GCP 运行
*   [RancherOS](https://rancher.com/docs/os/v1.x/en/) ，运行 SSH，不使用只读文件系统来保护 root。
*   [K3os](https://github.com/rancher/k3os) ，也是由牧场主经营，但不经营全香草 K8s 分销。管理是通过 Kubectl 进行的，但是支持 SSH。
*   AWS [Bottlerocket](https://aws.amazon.com/bottlerocket/) 是另一个具有不可变根 fs 和 SSH 支持的操作系统，也就是说，至少在最初，专注于 AWS 工作负载。

一个例外是 Talos OS，它是最固执己见的特定于容器的操作系统。像其他的一样，Talos OS 是最小的，没有包管理器，只使用只读文件系统(除了/var 和/etc/kubernetes，以及一两个可写但短暂的特殊文件，如/etc/resolv.conf)，并通过升级控制器与 K8s 集成进行升级。

然而，Talos 操作系统比其他操作系统更进一步，通过移除所有 SSH 和控制台访问，并使所有操作系统访问和管理 API 驱动。在运行 Kubernetes 的节点上，您想做的所有事情都有 API 调用——显示所有容器、检查网络设置等——但是没有办法做您不应该在节点上做的事情，比如卸载文件系统。Talos 还选择完全重写 Linux Init 系统，只做一件事——启动 Kubernetes。

不能管理任何用户定义的服务(它们都应该通过 Kubernetes 来管理。)这进一步提高了安全性(没有 ssh，没有控制台)，减少了维护(没有用户，没有修补)，并减少了任何 CVE 的影响(因为文件系统是不可变的和短暂的。)您可能不同意放弃 SSH 访问、限制 SRE 的行为、强制节点完全不可变是可取的——但这也是不久前反对不可变容器的论点，所以值得一看。拥有 API 管理的操作系统也非常适合大规模的操作和管理——如果您需要检查一个节点、一类节点或所有节点上的特定容器的日志，这是具有不同参数的相同 API 调用。

## 摘要

如果您已经接受了容器管理的牛而不是宠物的观点——销毁一个容器，并在要部署更新或修复时启动一个新版本——那么确保支持容器的基础设施采用相同的方法是有意义的。接受这种范式可能需要一点教育，即您的节点应该像容器一样进行管理，被销毁并重新配置以进行更新，而不是打补丁，但采用特定于容器的操作系统有助于推动这种采用，减少管理开销，并提高安全性。特定于容器的操作系统也有助于操作稳定性——如果系统管理员或开发人员不能将配置更改为“让它正常工作”,那么就消除了人为错误或错误配置导致下一次升级失败的可能性。

鉴于许多企业仍处于 Kubernetes 采用生命周期的早期，现在是熟悉这个下一代操作系统的好时机。通过将操作系统与 Kubernetes 紧密结合，可以将整个 Kubernetes 集群视为一台计算机，减少开销，并增强安全性。这让我们可以将重点放在计算基础架构提供的工作负载和价值上，这是向 API 驱动的数据中心迈出的又一步。

<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 68 31" version="1.1"><title>Group</title> <desc>Created with Sketch.</desc></svg>