<html>
<head>
<title>How to Connect Build Engineering and DevOps for Better Outcomes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何连接构建工程和开发运维以获得更好的结果</h1>
<blockquote>原文：<a href="https://thenewstack.io/how-to-connect-build-engineering-and-devops-for-better-outcomes/#0001-01-01">https://thenewstack.io/how-to-connect-build-engineering-and-devops-for-better-outcomes/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">


<p class="translated"><a href="http://www.activestate.com" class="clearfix infoBlock " target="_blank"> <div class="infoBlockTextBlock"> <p class="infoBlockTitle"> Bart Copeland，ActiveState首席执行官兼总裁</p> <p class="infoBlockText"> Bart Copeland是ActiveState的首席执行官兼总裁，active state正在用一个企业平台重塑构建工程，让开发人员可以为任何平台和任何环境构建、认证和解析任何开源语言。ActiveState帮助企业使用开源语言安全地扩展，并为开发人员提供他们喜欢使用的工具。Copeland拥有凤凰城大学的技术管理工商管理硕士学位和不列颠哥伦比亚大学的机械工程学位。</p> </div> </a></p><p class="translated">今天发布软件通常是一件快速而激烈的事情。DevOps工程师正在设计应用程序构建，改进软件交付流程等等。同时，构建工程师正在创建和维护构建系统，使用各种工具和框架来简化软件构建和部署。当今开发环境中的一个重大挑战是弄清楚如何连接这两个功能。</p>
<p class="translated">在DevOps趋势形成之前，由开发人员和工程师完成的编码和由运营人员完成的部署之间有一个离散的划分。然而，很明显，对于公司来说，优化包括生产力、开发和运营在内的利益不应该如此不同。DevOps就是结果。</p>
<p class="translated">由于采用了DevOps，发生了一些变化。组织用安全性换取速度，用确定性换取灵活性，用专有代码换取开源:</p>
<ul>
<li class="translated">上市时间已经成为竞争的必然。速度现在比修复漏洞更重要，这在下一个版本中总是可以解决的(希望如此)。事后对安全和漏洞的改造成为开发和工程团队的一大障碍。最终，利润损失的风险大于潜在未知威胁的风险。</li>
<li class="translated">为了更快地进入市场，敏捷性比确定性更重要。例如，产品的迭代推进摒弃了固定的、已知的路线图，支持实施本周最重要的特性/功能。不变性的趋势在这里也很重要；扔掉坏掉或过时的东西通常比试图修复或更新它更简单快捷。</li>
<li class="translated"><strong>开源</strong>击败了专有代码，因为它提供了更大的创新、更低的成本和透明度。开发人员不必专注于创建专有代码，而是可以通过汇编开源代码来快速迭代解决方案，从而加快上市时间。此外，从已经创造的东西中获取的能力可以解放您的开发团队，让他们为您的企业工作进行创新和构建IP。</li>
</ul>
<p class="translated">并不是所有的组织在同意这种折衷后都会得到同样的结果。赢家通常是拥有成熟开发运维流程的组织。对大多数人来说，修复某个东西和知道它是否会破坏上游的某个东西之间的矛盾还没有消除。您可能能够快速更新和修补单个解决方案，但是一旦您将其推向CI流，这会对您产生什么影响呢？即使对于成熟的DevOps组织，也存在与两个被忽略的因素相关联的隐藏机会成本:开源编程语言和构建工程。</p>
<p class="translated">当您用新版本、依赖项、安全补丁等改进您选择的开源语言时，更多的工作被堆积到您的DevOps团队上。团队应该关注重要的事情:创建和交付最新版本。</p>
<p class="translated">每次您必须改进底层开源语言时，您的构建工程都会受到影响。您需要重建所有的开发人员环境、CI/CD系统和生产环境。所有这些构建工程工作都是手动的，减缓了上市时间，并消耗了宝贵的工程资源。此外，您不确定您的重建和更新是否会提供保证更新的性能改进。</p>
<p class="translated">DevOps工程师习惯于创建自动化开发实践，那么为什么不自动化改造和构建您的开源语言，并无缝连接到DevOps周期的其余部分呢？您可以确保构建的可再现性、依赖性管理以及对公司安全性和许可标准的遵从。例如:</p>
<ul>
<li class="translated"><em>打包</em>:如果每个连续的构建可以用多种方式打包——任何操作系统的任何形式——考虑一下您的工作流程的变化。</li>
<li class="translated"><em>构建验证</em>:想象一下，能够根据冒烟测试审查每个连续的构建，包括符合您的安全性和许可标准，这样您就知道它是否准备好部署了？</li>
<li class="translated">连续构建:如果每次发现新版本的库或漏洞补丁时，都会启动新的构建，并在完成时通知您，那么您就可以保持连续部署。</li>
<li class="translated"><em>系统更新</em>:想象一下，使用一个命令就可以用最新版本更新开发、测试甚至生产环境中所有受影响的系统。</li>
<li class="translated"><em>构建影响</em>:考虑能够理解通过采用最新的构建可以获得的性能改进(如果有的话)的好处。</li>
</ul>
<p class="translated">随着最新的软件版本被匆忙推向市场，DevOps团队经常发现自己在堵塞自己无意中造成的漏洞。自动化是克服这些挑战的强大盟友。自动化开源语言的构建管道使得确保构建的可重复性和依赖性管理成为可能。它还提供了符合企业安全和许可标准的业务优势。通过这种方式，DevOps和Build Engineering结合在一起，将两个功能领域的真正承诺变为现实。</p>
<p class="attribution translated">通过Pixabay的特征图像。</p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
<title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>
</div>
</div>    
</body>
</html>