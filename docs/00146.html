<html>
<head>
<title>So, You Want to Go Cloud-Native? First, Ask Why</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">那么，您想成为云原生用户吗？首先，问为什么</h1>
<blockquote>原文：<a href="https://thenewstack.io/want-go-cloud-native-first-ask/#0001-01-01">https://thenewstack.io/want-go-cloud-native-first-ask/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">


<p class="translated"><a href="http://www.redpoint.com/" class="clearfix infoBlock " target="_blank"><div class="infoBlockTextBlock"><p class="infoBlockTitle">Lenny Pruss</p><p class="infoBlockText">Lenny Pruss是Redpoint Ventures的负责人，他主要从事云基础设施、开发工具和安全方面的投资。他在Memory Leak上写了关于开发人员业务的文章。</p> </div> </a></p><p class="translated">在过去的几年里,“原生云”一词已经成为设计和构建应用程序以及支持它们的基础设施的人们的共同意识。</p>
<p class="translated">本质上，云原生指的是为云量身定制的软件架构范式。它要求应用程序1)使用容器作为打包和部署的原子单元，2)自治，即集中编排和动态调度，3)面向微服务，即构建为松散耦合的模块化服务，每个服务运行一个独立的进程，通常通过API通过HTTP相互通信。</p>
<p class="translated">剖析这些特征进一步表明，现代应用程序需要独立于平台(例如，与物理和/或虚拟资源分离，以便在云和计算环境中同样工作良好)、高度灵活、高度可用且易于维护。</p>
<p class="translated">听起来，构建云原生应用对每个组织来说都是显而易见的，无论他们是否考虑编写业务关键型软件。然而，在实践中，云原生化(很像采用DevOps)需要实施一系列新技术和实践，这些技术和实践有意义地转移与编写、部署和管理软件相关的开销成本。因此，在考虑进行云原生之前，必须从技术和组织两方面了解这种架构转型的动机。</p>
<p class="translated">一个很好的起点是Google，它是这种高度分布式自主计算范例的典型代表。谷歌已经在集装箱化基础设施上运行了近十年，并通过一个名为Borg的专有系统管理资源分配、调度、协调和部署。</p>
<p class="translated">“博格提供了三个主要好处，”2015年谷歌的一篇研究论文<a href="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/43438.pdf" class="ext-link" rel="external "> <em>解释说，谷歌的大规模集群管理有博格</em> </a>。这种方法“隐藏了资源管理和故障处理的细节，因此用户可以专注于应用程序开发。”Borg-ian方法还“以非常高的可靠性和可用性运行，并支持做同样事情的应用程序，让我们能够在数万台机器上有效地运行工作负载。”</p>
<p class="translated">因此，谷歌进行云原生的理由是实现1)敏捷性，如开发人员生产力和自助服务所定义的，2)容错和3)水平可扩展性。虽然几乎没有任何组织需要像谷歌这样大规模地运营，但世界上的每家公司都会问自己“我如何走得更快”和“我如何将风险降至最低？”</p>
<p class="translated">然而，当云原生成为目的而不是手段时，问题就出现了。虽然容器、自动调度和面向微服务的设计都是可以提高运营敏捷性并降低与运输软件相关的风险的工具，但它们远不是灵丹妙药，并且涉及到将有意义的成本从开发转移到生产。马丁·福勒和其他人将这种现象称为“<a href="http://martinfowler.com/bliki/MicroservicePremium.html" class="ext-link" rel="external ">微服务溢价</a>”</p>
<p class="translated">“[云原生]方法完全是为了处理复杂的系统，但为了做到这一点，该方法引入了自己的一系列复杂性。福勒写道:“当你[采用云原生架构]时，你必须致力于自动化部署、监控、处理故障、最终一致性以及分布式系统引入的其他[复杂性]。”</p>
<p class="translated"><img decoding="async" loading="lazy" class="aligncenter wp-image-1024754" src="../Images/b47c835fe22da5b83cd421cea8041466.png" alt="Complexity_Chart" data-id="1024754" data-original-src="https://thenewstack.io/wp-content/uploads/2016/02/Complexity_Chart.png"/></p>
<p class="translated">流行的谬论是将使用Docker作为包格式与从一开始就将应用程序构建为复杂的分布式系统的需求混为一谈。</p>
<p class="translated">第一条经验法则是“如果没有坏，就不要修复它”，所以如果你的团队在高水平上运行，发布按计划进行，并且你的应用具有弹性并可伸缩以满足用户的需求，就没有必要增加复杂性。持续高水平的开发人员生产力、连续部署和容错系统可以而且经常在不与docker文件交互的情况下实现(尽管它可以从根本上简化开发工作流)。事实上，高性能软件组织中许多最优雅的交付管道都是基于AMI并由Slackbots部署的！</p>
<p class="translated">然而，随着您的工程组织膨胀到100多个开发人员，云原生化——包括建立整个分布式运行时——很可能开始变得有意义。请记住，所有这些决策都是权衡，复杂性只是被转移了，而不是减少了。</p>
<p class="attribution translated">Docker是新堆栈的赞助商。</p>
<p class="attribution translated">由<a href="http://www.laughandpee.com/" class="ext-link" rel="external ">瑞安·麦奎尔</a>通过<a href="http://www.gratisography.com/" class="ext-link" rel="external ">地形图</a>拍摄的特写图像。</p>
<p> </p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
<title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>

</div>
</div>    
</body>
</html>