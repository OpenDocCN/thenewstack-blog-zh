<html>
<head>
<title>How Service Mesh Transforms Cloud Native App Development </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">服务网格如何转变云原生应用开发</h1>
<blockquote>原文：<a href="https://thenewstack.io/how-service-mesh-transforms-cloud-native-app-development/#0001-01-01">https://thenewstack.io/how-service-mesh-transforms-cloud-native-app-development/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">


<p class="translated"><a href="https://azure.microsoft.com/en-us/?v=17.14" class="clearfix infoBlock " target="_blank"> <div class="infoBlockTextBlock"> <p class="infoBlockTitle"> Brendan Burns，微软</p> <p class="infoBlockText">杰出工程师Brendan Burns是Kubernetes的联合创始人，现在是微软的杰出工程师，领导Azure容器服务(AKS)、Azure容器实例、Azure云外壳和Azure资源管理器的开发工作。他和家人住在华盛顿州西雅图。</p> </div> </a></p><p class="translated">Kubernetes具有变革性的原因有很多，但最重要的原因之一是它的API是为开发人员设计的。在Kubernetes中，您可以创建部署和服务，而不是机器、磁盘和网络等基础设施对象。您仍在使用计算、网络和存储，但您创建的资源与应用程序开发保持一致。</p>
<p class="translated">然而，在Kubernetes的容器或pod中运行流程并不是全部。一个应用不仅仅是它的运行代码，它还被它的网络通信所定义。这些消息和特征，如拓扑、路由、度量和访问控制，定义了分布式系统及其容器映像。</p>
<p class="translated">因此，很明显，定义应用通信的面向应用的API是云原生开发人员体验的关键部分，这些API通常被称为服务网格API。服务网格API使应用程序开发人员能够使用开发人员友好的声明性资源来表达他们的分布式应用程序的连接性。如何实现这种应用程序连接的具体细节留给特定的网格实现，如Consul、Linkerd、Istio或Envoy。</p>
<blockquote><p class="translated">一个应用不仅仅是它的运行代码，它还被它的网络通信所定义。这些消息和特征，如拓扑、路由、度量和访问控制，定义了分布式系统及其容器映像。</p></blockquote>
<p class="translated">服务网格用户和服务网格实现之间的解耦是Kubernetes关键设计原则的一个例子。即模块化可组合性和使用声明性API的基础设施的去耦分层。这个设计原则导致Kubernetes由许多通用的可插拔API组成。这方面的例子包括允许Kubernetes跨Azure、AWS、Google等平台工作的云提供商绑定；以及CNI(容器网络接口)、CSI(容器存储接口)和CRI(容器运行时接口)，它们一般定义了容器如何与计算、网络和存储进行交互。</p>
<p class="translated"><a href="https://smi-spec.io/" target="_blank" rel="noopener noreferrer external " class="ext-link">服务网格接口</a> (SMI)为服务网格概念提供了相同的通用API。SMI是一个通用接口，它以一种实现中立的方式呈现核心服务网格概念。它捕捉了服务网格中的核心思想，但提供了任何特定服务网格实现之上的抽象，如Istio、Linkerd或Consul。</p>
<p class="translated">将API规范从实现中分离出来已经在整个Kubernetes生态系统中创造了价值，同样的价值也可以在服务网格技术中实现。通用API使人们能够构建可移植的应用程序，这些应用程序可以轻松地从本地迁移到基于云的集群，或者在各种公共云之间迁移。此外，标准化我们对通用接口的讨论使全球社区能够讨论，更重要的是，教授相同的概念和资源集，而不管它们是如何实现的。公共接口意味着开发人员可以构建有用的工具，供整个生态系统使用。</p>
<p class="translated">也许最重要的是，一个通用的API将证明像服务网格这样的新技术是可行的。当API和实现紧密绑定在一起时，采用一个新的API(或一组API)是一个令人担忧的选择。如果一段时间后，实现变得不合适，那么改变实现需要大手术和重新学习概念和工具，因为API和实现是紧密结合在一起的。一个通用的API改变了这个等式，因为用户从API的实现中抽象出来，实现可以交换，几乎没有变化。这意味着采用网格的成功并不局限于任何特定实现的成功，这反过来意味着采用像服务网格这样的新技术风险更小。</p>
<p class="translated">服务网格接口被设计成易于理解和实现的简单API，因此它仅由四个概念定义:</p>
<ul>
<li class="translated">路由定义了通过HTTP或TCP进出应用程序的路径</li>
<li class="translated">TrafficTarget描述了应用程序是否可以在一组特定的路由上调用(或接收调用)。</li>
</ul>
<p class="translated"><img decoding="async" loading="lazy" class="aligncenter size-full wp-image-8659987" src="../Images/f28d35a439214479436d19bb7e663c21.png" alt="" data-id="8659987" data-original-src="https://cdn.thenewstack.io/media/2019/09/15038476-image1-17.png"/></p>
<ul>
<li class="translated">TrafficSplit描述了如何在两个(或多个)Kubernetes服务之间进行流量分割，以便进行实验。</li>
</ul>
<p class="translated"><img decoding="async" loading="lazy" class="aligncenter size-full wp-image-8659989" src="../Images/7e0a607670a35d8d0bcdfeee9608aea0.png" alt="" data-id="8659989" data-original-src="https://cdn.thenewstack.io/media/2019/09/6ec6b769-image2-19.png"/></p>
<ul>
<li class="translated">TrafficMetrics描述了用于获取应用流量统计信息的通用指标端点。</li>
</ul>
<p class="translated"><img decoding="async" loading="lazy" class="aligncenter size-full wp-image-8659991" src="../Images/d31cce2376df22df64575dd3d612cff6.png" alt="" data-id="8659991" data-original-src="https://cdn.thenewstack.io/media/2019/09/44e3d364-image3-21.png"/></p>
<p class="translated">有了这个API，可以用面向开发人员的方式定义应用程序的核心面向应用程序的结构。</p>
<p class="translated">当然，这种接口的主要问题是它是“最小公分母”,因此对任何人都没有用。这一直是接口API的一个问题。解决这个问题的方法是包含特定于供应商的注释，以及规范随时间的演进。我们在这一演变中的灵感来自OpenGL，尽管通用API和特定图形卡功能之间存在类似的紧张关系，但它仍然取得了成功。在SMI中，特定于API供应商的注释将一直存在，并且不可移植。然而，随着时间的推移，最受欢迎的特定于供应商的特性将被包含并添加到规范中。通过这种方式，演进希望确保大多数用户能够通过SMI API成功地管理他们的服务网格。</p>
<p class="translated">Kubernetes标志着向面向应用和开发者的云API转变的开始。SMI是这条路上重要的下一步。</p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
<title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>
</div>
</div>    
</body>
</html>