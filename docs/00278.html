<html>
<head>
<title>The Four Critical Practices of Effective Software Development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有效软件开发的四个关键实践</h1>
<blockquote>原文：<a href="https://thenewstack.io/software-development-effective-development-practices/#0001-01-01">https://thenewstack.io/software-development-effective-development-practices/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">

<div class="editors-note"><p>
“</p><a href="http://www.thenewstack.io/tag/It's-All-About-Software-Development">It’s All About Software Development</a><p class="translated">”是一系列探索为什么组织应该关心有效软件开发的优化的帖子。有效的软件开发是什么样的？没有魔法，组织如何从他们(大部分)非常低效的软件开发转移到有效的软件开发？请继续阅读…</p></div>

<p class="translated"><a href="http://www.emisonian.com/" class="clearfix infoBlock " target="_blank"> <div class="infoBlockTextBlock"> <p class="infoBlockTitle">乔·艾米森</p> <p class="infoBlockText">乔·艾米森是美国领先的商业房地产信息提供商Xceligent的首席信息官。Joe是一位连续的技术企业家，最近一次是在2008年创立BuildFax，并为许多其他公司的云发布和迁移提供咨询。Joe毕业于威廉姆斯学院，获得英语和数学学位，并拥有耶鲁法学院的法律学位。在推特上找乔:@JoeEmison。</p> </div> </a></p><p class="translated">这是有效软件开发系列文章的第四篇。本系列<a href="https://thenewstack.io/modern-effective-software-development-15/" class="local-link">已经讨论了</a>是什么使得现代软件开发比传统软件开发更有效:频繁的发布和永远恒定的速度。然后继续解释<a href="https://thenewstack.io/software-development-starts-product/" class="local-link">一个组织应该如何运行</a>它的产品和技术团队，以便交付给开发团队的构建工作量足够小并且足够迭代，以便这些频繁的发布可以实际完成。</p>
<p class="translated">但是，即使您的组织正在正确地进行产品方面的工作，缩小功能范围，并针对用户和主题专家迭代设计以进行验证，如果您没有遵循有效的软件开发生命周期实践，您将无法执行现代软件开发。</p>
<blockquote><p class="translated">“写代码的时候，就像下一个必须和你一起工作的程序员拿着枪指着你的头一样。”—程序员格言</p></blockquote>
<p class="translated">在有效的现代软件开发中，开发团队有一个已知的最小回归速度。这意味着开发团队可以足够频繁地开发出新的特性、错误修复和其他需要在代码中实现的东西，这样就有可能一直发布软件，并且这些版本在每个版本中都有有意义的变化。这意味着出现的错误——回归——的数量必须最小。否则，团队将花费所有的时间来修复bug。</p>
<p class="translated">下面，我描述了软件开发团队必须实践的四个关键过程，如果他们能够以这种方式执行的话。</p>
<h2 class="translated">小故事</h2>
<p class="translated">这是第一步:小故事尺寸。开发人员以票证的形式获得他们的工作，现在通常称为“故事”,因为每个都应该写成一个“用户故事”,这样开发人员就可以理解为什么要完成这项工作，并对用户产生共鸣和理解。</p>
<p class="translated">小故事之所以伟大，有几个原因。首先，如果故事要求不超过一天半的工作，那么如果开发人员对工作的时间估计错误了25 %,这仍然是少于一天的额外工作。这意味着很容易每周了解一个项目是否按计划进行。如果故事估计需要几个星期，那么直到截止日期过后才知道你已经落后是非常困难的。</p>
<p class="translated">第二，大故事往往不是很明确。如果给一个开发人员一个她认为需要两周完成的故事，她几乎肯定需要比已经写给她的更多的信息。相反，如果两周的工作被分解成十个不同的故事，那么每个故事可能都有足够严格的定义，这样她就不必四处寻找写故事的人来理解她编写代码所需的额外细节。</p>
<h2 class="translated">特征分支</h2>
<p class="translated">第二个重要的实践是对需要完成的每一项工作进行分支。对于开发团队来说，处理集中存储在某个地方的同一份代码仍然是很常见的。这是一种可怕的做法，因为开发人员会引入错误。</p>
<p class="translated">如果您是一名开发人员，正在开发另一名开发人员正在破坏的同一份代码，您的工作将会被中断，并且由于其他开发人员造成的错误，您估计的一天半可能会变成三天或四天。</p>
<p class="translated">此外，如果您正在代码中创建回归，您应该在将更多的新代码与普通代码合并之前识别并修复这些回归。否则，无论是谁发现了您所创建的问题，现在都不得不去追踪您(如果每个人都在编辑相同的代码副本，这通常是很困难的)，或者不得不自己去诊断问题，从而导致更多的延迟。</p>
<h2 class="translated">自动化测试</h2>
<p class="translated">第三个关键实践是自动化测试。当你是一名开发人员，并且你在你的分支中工作，你需要一个简单的方法来知道你是否因为添加新代码而破坏了一些东西。这意味着有人需要编写一堆自动化测试来验证人们没有破坏东西。</p>
<p class="translated">我发现大多数有效的开发组织都让开发人员编写他们自己的测试来保护他们添加的功能，但这里的关键是让他们交付自动化测试，而不是耗时数天的手动质量保证(QA)过程。此外，手动QA在这样一个环境中几乎不起作用，在这个环境中，你对正在完成的每一个单独的工作都有一个分支。对于人工QA来说，要测试的东西太多了，在财务上没有意义。所以手工QA只能在单个分支合并后运行，这意味着每个bug都需要“找到破坏它的人”的过程，与自动化测试相比，这是一个不必要的缓慢而痛苦的过程。</p>
<p class="translated">对于自动化测试非常困难或不切实际的应用程序的某些部分，手动QA仍然是必要的。但是，如果您对每个发布都有大量的手工QA工作要做，那么每周进行多次发布基本上是不可能的。</p>
<p class="translated">许多人认为在现有的项目中不可能进行自动化测试，因为在现有的项目中没有测试覆盖或者机制来编写或者运行测试。对于你们所有人，请继续关注下一篇文章，在那里我将讨论如何在现有的应用程序中采用这些实践，而不必在几周或几个月内停止特性开发的所有前进进程。</p>
<h2 class="translated">代码审查</h2>
<p class="translated">第四个关键实践是代码审查。有一句传统的程序员格言是这样说的:“编写代码时，就像下一个必须与你的代码打交道的程序员拿着枪指着你的头一样。”代码评审就像让下一个程序员看你的代码，并在你将你的代码与大众融合之前给你意见。</p>
<p class="translated">代码审查做了许多伟大的事情。这意味着在代码与现有的代码库合并之前，有几组眼睛在盯着它。真正有效的团队通常有相当严格的风格指南，因此通常只有一种正确的方法来编写特定的代码部分。此外，大多数优秀的团队都让每个开发人员审查代码，而不仅仅是一两个高级开发人员。这使得对代码库的交叉理解变得非常好，使得每个人在未来继续使用这个代码库变得更加容易，并且交付必要的速度和频繁的发布。</p>
<p class="translated">虽然有效的团队经常遵循其他伟大的过程，但是以上四个要素对于有效的现代软件开发是至关重要的。如果你缺少以上四个中的任何一个，你将无法在一个可扩展的团队中交付一个恒定的速度和最小的回归。</p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
<title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>

</div>
</div>    
</body>
</html>