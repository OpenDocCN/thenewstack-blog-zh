# IBM OpenStack 工程师呼吁为 Jenkins 增加 Zuul 以支持超大规模项目

> 原文：<https://thenewstack.io/ibm-openstack-engineer-urges-cncf-consider-augmenting-jenkins-zuul/>

当您管理一个超大规模的项目，该项目有几十个国家的成千上万的贡献者，并且有许多活跃的、独立开发的组件，您如何期望可靠地完成将项目的发展作为单个流来管理的壮举？当然，你可能会问自己，除了 OpenStack 本身，有多少现实世界的项目符合这种描述？然而，你可能还记得不太久以前，Kubernetes 被描述为超大规模架构的产品。或许今天早上的超大规模上涨注定会成为今晚的主流商品。

在云原生计算基金会(Cloud Native Computing Foundation)周三上午的定期技术监督委员会会议上，IBM 的云架构师(2015 年 9 月之前在 HPE 工作)和 OpenStack 的贡献者 Clint Byrum 应邀介绍了他的案例，说明 CNCF 如何使用自动*看门人*系统来改善其持续集成流程。

这样的系统将阻止 CI 管道被打开，以及合并过程的发生，直到特定的条件被满足。但是，当闸门关闭时，它实际上可以使一些测试操作提前进行，同时在闸门打开之前阻止这些测试产生的任何合并。

## 我们在市区是怎么做事的

Byrum 声称这个系统改善了 OpenStack 提交对其许多上游组件的更改的方式，并且自 2012 年以来一直在悄悄地这样做(鉴于其名称，这是一个惊喜)。它被称为 [Zuul](https://github.com/Netflix/zuul) ，一个以“看门人”食尸鬼命名的项目，该食尸鬼占用了原版《捉鬼敢死队》中西格妮·韦弗的身体(在这一行，乐趣就是你创造它的地方。)

“我们希望测试集成在一起的组件，”Byrum 告诉与会者。“因此，如果它本身不是一个完全的孤岛——大多数东西都不是，我们希望确保它们实际上能够协同工作，而不仅仅是它们的 API 按照它们预期的方式工作——我们会在 OpenStack 的每个主要项目的每个提交中进行全面的集成测试，在那里它们被集成在一起*预合并*。除非代码通过这些测试，否则我们不会让代码落地。”

Zuul 在 OpenStack 中的作用是提供一个名为*trunk gate*的服务(不要和 tailing 混淆)。该系统每次都让新代码提交通过相同的步骤，首先在虚拟环境中进行本地测试，然后提交给 OpenStack 的 Gerrit 库进行审查，并通过一系列自动化补丁进行更新。一旦代码到达验收阶段，它就要接受另一组预合并检查。并且一旦合并，它仍然服从合并后的分析。

这是一种由詹金斯管道组成的上层建筑。正如 Byrum 向 CNCF 承认的那样，这不是一件容易的事。

## 超大规模对冲

“詹金斯建筑有一个致命的缺陷，那就是我们想要大门。但是为了进入 Jenkins，除了提交大量的合并提交或 [monorepo](https://medium.com/@bebraw/the-case-for-monorepos-907c1361708a#.rir3h6xvz) 之外，它没有任何优化的方法，”Byrum 说，他指的是在单个存储库中容纳多个版本的相关代码组件的替代方法。他指出，他的团队确实研究了这种替代方案，但最终拒绝承担它的负担。

他认为，维护独立的存储库使他的团队更容易设计主干门控系统。在他们的特殊情况下，他们创造了一个独特的确定系统，使科幻小说显得过时:*投机未来合并测试*。

Byrum 将 Zuul 测试引擎背后的算法的创建归功于 OpenStack 核心贡献者 James E. Blair，反过来，Blair 在 2013 年将 Zuul 测试引擎的灵感归功于 CPU 使用的推测性多线程技术。这个概念大约在 1998 年取得了成果，被发明出来作为处理器加速并行处理的一种手段，特别是在多个线程共享相同数据的情况下。

这是字面上的跳跃前进的原则。当一个内核有机会时，它会执行一个线程尾部的指令。对于 Blair 引用的版本，如果那些推测性指令打算对主存储器进行改变，那么该存储器的内容首先被镜像到高速缓存中，所以推测性改变可以在那里进行。如果线程过早地结束执行(如果推测是错误的)，则高速缓存内容被擦除，并且先前的线程状态被恢复。这导致了几个周期的损失，但是累积起来，总损失应该小于 CPU 在试图以完美的顺序执行每个线程时遇到的瓶颈。

Blair 借用了这个想法，作为一种允许 Gerrit 为每个组件触发合并测试的方式，甚至在我们知道它实际上是必要的时候，在管道中的点之前。在持续集成中，必须按顺序测试多个组件，这些测试的层次结构是由这些组件之间的依赖关系决定的。通过所有测试的组件可以与生产流合并。

但是当一个预期变更的测试失败时，Zuul 的调度器通过从测试序列中移除该变更来做出响应——同时保持该变更在合并队列中的位置。它不会改变队列；它仅仅依靠看门人来确保未测试的变更不会被合并。随后，依赖于失败变更的序列中较早的测试被重新启动。

自始至终，看门人维护一个内部指针，称为最近的非故障项目*(NNFI)。这成为测试序列的焦点。但它也为投机结果创造了一个起点，正如 Byrum 所描述的那样——这是 Zuul 向前跳跃并为新的拉动请求制定预期着陆订单的一种方式。*

“本质上，[*Zuul*所做的是查看它被告知的所有事件，包括[*拉取请求*的批准，它说，‘我将建立一个未来，让它们按照这个顺序*着陆。如果它们没有相互依赖，如果它们不在同一个回购协议中，并且相互堆叠，那么它会确保它们可以合并在一起，并建立一个大而长的变更 1 管道，然后变更 1 + 2，然后变更 1 + 2 + 3，以此类推。然后，它使用弹性云并行测试每个组合。"*

他告诉 CNCF，结果是，对于大量同时聚合的拉请求——比如说 25 个——Zuul 为合并顺序创造了一个窄至 1 的可能性窗口。使用 NNFI，Zuul 可以重新组织这个序列，并在序列中的任何合并提交导致问题时执行*门重置*。

Byrum 说:“在最好的情况下，不管你备份和批准了多少工作，你只需要一个测试窗口。“在最坏的情况下，您可以让所有的补丁都知道它们都失败了，但是您没有得到坏代码。”

## 没有丹娜

这些年来，OpenStack 有几个优点，其中一个不是它发展的稳定和不懈的步伐。Byrum 承认，其他开源社区项目已经试验了 Zuul 的 2.x 版本，效果不佳。本着同样谦逊的精神，他承认，Zuul 到当前版本的发展已经偏离了它的主要路线，以满足 OpenStack 的特定和排他性需求——因此暴露了该平台的一些实现细节，也许是不必要的。

但他告诉《CNCF 》,对 Zuul 的“长期、大规模的重构”已经进行了多年，他希望最迟在 6 月份推出 Zuul 的 3.x 版本。这个新版本将包括一个更不可知论的定义语言，他建议 CNCF 推迟采用 Zuul，直到基于该语言的 API 的可靠性得到保证。

然而，与此同时，他建议对网守试用感兴趣的开发人员试用 bonny ci T1，他称之为“Zuul-as-a-Service”作为一个基于云的环境，BonnyCI 可能还没有为 CNCF 托管的项目的规模做好准备——例如，他说，它在自己的云之外的依赖可能仅限于 GitHub。然而，可以想象，它可以证明守门和投机的未来原则在起作用。

Zuul 的可移植性的话题谈到了一个更广泛的问题，即算法是否可以在宏观上加速自动化，就像它们在微观上加速代码执行一样。我们可以把使用寄存器、提取、预取和缓存的基于云的软件开发过程想象成我们在一个巨大的 CPU 中生活和工作吗？文化方面似乎令人生畏，但富有成效的回报前景是不可否认的。(在那里，你认为我会用另一个《捉鬼敢死队》的参考来结束这篇文章，就像关于穿越溪流或其他东西的警告。)

云计算原生计算基金会是新堆栈的赞助商。

牛津大学马格达林学院外[守门人石像鬼的标题图片](https://commons.wikimedia.org/wiki/File:Gargoyle_11.JPG)，由 Chris Creagh 创作，经知识共享许可。

<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 68 31" version="1.1"><title>Group</title> <desc>Created with Sketch.</desc></svg>