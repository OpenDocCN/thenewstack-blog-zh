# Dialpad 如何将其 Python AI 开发从 Pip 转移到诗歌

> 原文：<https://thenewstack.io/how-dialpad-migrated-its-ai-development-from-pip-to-poetry/>

[](https://twitter.com/thekevj)

 [凯文·詹姆斯

凯文·詹姆斯是 Dialpad 人工智能工程团队的助理工程师兼技术主管。当找不到令人兴奋的新方法来使用 kubernetes 解决他的团队的问题时，他喜欢在厨房、鸡尾酒柜台或仪器上进行实验。](https://twitter.com/thekevj) [](https://twitter.com/thekevj)

那确实是一个黑暗和暴风雨的日子，幸运的是，我们无畏的英雄偶然发现了 pip 变更日志中的一个条目:

**维护人员正准备发布 pip 20.3，默认情况下会启用新的解析器。**

困惑和好奇击中了他们的心！他们问自己:*这个新的解析器是什么？这会影响我们吗？我怎样才能学到更多？我没关烤箱吗？*对于 Dialpad 的人工智能团队来说，Python 及其使用是我们大部分[开发工作的核心](https://thenewstack.io/category/development/):在错误的时间做错误的改变可能会带来灾难。

在搜寻了描述新行为的晦涩难懂的大部头和几乎难以辨认的潦草字迹后，答案很清楚:新的解析器有一个与我们的工作流不兼容的清单。它会阻止我们部署新的机器学习模型，会导致我们的 CI/CD 平台消耗数小时的学分，试图徒劳地调和宇宙中不兼容的事实，甚至会阻止我们建立自己的开发环境。

需要做点什么。一些勇敢的人需要发现一种新的方式，一种用于 Dialpad 的 Python 包管理的新风格，这可以将他们带入一个更光明的未来——一些人认为包管理的未来是 [诗歌](https://python-poetry.org/) 。

这是他们的故事。

## 我们为什么以及如何选择诗歌？

 [Vasundhara Gautam

Vasundhara Gautam 是 Dialpad 的一名语音识别工程师，他最近离开了公司，开始在萨尔州大学攻读计算机科学博士学位，在那里，xe 将继续满足 xyr 对代码、语言和构建公平的语音识别系统的热情。在 xyr 空闲时间，xe 喜欢唱歌，弹钢琴和去观鸟。](https://twitter.com/VasundharaNLP) 

像许多人一样，用更多的诗歌填充 Dialpad 的旅程始于 RFC(征求意见)。Dialpad 的人工智能团队使用 RFC——最初以 [命名，即封装互联网](https://en.wikipedia.org/wiki/Request_for_Comments) 规范的文档——来讨论工具、工作流程和我们自己内部流程的变更建议。任何感兴趣的工程师都会对这些 RFC 进行讨论，直到所有问题都解决了，并且我们就最佳的前进方式达成了共识。

在这种情况下，RFC 包括几个主要主题:

**我们要解决的问题是什么？**我们当前的 pip 工作流程会导致哪些特殊问题，它们会对我们产生怎样的影响？在我们的案例中，变化是多方面的，但最显著的是:

*   新的解析器在安装时而不是开发时起作用(这意味着我们无法知道我们的依赖关系是否会冲突，直到我们已经提交了要构建的代码变更)，以及；
*   它不能重新计算以前的依赖关系(因此，在我们构建的后续步骤中，我们试图添加新包的任何地方——我们经常这样做，以将我们的 AI 模型作为黑盒包含在我们的平台代码之上——可能会发现不存在冲突的地方)

此外，虽然不太重要，但没有办法尽早脱离 pip 过程:如果发现冲突，我们将无法发现，直到 pip 用尽了所有可能的选择，下载了潜在依赖版本矩阵中所有可能兼容的选项。由于我们不希望将全年预算花在一周的额外计算时间和网络使用上，这对我们来说不是一个好的选择。

我们有什么选择？Python 打包权威维护了一个 [列表，该列表列出了这个空间中所有可用的工具](https://packaging.python.org/key_projects/) 。最重要的是，他们甚至有一套更精简的建议实践[](https://packaging.python.org/guides/tool-recommendations/)可以采用。不幸的是，这些建议的范围往往很窄或很具体，而且大多是由构建新工具的人更新的——最自然的是将他们自己的新工具列为建议。我们希望确定什么最适合我们的特定用例，并采用一种匹配我们的工具，而不是将我们自己与一种新采用的工具相匹配。因此，我们从所有可能的工具的列表开始，在互联网上搜索相关的博客文章或黑客新闻文章，并最终将我们的列表缩减到目前看来最值得注意和最相关的选择:pip(针对我们的问题有几个变通办法)、Pipenv、pip-tools、buildout、flit 和 poem。

每一种都有其优点和缺点，处理 Python 包开发生命周期的不同子集，并且能够以某种方式解决我们面临的问题。对于他们中的每一个，我们调查了其他人是如何使用他们的，他们的开发周期是什么样的，以及他们想要解决的总体目标是什么。

这些选项如何适应我们的工作流程？在[人工智能](https://thenewstack.io/category/machine-learning/) (AI)团队中，我们喜欢自动化工具:如果我们可以避免需要人类专注于一些重复的任务或担心一些可解决的问题，这在我们的书中是一大胜利。我们使用像 [翻新](https://www.whitesourcesoftware.com/free-developer-tools/renovate/) 这样的工具来确保我们不需要对我们的依赖关系进行微观管理更新， [预提交](https://pre-commit.com/) 来运行不断增长的 linters，以及 [CircleCI](https://circleci.com/?utm_content=inline-mention) 来自动运行那些 linters，测试，以及与我们代码的持续交付相关的一切；我们构建应用程序和库(以及介于两者之间的脚本！)，在 Knative 和 Kubernetes 以及一些无服务器平台上运行我们的代码，用 Python 编写代码，这些代码可以与我们用 C++、Elixir、Java 编写的其他代码接口……不用说，在这一点上有一大堆要检查的内容。

我们理想的工具应该是能与我们系统中的其他东西无缝协作，在所有可能的情况下都能正常工作，不会出现任何问题，并且能在它工作时折叠我们的衣物。更现实一点来说，一个对我们来说很容易集成的工具，并且几乎不需要改变我们的其他设置或大型 OSS 贡献来弥补差距，这将是我们最好的选择。

**安全迁移到新解决方案的计划是什么？**在这种情况下，我们如何才能避免完全破坏一切或者花费几个季度的时间一次移植一个系统呢？这些工具中的任何一个比其他工具更容易或更难工作吗？迁移是否足够公式化以编写变更脚本，而不需要全部手动编写？

我们坚信在任何两个可能的系统之间都有一条安全的迁移路径，但是有些情况肯定比其他情况容易得多。理想情况下，我们能够从以前的工作流程过渡到最终的选择，而不会走太多弯路或临时修改。

最后，令人惊讶的是，最终选择诗歌并没有产生摩擦——这将是一种迁移，是的，但不是一种我们无法轻松应对的迁移。它将解决我们面临的所有问题以及其他一些问题，例如帮助我们简化虚拟环境管理。所有其他的选择都有它们自己更大的缺陷和限制，需要改变我们做不相关事情的方式，或者给我们的系统增加更多的工具和复杂性。

虽然 does 试图一次解决多个问题(包管理、版本约束、虚拟环境等等)，但它在某种程度上与我们从编写第一行代码开始就一直在拼凑的系统非常吻合。我们通常试图坚持使用“适合工作的工具”，而不是“做所有事情的工具”，但是当“一个工具”碰巧也能做所有事情时，那么，决定就很容易了。

一旦 RFC 被接受，其中的一些细节被制定出来，实际的改变就开始了。

## 迁移到诗歌

由于人工智能团队有许多代码库分布在几个团队中，对我们的用户来说具有不同程度的复杂性和重要性，所以仔细计划如何做出我们的改变是很重要的。使用我们的一些不太关键的系统(比如内部工具或者对新功能想法的黑客马拉松式的研究)作为第一步，以确保我们已经解决了任何困难，然后我们首先优先考虑面向生产的代码，并以我们的方式向后工作。对于我们最重要的系统来说，最重要的是首先解决这些问题，以防我们的时间表估计严重偏差，在我们准备好之前就发生问题。

在某些情况下，我们决定不升级代码，因为成本效益比太低了。例如，在数据科学团队中，我们提交来自特定实验的代码，有时包括 Jupyter 笔记本和其他没有打包和没有单元测试的代码。打包来自 *亿万年前* 2018 的实验代码，并手动测试它以确保它仍然工作，这似乎不值得，尤其是当我们的大部分实验代码要么在实验后没有使用，要么已经在其他存储库中转换为生产代码。

由于我们系统地检查和修改了几乎所有的代码，我们试图在这个过程中解决其他问题；虽然我们想小心地将范围蔓延添加到已经复杂的项目中，但在简单的情况下，我们认为最好让您注意到的东西比您发现它们时更好。由于这个原因，它最终不是一对一的迁移，但是诗歌使得打包代码变得足够容易，从而不会延长在 *alllll* 的迁移时间。我们修复的一些问题包括:

*   重命名错误命名的包
*   更新/添加包描述
*   标准化我们的 docker 文件约定并记录这些标准
*   修复任何文件夹名称不一致的问题，并阐明文档中的最佳实践
*   检查依赖性实际上是必要的，并删除那些不必要的
*   我们可以扩展依赖项的版本范围，并准确锁定那些没有使用语义版本或任何其他有用模式的依赖项(我们的法律团队遗憾地通知我们，在这里链接到一些流行的包不是一个好主意)

我们只专注于解决一次问题，而且是以一种可组合的方式。例如，我们没有在我们的每个存储库上创建定制的 CircleCI 工作流，而是创建了一个可重用的 [CircleCI orb](https://circleci.com/developer/orbs/orb/talkiq/poetry) ，其任务是将任意包部署到包索引中，在诗歌环境中运行命令，等等。然后我们可以在我们所有的仓库中使用这个 orb，而不需要重复的代码。

总的来说，将我们的软件包从 pip 切换到诗歌是相当简单和快速的，但是我们希望将工作进行分发，这样每个人都有机会亲身体验使用诗歌的工作。围绕这一点的教育花费了大量的时间和精力，特别是因为我们与具有不同背景和对软件熟悉程度的队友一起工作。我们在迁移上花费的大部分时间都是有意为之的，为我们所有的团队成员在引入新系统时学习它留下了空间，而不是随着时间的推移吸收变化。

## 教育、文档、演示

我们的主要教育方法是通过演示和文档。

这些演示对于让整个团队了解 pip 的进展、我们为什么选择诗歌以及迁移过程将会是什么样子非常有用。我们召开了协作会议，会上我们仔细检查了所有包的列表，并将每个包分配给它的一个代码所有者来处理它的迁移。通过以平衡的方式将工作委派给整个团队，拥有快速周转的完成里程碑，并清楚地传达这项工作的优先级，我们能够确保迁移顺利进行。在某些情况下，团队选择为一个特定的存储库进行短期开发冻结，这样他们就可以埋头专注于这个变更，而不需要担心其他正在进行的优先级。

我们还必须在短时间内生成大量的文档。对于我们的大部分内部文档，我们使用 [Sphinx](https://www.sphinx-doc.org/en/master/) ，并配置我们所有的存储库，以便在每次新的变更时自动从文本文件构建并发布我们的文档。这使得每一次变更都很容易包含或更新我们的文档，并且很容易跨多个团队交叉引用来自多个来源的信息。这也使得回顾这些文档变得容易，或者帮助给每个人工智能团队一个简单的参考点来理解其他人已经完成了什么；通过使用存储在 git 中的文本文件，审查文档就像审查代码一样，这是我们经常做的事情。

对于语音识别团队，Vasundhara 在一个分支上创建了一个文档大纲， [xe](https://www.macmillandictionary.com/us/dictionary/american/xe) 立即与团队分享了这个文档大纲，尽管它并不完整。该团队在升级 Docker 文件和测试 Docker 映像之前先升级软件包，因此 xe 首先填写了软件包升级的分步说明。当团队中的其他人在做这个的时候，xe 完成了剩下的部分；这种并行工作使得升级过程不会因为缺少文档而受阻。我们在更新文档时畅通无阻的另一种方式是将这个特定的文档保存在 git 分支上，而不是每次都推到 main 上，因为那将需要审查并可能成为瓶颈。

当然，文档在第一次尝试时从来都不是完美的，因此基于团队 Slack 频道中出现的澄清请求，Vasundhara 细化了说明，并融合了其他人的问题、建议和想法。我们最后不得不在文档中添加一个 FAQ 部分，因为一些问题和陷阱经常出现，不一定符合说明。

## 常见(问答)问题

FAQ 部分的一些答案已经在官方诗歌文档[](https://python-poetry.org/docs/)或命令行用法中提供。例如，经常出现的一个问题是如何删除一个诗歌虚拟环境并从头开始( [诗歌环境移除](https://python-poetry.org/docs/managing-environments#deleting-the-environments) 命令)。另一个出现了几次的问题是，人们无法使用 poem 命令，即使他们刚刚 pip 安装了它:这是因为他们错过了 pip 安装命令的输出，该命令说他们必须将一个文件夹添加到他们的 PATH 环境变量中。当问题在团队频道或私人消息中被不止一次地提出时，它们被添加到诗歌迁移指南的 FAQ 部分并在那里得到回答，同时还有一个到带有答案的官方位置的链接。

无畏的工程师也经常向我们提出一些问题，他们希望超越完成迁移所需的最低理解水平。例如，我们建议在指定依赖项时不要使用插入符号语法，许多人想知道我们为什么提出这个建议的更多细节。

让我们假设一个名为 aardvark 的包。假设我在你的公关上提出了这个改变，而你感到困惑，因为根据官方的诗歌文档，它们的意思是一样的。

现在我们对 1.2.0 到 2.0.0 版本(不包括)肯定是好的，因为 [语义版本](https://semver.org/) 。比方说 aardvark 版本 2.0.0 发布了，我们测试了它，一切正常。现在，我们希望扩大范围的上限，但是没有理由放弃范围的下限——毕竟，我们没有使用 v1.3.0 独有的任何特性！

你不能用脱字符语法做到这一点。^1.2.0 始终只表示> =1.2.0，<2.0.0\. To get it to include 2.0.0 you would necessarily have to lose the 1.x.x versions — you’d have to change it to, say, ^2.0.0.

On the other hand, if you had > =1.2.0，<2.0.0, you could just change this to > =1.2.0，<3.0.0.

It’s easier to read and reason about > =1.2.0，<2.0.0 than the caret syntax, it’s consistent with all the other code, and therefore our documentation recommended the “> =，诗加命令。幸运的是，这种事情很容易添加到我们的林挺规则中，再也不需要担心了，因为 poem 使用 TOML 配置语言编写规则非常简单。

其他常见问题是关于诗歌使用的问题。

## 诗歌 Gotchas

有一个常见的用户体验问题与为我们的私有包索引配置带有认证令牌的诗歌有关。运行配置命令时，人们要么看不到输出，要么看到以下内容:

两种选择都让许多人感到困惑，因为没有明显的成功迹象。所以我们必须解释这两种情况实际上都是成功的——在一种情况下，凭证存储在系统密匙环中，而在另一种情况下，如果找不到正确配置的密匙环，poem 默认将凭证存储在明文文件中。

也许最大的问题(也是最需要解决的问题)是 poem 在 Docker 图像中的行为，并且禁用了虚拟环境。如果你已经使用 pip 安装了 poem，poem 让poem install–no-dev*卸载任何未被管理的包*的行为意味着 poem 实际上卸载了它自己*和它所有的依赖项*，这些有时是其他包所需要的。将诗歌作为可选的依赖项添加到所有使用诗歌包的 Docker 图像中是我们的解决方法，尽管在这一步之后我们从未使用过诗歌本身。

## 诗歌的未来

几个月过去了，尘埃早已落定。诗歌只是现在世界的方式，旧的方式已经消失得无影无踪。在这一过程中有几个障碍，比如由半打同时发生的边缘情况引起的几个 [难以置信的小众问题](https://github.com/renovatebot/renovate/issues/8547) ，但是没有一个问题没有被迅速而容易地解决。我们已经向 [提交了几篇文章，修复了 poems 的终端输出](https://github.com/python-poetry/poetry/pull/3881) 的一些问题，并向 [aid 提交了几篇文章，以支持钥匙圈式认证](https://github.com/python-poetry/poetry/pull/4120) ，但在大多数情况下，一切都很快，很实用；事实上，人们很容易忘记这个曾经严重影响我们的问题。

能够忘记这曾经是一件大事当然是目标；总而言之，我们对新系统很满意，能够花更少的时间担心我们的包装，花更多的时间致力于人们似乎很兴奋的整个“大数据和人工智能”的事情。

<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 68 31" version="1.1"><title>Group</title> <desc>Created with Sketch.</desc></svg>