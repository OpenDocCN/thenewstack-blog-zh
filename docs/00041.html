<html>
<head>
<title>Some Reasons Why Swift is Better than Objective-C</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift优于Objective-C的一些原因</h1>
<blockquote>原文：<a href="https://thenewstack.io/some-reasons-why-swift-is-better-than-objective-c/#0001-01-01">https://thenewstack.io/some-reasons-why-swift-is-better-than-objective-c/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">


<p class="translated">Swift于2014年由苹果公司发布，被描述为ob active-C，但没有C，反应不一。对于现有的Objective-C开发人员来说，这是一个“谁需要它？”，而对于千百万努力学习目标C的人来说，这是一股清新的空气。这里我举几个案例来说明为什么我觉得Swift作为编程语言比Objective-C优越。</p>
<p class="translated">目标-C已经有将近25年的历史了，最好由那些有C思维的人来编写。例如，将文本分配给一个字符串需要一个指向NSString的指针，这是一个内置类型:<br/></p>
<div id="crayon-642310693dc19439467164" class="crayon-syntax crayon-theme-github-gist crayon-font-liberation-mono crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-always">
<p class="crayon-plain-wrap"/>
<div class="crayon-main">
<table class="crayon-table">
<tr class="crayon-row">
<td class="crayon-nums " data-settings="show">

</td>
<td class="crayon-code translated"><div class="crayon-pre"><p class="crayon-line" id="crayon-642310693dc19439467164-1"><span class="crayon-e ">ns string *</span><span class="crayon-i">str</span><span class="crayon-h"/>=<span class="crayon-h"/>@<span class="crayon-s">“你好”，</span>；</p> </div></td>
</tr>
</table>
</div>
</div>

<p class="translated">这意味着你真的需要了解指针和内存分配。现在，ARC(自动引用计数)的引入简化了内存分配，因为以前您必须手动进行分配，使用retain来分配内存，并确保使用release来释放内存。Objective-C 2.0还引入了更简单的文字语法，因此可以使用更简单的代码来代替冗长繁琐的方法调用。这两个都将true(是)赋给NSNumber。<br/></p>
<div id="crayon-642310693dc1e319045530" class="crayon-syntax crayon-theme-github-gist crayon-font-liberation-mono crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-always">
<p class="crayon-plain-wrap"/>
<div class="crayon-main">
<table class="crayon-table">
<tr class="crayon-row">
<td class="crayon-nums " data-settings="show">

</td>
<td class="crayon-code translated"><div class="crayon-pre"><p class="crayon-line" id="crayon-642310693dc1e319045530-1"><span class="crayon-e ">ns number *</span><span class="crayon-i">my bool number</span><span class="crayon-h"/>=<span class="crayon-h"/>【<span class="crayon-e">ns number</span><span class="crayon-i">numberWithBool</span><span class="crayon-st">:</span><span class="crayon-i">是</span>；</p><p class="crayon-line crayon-striped-line" id="crayon-642310693dc1e319045530-2"><span class="crayon-e ">ns number *</span><span class="crayon-i">my bool number</span><span class="crayon-h"/>=<span class="crayon-h"/>@<span class="crayon-i">是</span>；</p> </div></td>
</tr>
</table>
</div>
</div>

<p/>
<h2 class="translated">这么多文件！</h2>
<p class="translated">标准C有不同的编译单元，每个编译单元通常有一个扩展名为. h的头文件和一个扩展名为. C的C文件。m not .c .其他编程语言比如Java，C#，甚至JavaScript当然还有Swift只用一个文件管理。</p>
<p class="translated">使用头文件的原因是当你访问另一个文件中定义的变量、类型或函数时。的。c或者。m文件有函数体，但是头文件是声明函数的地方。必须读取单独的头文件会降低编译速度。Swift只有一个声明。</p>
<h2 class="translated">迅速发生的</h2>
<p class="translated">Swift从其他语言中精选了许多最佳特性。选项类似于C#中的可空类型。变量声明类似于Pascal，只是var适用于每个声明。总的来说，这是一种非常优雅的语言，一些特性显示了一些非常好的想法。简化的语法增强了可读性。除非您想在一行中包含多个语句，否则不需要用分号来分隔语句。</p>
<p class="translated">最好的快速改进之一是使用控制流语句，如if、for、while和do-while。在C和许多其他语言中，语句后的块可以是一条语句，也可以是大括号内的块。程序员经常被警告说，单个语句，而不是大括号内的语句会导致问题，2014年发生了一个真正的大错误<a title="Link to Wired.com" href="http://www.wired.com/2014/02/gotofail/" target="_blank" class="ext-link" rel="external "> OpenSSL Goto error </a>。<br/></p>
<div id="crayon-642310693dc1f200625047" class="crayon-syntax crayon-theme-github-gist crayon-font-liberation-mono crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-always">
<p class="crayon-plain-wrap"/>
<div class="crayon-main">
<table class="crayon-table">
<tr class="crayon-row">
<td class="crayon-nums " data-settings="show">

</td>
<td class="crayon-code translated"><div class="crayon-pre"><p class="crayon-line" id="crayon-642310693dc1f200625047-1"><span class="crayon-e">if</span><span class="crayon-h"/>(<span class="crayon-i">err</span><span class="crayon-h"/>=<span class="crayon-h"/><span class="crayon-i">sslhashsha 1</span><span class="crayon-st">)。</span> <span class="crayon-e">更新</span>(<span class="crayon-sy">&amp;amp；</span> <span class="crayon-i"> hashCtx </span>、<span class="crayon-h"/><span class="crayon-sy">&amp;amp；</span>T29】signed params)<span class="crayon-h"/>！=<span class="crayon-h"/><span class="crayon-cn">0</span>)</p><p class="crayon-line crayon-striped-line" id="crayon-642310693dc1f200625047-2"><span class="crayon-h"/><span class="crayon-e">goto</span><span class="crayon-i">fail</span>；</p> <p class="crayon-line" id="crayon-642310693dc1f200625047-3"> <span class="crayon-h"> </span> <span class="crayon-e">转到</span> <span class="crayon-i">失败</span>；</p> </div></td>
</tr>
</table>
</div>
</div>

<p class="translated"><br/>尽管有缩进，(这不是Python)第二个goto总是被执行，因此跳过了大量的检查并危及SSL加密。它在iOS 7.0.6中得到修复，但如果在Swift中编码，它会导致编译错误。除了switch语句，所有其他控制流特性都需要大括号，并且不允许使用单行语句。</p>
<p class="translated">所以这是可以的<br/></p>
<div id="crayon-642310693dc21451884492" class="crayon-syntax crayon-theme-github-gist crayon-font-liberation-mono crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-always">
<p class="crayon-plain-wrap"/>
<div class="crayon-main">
<table class="crayon-table">
<tr class="crayon-row">
<td class="crayon-nums " data-settings="show">

</td>
<td class="crayon-code translated"><div class="crayon-pre"> <p class="crayon-line" id="crayon-642310693dc21451884492-1"> <span class="crayon-i">如果</span> <span class="crayon-h"> </span> <span class="crayon-m">我</span><span class="crayon-h"/><span class="crayon-sy">&amp;lt；</span><span class="crayon-h"/><span class="crayon-cn">9</span><span class="crayon-h"/>{</p><p class="crayon-line crayon-striped-line" id="crayon-642310693dc21451884492-2"><span class="crayon-h"/><span class="crayon-e">打印</span> ( <span class="crayon-s">【你好】</span> ) </p> <p class="crayon-line" id="crayon-642310693dc21451884492-3"> } </p> </div></td>
</tr>
</table>
</div>
</div>

<p class="translated"><br/>但这不是，而且会产生‘预期的{ after if condition’错误。<br/></p>
<div id="crayon-642310693dc22079944496" class="crayon-syntax crayon-theme-github-gist crayon-font-liberation-mono crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-always">
<p class="crayon-plain-wrap"/>
<div class="crayon-main">
<table class="crayon-table">
<tr class="crayon-row">
<td class="crayon-nums " data-settings="show">

</td>
<td class="crayon-code translated"><div class="crayon-pre"> <p class="crayon-line" id="crayon-642310693dc22079944496-1"> <span class="crayon-i">如果</span> <span class="crayon-h"> </span> <span class="crayon-m">我</span><span class="crayon-h"/><span class="crayon-sy">&amp;lt；</span><span class="crayon-h"/><span class="crayon-cn">9</span><span class="crayon-h"/></p><p class="crayon-line crayon-striped-line" id="crayon-642310693dc22079944496-2"><span class="crayon-h"/><span class="crayon-e">打印</span> ( <span class="crayon-s">【你好】</span> ) </p> </div></td>
</tr>
</table>
</div>
</div>

<p/>
<h2 class="translated">静态或动态</h2>
<p class="translated">Swift为iOS开发带来了类型安全，因为Objective-C的动态特性意味着编译器不能依赖于在编译时知道方法的类型。有利的一面是，你可以在运行时向现有的类中添加方法，并改变实例的类型，但这些都是有代价的；运行时代码必须对选择器实现进行额外的检查，这就增加了额外的代码。由于静态类型化，Swift编译器可以优化调用并直接调用方法或使用虚拟表(vtable)。</p>
<h2 class="translated">返回带有元组的数据</h2>
<p class="translated">Objective-C不直接支持元组。这是一种将两个或三个值集中在一个地方的方法。有点像结构，但更简单。Swift增加了元组，这里有一个字符串和一个Int。<br/></p>
<div id="crayon-642310693dc23664486409" class="crayon-syntax crayon-theme-github-gist crayon-font-liberation-mono crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-always">
<p class="crayon-plain-wrap"/>
<div class="crayon-main">
<table class="crayon-table">
<tr class="crayon-row">
<td class="crayon-nums " data-settings="show">

</td>
<td class="crayon-code translated"><div class="crayon-pre"><p class="crayon-line" id="crayon-642310693dc23664486409-1"><span class="crayon-i">var</span><span class="crayon-h"/><span class="crayon-st">a</span>:(<span class="crayon-i">String</span>，<span class="crayon-i">Int</span>)<span class="crayon-h"/>=<span class="crayon-h"/>(<span class="crayon-s">【大卫】</span>，<span class="crayon-cn"> 40 </span> ) </p> </div></td>
</tr>
</table>
</div>
</div>

<p class="translated"><br/>可以通过位置访问各个部分，因此a.0的值为“David ”, a . 1的值为40。</p>
<p class="translated">元组真正的得分是在函数的返回值中。对于计算多个值或者返回一个错误代码的函数来说，能够返回多个值是非常方便的。下面的示例演示如何实现findpos函数，该函数搜索提供的数组并返回位置。返回的元组是可选的元组，因此它可以检查空数组，并在这种情况下返回nil。<br/></p>
<div id="crayon-642310693dc24168864342" class="crayon-syntax crayon-theme-github-gist crayon-font-liberation-mono crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-always">
<p class="crayon-plain-wrap"/>
<div class="crayon-main">
<table class="crayon-table">
<tr class="crayon-row">
<td class="crayon-nums translated" data-settings="show"><div class="crayon-nums-content"><p class="crayon-num" data-line="crayon-642310693dc24168864342-1">1</p><p class="crayon-num crayon-striped-num" data-line="crayon-642310693dc24168864342-2">2</p><p class="crayon-num" data-line="crayon-642310693dc24168864342-3">3</p><p class="crayon-num crayon-striped-num" data-line="crayon-642310693dc24168864342-4">4</p><p class="crayon-num" data-line="crayon-642310693dc24168864342-5">5</p><p class="crayon-num crayon-striped-num" data-line="crayon-642310693dc24168864342-6">6</p><p class="crayon-num" data-line="crayon-642310693dc24168864342-7">7</p><p class="crayon-num crayon-striped-num" data-line="crayon-642310693dc24168864342-8">8</p><p class="crayon-num" data-line="crayon-642310693dc24168864342-9">9</p>10<p class="crayon-num" data-line="crayon-642310693dc24168864342-11">11</p><p class="crayon-num crayon-striped-num" data-line="crayon-642310693dc24168864342-12">12</p><p class="crayon-num" data-line="crayon-642310693dc24168864342-13">13</p><p class="crayon-num crayon-striped-num" data-line="crayon-642310693dc24168864342-14">14</p><p class="crayon-num" data-line="crayon-642310693dc24168864342-15">15</p><p class="crayon-num crayon-striped-num" data-line="crayon-642310693dc24168864342-16">16</p></div></td>
<td class="crayon-code translated">)(我)(们)(都)(不)(知)(道)(,)(我)(们)(还)(不)(知)(道)(,)(我)(们)(还)(有)(些)(什)(么)(情)(感)(呢)(?)(我)(们)(都)(不)(知)(道)(了)(,)(我)(们)(还)(不)(知)(道)(,)(我)(们)(还)(是)(有)(什)(么)(情)(感)(呢)(?)(我)(们)(还)(不)(知)(道)(,)(我)(们)(们)(还)(不)(知)(道)(,)(我)(们)(还)(有)(些)(什)(么)(好)(的)(情)(感)(。( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )<span class="crayon-h"/><p class="crayon-line crayon-striped-line" id="crayon-642310693dc24168864342-4"><span class="crayon-h"/><span class="crayon-e">【如果】</span><span class="crayon-i">值</span><span class="crayon-st">)(我)(们)(都)(不)(知)(道)(,)(我)(们)(还)(不)(知)(道)(,)(我)(们)(还)(不)(知)(道)(,)(我)(们)(还)(不)(知)(道)(,)(我)(们)(还)(不)(知)(道)(,)(我)(们)(还)(不)(知)(道)(,)(我)(们)(还)(不)(知)(道)(,)(我)(们)(还)(不)(知)(道)(。 )(我)(们)(都)(不)(知)(道)(,)(我)(们)(还)(不)(知)(道)(,)(我)(们)(还)(不)(知)(道)(,)(我)(们)(还)(不)(知)(道)(,)(我)(们)(还)(不)(知)(道)(,)(我)(们)(还)(不)(知)(道)(,)(我)(们)(还)(不)(知)(道)(,)(我)(们)(还)(不)(知)(道)(。 )(我)(们)(都)(不)(知)(道)(,)(我)(们)(还)(不)(知)(道)(,)(我)(们)(还)(不)(知)(道)(,)(我)(们)(还)(不)(知)(道)(,)(我)(们)(还)(不)(知)(道)(,)(我)(们)(还)(不)(知)(道)(,)(我)(们)(还)(不)(知)(道)(,)(我)(们)(还)(不)(知)(道)(,)(我)(们)(还)(不)(知)(道)(。 )(我)(们)(都)(没)(想)(到)(这)(些)(事)(,)(我)(们)(就)(是)(这)(些)(事)(,)(只)(是)(这)(些)(事)(,)(只)(是)(这)(些)(事)(。)(我)(们)(都)(不)(知)(道)(,)(我)(们)(还)(不)(知)(道)(,)(我)(们)(还)(不)(知)(道)(,)(我)(们)(还)(不)(知)(道)(。</span></p></td>
</tr>
</table>
</div>
</div>

<p class="translated"><br/>“if var b =”语法意味着如果对findpos的调用返回一个非零值，那么它声明一个变量b并将返回值赋给它。<br/>find pos的返回值是一个可选的元组，但是要访问该元组，必须将其解包。这是通过“if var b”完成的，因此b包含未包装的元组，而不是可选的。</p>
<p class="translated">这可能需要一点时间来理解。考虑这个替代代码，而不是“if var b”。<br/></p>
<div id="crayon-642310693dc25263948798" class="crayon-syntax crayon-theme-github-gist crayon-font-liberation-mono crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-always">
<p class="crayon-plain-wrap"/>
<div class="crayon-main">
<table class="crayon-table">
<tr class="crayon-row">
<td class="crayon-nums " data-settings="show">

</td>
<td class="crayon-code translated"><div class="crayon-pre"><p class="crayon-line" id="crayon-642310693dc25263948798-1"><span class="crayon-i">var</span><span class="crayon-h"/><span class="crayon-i">b</span><span class="crayon-h"/>=<span class="crayon-h"/><span class="crayon-e">find pos</span>(<span class="crayon-cn">45</span>，<span class="crayon-i">数组</span>)</p><p class="crayon-line crayon-striped-line" id="crayon-642310693dc25263948798-2"><span class="crayon-i">if</span><span class="crayon-h"/><span class="crayon-i">b</span><span class="crayon-h"/>！=<span class="crayon-h"/><span class="crayon-e">nil</span><span class="crayon-h"/>{</p><p class="crayon-line" id="crayon-642310693dc25263948798-3"><span class="crayon-h"/><span class="crayon-i">if</span><span class="crayon-h"/><span class="crayon-i">b</span>！。<span class="crayon-i">找到</span><span class="crayon-h"/>{</p><p class="crayon-line crayon-striped-line" id="crayon-642310693dc25263948798-4"><span class="crayon-h"/><span class="crayon-e">打印</span> <span class="crayon-h"> </span> ( <span class="crayon-i"> b </span>！。<span class="crayon-i">位置</span>)</p><p class="crayon-line" id="crayon-642310693dc25263948798-5"><span class="crayon-h"/>}</p><p class="crayon-line crayon-striped-line" id="crayon-642310693dc25263948798-6">}</p></div></td>
</tr>
</table>
</div>
</div>

<p class="translated">这里b有一个可选元组的值，为了访问元组部分，它需要从可选元组解包。您可以通过添加感叹号来手动完成此操作。允许您访问基础元组成员。但是这不是好的编程，因为它需要两个解包。因此使用“if var b”或“if let b”。如果返回值从未改变，则使用“if let b”。</p>
<h2 class="translated">用线串</h2>
<p class="translated">Swift字符串是Objective-C的一个重大改进。不用担心使用可变或不可变的字符串类型，如果你想要一个字符串，你可以使用var来声明它，或者使用let来声明不可变。连接字符串就像<br/>一样简单</p>
<div id="crayon-642310693dc26061560028" class="crayon-syntax crayon-theme-github-gist crayon-font-liberation-mono crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-always">
<p class="crayon-plain-wrap"/>
<div class="crayon-main">
<table class="crayon-table">
<tr class="crayon-row">
<td class="crayon-nums " data-settings="show">

</td>
<td class="crayon-code translated"><div class="crayon-pre"><p class="crayon-line" id="crayon-642310693dc26061560028-1"><span class="crayon-e">var</span><span class="crayon-i">myStr</span><span class="crayon-h"/>=<span class="crayon-h"/><span class="crayon-s">“我的名字是”</span></p><p class="crayon-line crayon-striped-line" id="crayon-642310693dc26061560028-2"><span class="crayon-i">myStr</span><span class="crayon-h"/>+=<span class="crayon-h"/><span class="crayon-s">【大卫波顿】</span> </p> </div></td>
</tr>
</table>
</div>
</div>

<p class="translated"><br/>什么不那么明显，我甚至不用声明字符串类型。编译器推断它是=右侧的字符串。</p>
<p class="translated">Swift字符串支持完整的Unicode字符集，甚至可以在switch语句中使用，但这两者在Objective-C中都不可用。</p>
<h2 class="translated">结论</h2>
<p class="translated">我的目的并不是抨击Objective-C，它是一种非常成功的编程语言，因为已经有许多应用程序是用它开发的，只是为了展示Swift如何在它的基础上进行改进。我把Objective-C看做一台手动割草机，在那里你会流汗很多，但它能完成工作。相比之下，Swift就像一台电动割草机，将减少所需的工作量。它也有更好的保护，所以你不能切掉你的手指。</p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
<title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>
</div>
</div>    
</body>
</html>