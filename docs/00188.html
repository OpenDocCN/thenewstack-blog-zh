<html>
<head>
<title>Delphix: Use Virtual Data, not Fake Data, to Test Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Delphix:使用虚拟数据，而不是假数据来测试应用程序</h1>
<blockquote>原文：<a href="https://thenewstack.io/delphix-use-virtual-data-not-fake-data-test-apps/#0001-01-01">https://thenewstack.io/delphix-use-virtual-data-not-fake-data-test-apps/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">


<p class="translated">在新的堆栈中，您经常看到我们讨论持续集成和持续交付(CI/CD) <a href="https://thenewstack.io/heroku-officially-embraces-cicd-automating-staging-github/" class="local-link">如何帮助开发人员自动化测试</a>和准备应用程序的过程。但是，如果这些开发人员正在自动构建旨在利用大规模客户数据库的应用程序，那会怎么样呢？</p>
<p class="translated">更深入地思考一下这个问题:从真实的数据库中借用真实客户数据的片段来测试真实环境中的数据库驱动的应用程序可能至少是不符合规范的，而且可能是不道德的，并且很可能是非法的，这取决于你的雇主或客户。生成合成数据(“Doe，John Q”，“1000 Liberty Lane”等)。)是一个非常耗时的过程，尤其是当应用程序在任何时候使用的数据量对于测试的真实性都至关重要的时候。</p>
<p class="translated">如果不经常运行的测试依赖于自制的、虚假的数据，那么它就不再是真正的持续集成。这是模拟连续性。</p>
<h2 class="translated">Lorem Ipsum</h2>
<p class="translated">一家名为<a href="https://www.delphix.com/" class="ext-link" rel="external ">德尔菲克斯</a>的公司的产品管理副总裁丹·格雷夫斯说:“公司做了很多变通办法，试图在没有虚拟数据的情况下做到最好。</p>
<p class="translated">虚拟数据不是假数据。在开源社区中，有多个正在进行的项目致力于开发API来检索适用于应用程序测试的虚假数据。例如对于变长字符串，可以设置<strong><a href="http://jsonplaceholder.typicode.com/" class="ext-link" rel="external ">JSONPlaceholder</a></strong><a href="http://jsonplaceholder.typicode.com/" class="ext-link" rel="external ">根据特定参数产生拉丁文无意义缠结的链</a>。<a href="https://scotch.io/tutorials/generate-fake-data-for-your-javascript-applications-using-faker" class="ext-link" rel="external ">一个名为Faker </a>的Node.js模块产生虚假记录，帮助建立个人数据表。<strong> <a href="http://www.mockapi.io/#/docs" class="ext-link" rel="external "> MockAPI </a> </strong> <a href="http://www.mockapi.io/#/docs" class="ext-link" rel="external ">不仅可以生成假记录</a>，还可以生成它们之间的假关系，用于关系数据库测试。但是如果你需要的只是数据而没有方法论，那么有一个网站<strong>generatedata.com</strong>T21】。</p>
<p class="translated">虚假数据的产生是否会带来性能风险，尤其是在“大数据”环境中，数据量可能会影响并行性？在去年12月出版的一本名为《安全共享大数据:管理数据安全 的奥莱利书中，作者泰德·邓宁和艾伦·弗里德曼博士甚至建议在授权应用测试之前测试虚假数据。</p>
<p class="translated">在引用一个特定的案例研究时，Friedman和Dunning写道，“一旦在安全边界内确定特定版本的合成数据在当前模型训练算法的背景下与KPIs关键性能指标]匹配得足够好，那么这些伪造数据就会在安全屏障外被用来构建新的和改进的感兴趣的模型版本。”</p>
<blockquote><p class="translated">“在过去几年里，你看到的许多数据泄露，”他解释说，“来自对非生产系统的攻击——开发、测试和记录系统——因为它们通常没有得到很好的保护。”</p></blockquote>
<p class="translated">格雷夫斯告诉我们，通过从活动数据库中切割出真实客户数据的小楔形，通常可以避免现实世界模拟中猪拉丁短语的所有性能调整。但这也带来了一系列问题，其中最大的问题并不像你刚刚想到的那样明显。</p>
<p class="translated">“如果实际的应用程序有一个10tb的大数据库，”他告诉我们，“他们可能会运行百分之一的数据库，这样他们可以在30分钟内而不是一天内刷新它。但问题显然是。因此，它不是生产代表。他们会发现数据错误。”</p>
<h2 class="translated">永远不要拿着满满一副牌玩</h2>
<p class="translated">但他说，即使细分过程只消耗半个小时的测试时间，但它必须完成的事实可能会限制组织平均每周投入自动回归测试的总时间，即使它们被纳入了据称是CI/CD的过程。“在一次跑步结束时，你能在两分钟后再跑一次吗？还是一天后？如果晚了一天，这意味着你一周实际上只运行了七个小时的测试，尽管运行一个测试只需要一个小时。”</p>
<p class="translated">Graves建议的解决方案，你可能已经猜到了，是Delphix的数据操作软件5.0版本，一般在4月份发布。深深隐藏在<a href="https://www.delphix.com/introducing-delphix-5" class="ext-link" rel="external ">Delphi 5</a>的营销信息“推动商业灵活性”之下的是发现它提供了一种叫做选择性数据分发的服务。如果数据库是一副牌，那么可以想象这是一种洗牌的方式，同时去掉一些牌来完成满堂红或同花顺，这些牌可以使记录变得可识别。</p>
<p class="translated">正如Graves所描述的，该过程“消除”了数据的标识，以满足两个主要目标:保持对管理法规(如SOX和HIPAA)的遵从，以及降低安全风险。“在过去几年里，你看到的许多数据泄露，”他解释说，“来自对非生产系统的攻击——开发、测试和记录系统——因为它们通常没有得到很好的保护。”</p>
<p class="translated">Delphix profiling系统扫描HIPAA规定的数据，识别需要屏蔽的字段，并遵守关于谁应该有权访问该数据的政策和指令。结果是包含不可识别记录的经过清理的完整卷拷贝。此外，由于现实世界的数据库模式会产生来自多个来源的记录的联合和连接(对于HIPAA监管的系统，Graves说，数量有几十个)，所以每个错误记录都必须遵循相同的关系模式。这样，每当一个真实的人被一个假名替换时，相同的假名将适用于所有情况。</p>
<p class="translated">“在数据屏蔽的世界里有很多科学，”他评论道，“来确保当我们匿名化信息时，我们不会破坏它运行分析或进行QA测试的有效性。我们花了很多时间来调整这些算法，以保留需要保留的内容。”</p>
<p class="attribution translated">专题图片:2010年澳大利亚堪培拉的一座桥梁建筑倒塌，由Flickr用户Richard拍摄，获得知识共享许可。</p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
<title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>

</div>
</div>    
</body>
</html>