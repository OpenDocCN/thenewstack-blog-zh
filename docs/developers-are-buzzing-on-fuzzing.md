# 开发者们正忙于 Fuzzing

> 原文：<https://thenewstack.io/developers-are-buzzing-on-fuzzing/>

找到代码中的漏洞非常重要，因为如果您不这样做，攻击者就会这样做。为了找到这些漏洞，有许多安全测试技术可用(各有利弊)，包括静态代码分析、笔测试甚至手动代码审计。然而，另一种被称为 fuzzing 的安全测试技术最近受到了很多关注，因为它的好处、随着时间的推移的巨大改进以及易用性。

## 模糊化的基础

 [乔纳森·梅茨曼

Jonathan 是 Google 开源安全团队的一名软件工程师。他是 OSS-Fuzz、FuzzBench 和 ClusterFuzz 的核心开发者。](https://www.linkedin.com/in/jonathan-metzman-b8892688/) 

Fuzzing 是一种向程序发送随机输入并监控其行为(通常针对崩溃或断言失败)的技术。Fuzzing 很有趣，因为它可以发现安全性和功能性缺陷。例如，谷歌迄今为止已经使用 fuzzing 找到了 5 万个 bug。其中，超过 13，000 个错误是安全漏洞。

虽然有许多不同的方法来模糊，但基本思想非常简单。你创建了很多输入，把它扔给程序，看看它做了什么，是否有问题。如果您使用它来查找安全漏洞，您会希望选择更有可能触发漏洞和更有可能覆盖新代码的输入。

通过设计，起毛是连续的。随着时间的推移，它可能会遇到障碍，不再发现新的代码覆盖范围和新的 bug(这就是为什么开发人员不断改进 fuzzer 很重要)。开发人员必须不断地参与理解和弄清楚他们的模糊器是如何发展的，同时维护模糊器崩溃的问题。

### 当今模糊化是如何使用的:黑盒和覆盖制导模糊化

 [阿斯拉·阿里

Asra 是谷歌开源安全团队的软件工程师。她是开源项目 Envoy 的积极维护者，主要关注模糊化和安全性。](https://twitter.com/AsraEntr0py) 

目前使用的主要模糊化方法是黑盒模糊化和覆盖制导模糊化，这两种方法在不同的情况下各有优势。在黑盒模糊化中，有人编写一个格式感知脚本来为被模糊化的程序(也称为目标)生成输入，以帮助模糊化器深入分析它。相比之下，覆盖引导的模糊化器(如 [libFuzzer](https://llvm.org/docs/LibFuzzer.html) 、 [AFL](https://github.com/google/AFL) 和 [AFL++](https://github.com/AFLplusplus/AFLplusplus) )在模糊化期间监控目标的内部执行路径，以尝试自动确定其未来的输入。安全研究人员通常使用黑盒模糊化，它比覆盖导向模糊化更容易发现更多的错误。然而，编写好的黑盒模糊器需要努力和专业知识——覆盖引导的模糊器自动创建有趣的输入，虽然自动发现的输入可能没有那么好，但覆盖引导的模糊器往往更容易使用。覆盖率导向的模糊化倾向于被开发人员更多地用在他们维护的程序上。覆盖率导向的模糊化更像是开发人员编写的测试他们自己项目的单元测试。

真正有趣的是使用来自黑盒模糊化的技术，并将它们与覆盖引导模糊化相结合。在这种组合技术中，模糊器知道它们正在模糊的格式，并从它们正在模糊的目标那里获得反馈。这种方法最常见的应用是使用一种叫做 [libprotobuf-mutator](https://github.com/google/libprotobuf-mutator) 的工具，这种工具可以让用户更好地控制他们希望用覆盖率导向模糊化来模糊程序的哪些部分。

一个值得进一步讨论的覆盖引导模糊器是 [AFL++](https://aflplus.plus/) 。AFL(美国模糊 Lop)是第一个覆盖导向的模糊器，发现了许多漏洞并被积极使用——但在最初的 AFL 开发者离开谷歌后，AFL 没有得到维护。来自 AFL 活跃社区的成员分化了 AFL，创建了 AFL++，这是一个正在积极发展的领域。随着社区不断测试和添加来自学术界的最新改进以及实现他们自己的新想法，AFL++不断得到改进。今天，谷歌在 [ClusterFuzz](https://github.com/google/clusterfuzz) 中用 AFL++替换了 AFL，并通过资金支持 AFL++的开发。

## ClusterFuzz:使模糊更容易

这些年来，起毛变得越来越简单。今天，通过使用 ClusterFuzz，开发人员只需编写一次 fuzzer 单元测试，它就会自动链接到每个 fuzzing 引擎(例如 AFL++或 libFuzzer)。开发者不必了解 fuzzing 引擎是如何工作的，他们免费获得使用不同引擎的好处。所有开发人员要做的就是编写 20 到 50 行 fuzzer 测试，fuzzing 生命周期的其余部分是完全自动化的。从使用正确的杀毒程序生成正确的构建集并编译这些模糊目标，到发现 bug 并消除它们，ClusterFuzz 将 bug 分配给开发人员，然后甚至验证开发人员创建的补丁。

ClusterFuzz 是这种模糊化基础设施的核心，它自动执行这种端到端操作，以简化模糊化工作流。

## 模糊引擎:改进模糊引擎

以前，没有标准的方法来评估覆盖引导模糊化的潜在改进。创建 FuzzBench 是为了提供一种现实世界的方法来评估学术界和工业界正在开发的模糊引擎的改进。FuzzBench 是为研究人员提供的免费服务，他们可以将自己的 fuzzer 与一个简单的 API 集成，然后提交集成。然后，他们会收到一份评估，将他们的模糊器与来自学术界和工业界的其他最先进的模糊器进行比较。

FuzzBench 现在用于许多学术论文的评价。它帮助研究人员评估他们模糊的引擎改进。FuzzBench 有利于 ClusterFuzz 用户、开发这些 fuzzing 引擎的研究人员和一般 fuzzer 用户，他们将结果作为他们可能使用的技术的指南。像 ClusterFuzz 一样，FuzzBench 中的 fuzzer 基准测试工作流也得到了简化。

研究人员所要做的只是提交他们的 fuzzer 代码，然后它会根据从 [OSS-Fuzz](https://github.com/google/oss-fuzz) (一种为开源软件提供持续 fuzzer 的工具)中挑选的真实世界基准，以非常大的规模自动运行。因此，覆盖制导模糊技术正在不断改进。

## 案例研究:特使模糊化

[Envoy Proxy](https://www.envoyproxy.io/) 是一个开源软件项目，最初由 Lyft 发起。如今，许多公司在许多不同的应用程序中使用它，这使得对它进行安全测试变得至关重要。特使代理是一种网络代理，攻击面大。

我们使用 fuzzing 识别了三种不同类型的攻击。第一个是死亡的一般查询——一个输入就使代理崩溃。Fuzzing 可以找到这类东西，因为它会崩溃，然后我们可以找到并提取问题。第二类问题与性能有关，可能导致拒绝服务。例如，与时间相关的问题可能会在模糊器中显示为超时。有时，超时输入可能被精心设计成一个漏洞，导致 DoS 攻击或潜在的堆栈溢出，以及不受控制的资源消耗，这可能导致代理消耗大量内存。第三类问题是攻击转变为高严重性的身份验证绕过，这可以通过使用杀毒程序的简单模糊测试运行来识别。

模糊测试发现了普通开发人员永远不会编写单元测试的问题——模糊化可以真正探索评审人员和开发人员的疏忽。

## 如果你不模糊你的代码，别人会的

如果您正在搜索漏洞，Fuzzing 是工具箱中的一个重要工具。在理想的世界中，模糊化应该像编写单元测试一样普遍和简单。再加上 OSS-模糊和集群模糊等工具的易用性，模糊化的价值比表面上看起来要大得多。Fuzzing 在发现稳定性问题和安全漏洞方面都很有用。它在寻找编程语言(如 C 和 C++)中的内存损坏漏洞方面很有效，但它甚至在内存安全语言(如 Go 和 Rust)中也很有用，在这些语言中发现了拒绝服务问题或功能正确性问题。

所以，模糊你的代码，因为如果你不这样做，别人会。

<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 68 31" version="1.1"><title>Group</title> <desc>Created with Sketch.</desc></svg>