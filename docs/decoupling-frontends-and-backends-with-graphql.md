# 用 GraphQL 解耦前端和后端

> 原文：<https://thenewstack.io/decoupling-frontends-and-backends-with-graphql/>

[](https://www.linkedin.com/in/anantjhingran)

[Anant jhin gran](https://www.linkedin.com/in/anantjhingran)

[Anant 是 StepZen 的创始人兼首席执行官，step Zen 是一家初创公司，采用一种新的方法来简化开发人员访问他们需要的数据，以增强数字体验。Anant 的职业生涯跨越了 IBM Fellow、IBM 信息管理部门的 CTO、Apigee 的 CTO 和 Google Cloud 的产品负责人，他的职业生涯一直处于数据库、机器学习和 API 创新的前沿。在 StepZen，Anant 正在享受创建一家公司，将他对这些技术的热爱结合在一起，以简化、加速和扩展前端开发。](https://www.linkedin.com/in/anantjhingran)

[](https://www.linkedin.com/in/anantjhingran)[](https://www.linkedin.com/in/anantjhingran)

前端开发人员需要管理他们正在构建的应用程序的数据。例如，他们可能希望提供客户订单的交付状态。所以他们需要公开这些构造的 API。另一方面，后端系统通常公开反映后端数据形状的 API。例如，它们可能返回给定其 TrackingID 的包的状态。它们只是不同的关注点。一个好的 API 设计必须承认这一点，并且实现必须围绕它进行编码。这种分离的另一个好处是后端可以来来去去——一家公司可能会从使用 FedEx 和 UPS 转向使用 USPS 和 DHL——但前端 API 的调用方式不必改变。客户订单的交付状态仅取决于订单，而不取决于任何特定的发货人。前端开发人员不必编写逻辑来预测每个交付提供者。

听起来很简单，但要做到这一点却很难。在本文中，我们认为使用 GraphQL 作为前端 API 的设计使事情变得更容易。还有一些其他的构造——接口、路由和声明性规范——可以使这种解耦变得更加容易。

在我们进入更多细节之前，我想带你回顾一些历史(尽管是通过我的眼睛看到的！)

## 作者在脱钩方面的经验

在我职业生涯的早期，我在数据库研究和开发方面做了很多工作——首先是在加州大学伯克利分校和我的导师 Mike Stonebraker 教授(以 Ingres 和 Postgres 闻名)一起读研究生，然后是在 IBM 从事 DB2 工作。当时的数据库世界是一个被称为“表”的抽象实体的世界，实现对用户是隐藏的。是的，虽然抽象显然是好的最终用户构造，但是运行数据库的人需要对实现的核心访问——设置索引、规范化和反规范化，以及运行统计数据来影响查询性能。因此，在数据库的世界里，抽象(用户如何与系统交互)和实现(管理员如何与系统交互)并存，为不同的受众服务。这种拥有两个视图的概念可以称为抽象(正如我在本段中所做的)，也可以称为前端和后端的解耦。

我曾在 IBM 做过一段时间的老板 Stuart Feldman (关于“制造”名声)的一次随机讨论开始时，他断言每个人都认为抽象是美丽的——但是如果每个抽象使性能下降 2 倍，那么 10 个抽象叠加在一起会使性能下降 1000 倍。我知道我破坏了他说这句话的深刻方式，但这让我思考:抽象的代价总是性能的下降吗？

接下来，我在 Apigee 深入地接触到了抽象的概念。早期，我们和当时在网飞的积丹尼一起工作。丹写了一些对 T2 有深远影响的关于分层的想法——他称之为资源和体验 API。虽然他没有从抽象的角度来处理它，但是概念是相同的。反映领域/实现的 API 给了 API 用户很大的权力；但另一方面，也许赋予了太多的权力。相比之下，“体验 API”(为开发人员构建特定于设备的功能)提供了适当的灵活性和控制。

同样的概念被称为“前端的后端”，简称 BFF。情人节那天，我的同事 Brian Rinaldi 在 BFF 上写了一篇博客，题为“[学会爱你的 Jamstack BFF](https://stepzen.com/blog/learn-to-love-your-jamstack-bff) ”他的核心主张是，即使在更现代的 API 中——如 graph QL——也必须小心构建正确的抽象。

现在，在 StepZen，当我们发布通过抽象后端问题来帮助开发人员构建 GraphQL APIs 的产品时，我们再次发现自己处于关于 GraphQL 的主导模式是否应该是抽象的对话中。为了充分理解 GraphQL 中抽象(解耦)的力量，我们需要理解 API 和查询语言。

## 蜜蜂

API 已经成为前端开发人员从后端获取数据的事实上的标准。但是要做到这一点，API 必须存在(咄！).这意味着必须有人来编写 API。这通常意味着一些团队必须编写 API，因为编写和维护 API 对于复杂的后端系统来说是一项巨大的任务。这意味着 API 不能频繁更改。

但是一个 API 本身是不够的。返回客户数据的 API 非常有用。但是，如果一个 web 页面显示一个登录客户的所有未完成订单，那么该页面还需要获取产品和交付数据。所以现在，必须有人来写组合逻辑。一个好的架构模式是避免在应用程序中直接编码这些组合，而是将其推送到一个 API 层(这就是我前面提到的 BFF 模式)。现在你有了一个两层的 API 系统——一个以后端/服务为中心的 API 层和一个以体验/前端为中心的 API 层。

到目前为止，一切顺利。但是还有更多考虑。API 通常会“公开”一些人可能需要的所有信息。毕竟，正如我们所讨论的，API 很难改变，所以公开任何人都可能需要的位的联合是值得的。然而，这使得公开的数据片段以“提供者”为中心。前端开发人员需要一个以客户为中心的视图，因为客户是应用程序的消费者。因此，以体验/前端为中心的 API 层还必须将以提供商为中心的数据转换为以客户为中心的数据。

举个例子，假设零售商使用 UPS 作为其运输公司。对 UPS 的 API 调用不仅返回这个片段:

```
...
“status”:  {
  “type”:  “D”,
  “description”:  “Delivered”,
  “code”:  “FS”
},
“date”:  “20210223”,
“time”:  “130030”
…

```

…但也有大量的其他信息，像所有其他事件一样，“在 UPS 工厂处理”、“到达工厂”、“托运人创建了标签，UPS 尚未收到包裹”等等。现实中，开发者需要的是这三个字段:

```
{
  delivered:  // date & time if delivered
  expectedDelivery:  // date when expected
  shipped:  // has the package started its journey?
}

```

最后，如果您将提供商从 UPS 换成 FedEx，会发生什么？你需要更新你所有的手机应用吗？这听起来是个坏主意。前端应该有一个对提供者完全不可知的视图。

到目前为止，我们已经看到:

*   后端 API 很少改变
*   需要进行大量的数据混合和匹配
*   以客户为中心的视图优于以提供商为中心的视图
*   后端可以来来去去

因此，除了后端层之外，前端 API 层几乎总是必须存在的。抽象层必须存在于后端之上。

## 查询语言

正如我在本文的第一部分中所讨论的，查询语言非常棒——尽管吹毛求疵,“这是我想要的，给我，我不在乎你如何得到它”的概念非常强大。最常见的形式当然是 SQL。但是我们身边还有其他一些优秀的例子。

以谷歌搜索为例。它带来了很好的结果，对吗？计算机科学、页面排名算法、机器学习魔法——这些都是针对一个简单的 2-3 个单词的查询。谷歌最重要的创新之一是让用户从精确提问(“Anant 在 Jhingran 的三个单词之内，标题包含 StepZen”)转向指定像“Anant Jhingran StepZen”这样简单的事情，并期望谷歌做正确的事情。

在这两种情况下，查询语言都很好地抓住了抽象的概念。它的一端(面向用户的一端)用一种用户容易理解的语言进行交流。另一端(实现端)用后端语言(表格、网站、搜索索引等等)进行通信。

## GraphQL

GraphQL 结合了 API 和查询语言的精华。它是一个 API，因为一个简单的 POST 返回请求的数据。它是一种查询语言，因为用户可以询问她想要的内容(只要在 GraphQL API 端点的定义中允许)。

GraphQL 有三个不同的概念:

1.  类型(如客户、订单等。)与用户(前端开发人员)进行交互。这些类型在一个图中链接在一起—例如，一个客户可能有订单—因此命名为 GraphQL。它有一个额外的抽象，一个接口，可以用来进一步隐藏类型。当有多个不同的实现时，这尤其有用。
2.  查询，如 customerById(查询只是图形的入口点)返回一种类型的数据。
3.  解析器，描述查询的实现和与类型相关的数据位的生成。例如，可能有一个解析器说查询 customerById 可以通过对 MySQL 数据库发出 SQL 语句来执行，而查询 orderByCustomer 需要对 REST 端点执行 GET。

类型(或接口)和解析器的分离(查询在它们之间起中介作用，通过解析器执行并返回符合类型的数据)为 GraphQL 提供了一个很好的机会来进行正确的解耦或抽象。事实上，有了接口，您可以获得两全其美的额外优势——在需要时保持抽象，在抽象不够时深入细节。举个例子:

```
interface  WeatherReport  {
  min:  Float!
  max:  Float!
}
type  AccuWeather  implements  WeatherReport  {
  min:  Float!
  max:  Float!
  description:  String
}
type  OpenWeatherMap  implements  WeatherReport  {
  min:  Float!
  max:  Float!
}
The developer can issue  a  query:
query weather  (date:  “2021-02-25”,  latitude:  37,  longitude:  -121.7)  {
  min
  max
  ...  on  AccuWeather  {
  description
  }
}

```

这段代码表示，如果查询天气碰巧从 AccuWeather 返回，那么也返回描述，否则只返回接口值。

但是仅仅因为机会存在并不意味着它被默认打开。想象一个后端 MySQL 数据库。在一个简单的层次上，它可以有一个名为“legacy_101”的客户表、一个名为“purchase_list”的订单表、一个产品表(“gid_index”)和一个可以将订单连接到产品的链接表(purch_x_gids)。这些表中的列名可以像“cust_id”、“yrs_since_mat”或其他什么一样没有意义。默认的 GraphQL 实现将为每个表创建一个类型，并查询所有列或其上有索引的列的子集。你会得到对一个前端开发人员来说毫无意义的官样文章。不要让我从更非结构化的数据源开始，比如 NoSQL 或内容管理系统。叹气。

但是一个人可以利用这个机会。您可以选择以下两种方式之一:

*   首先是应用程序需要看到的类型和接口，以及应用程序可以进行的查询。然后编写解析器将类型和查询映射到正确的后端数据。挑战在于解析器现在可能变得低效——每个查询都需要一个三方连接？呃。
*   您从后端的自省开始——这是它们拥有的，这是默认类型和可以从中生成的查询系统。然后你削减、修改和映射，直到你得到一个对前端开发人员有意义的类型和查询系统。挑战在于，如果你有一个新的后端，这个过程就会中断；但是当你只有一个的时候，这可以很好的工作。

我称之为[隧道战略](https://www.mentalfloss.com/article/63450/10-fascinating-facts-about-chunnel)。一端(比如北方)是前端开发者的视角。另一端(比如南方)是后端。你从两边挖，一边挖一边调整，直到你拥有了两个世界的精华——在中间相遇！

好的 GraphQL 端点(以及用来创建它们的系统)必须平衡抽象和实现。这种语言非常强大，允许这样做，并且很容易做到。但是构建 GraphQL API 的开发人员必须认识到这一点，并有意识地努力做正确的事情。最终，推动平衡的系统和工具将成为构建和使用 GraphQL APIs 的开发人员的最佳工具。前端和后端应该(也可以)分离，但这不是免费的。

我喜欢抽象。GraphQL 具有非凡的能力——包括允许前端开发人员使用他们的概念进行交互，以及允许 GraphQL 层与后端实现进行协调。当然，仅仅因为该模式容易实现并不意味着您应该选择这样做，或者您用来实现 GraphQL 的系统使得它容易实现。在 StepZen，我们相信这些抽象对于开发人员来说是强大的，我们的目标是让您能够非常容易地构建它们。

<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 68 31" version="1.1"><title>Group</title> <desc>Created with Sketch.</desc></svg>