<html>
<head>
<title>VMware’s Kit Colbert: Is the Cost of Migrating to Containers Really Worth the Effort?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">VMware的Kit Colbert:迁移到容器的成本真的值得付出吗？</h1>
<blockquote>原文：<a href="https://thenewstack.io/vmwares-kit-colbert-cost-migrating-containers-really-worthwhile/#0001-01-01">https://thenewstack.io/vmwares-kit-colbert-cost-migrating-containers-really-worthwhile/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">


<p class="translated">VMware将工作负载可移植性作为其业务的基础。但是在过去的几年中,“工作量”的概念已经有所改进。虚拟机中表现得像机器一样的部分引入了太多的开销。没有它，工作负载可能更容易维护——假设我们让我们的容器技术同意在同一页面上一起工作。</p>
<p class="translated">VMware对加速实现这种未来状态有什么兴趣？在前十年，当微软面临世界日常计算任务向更小、更多功能的平台转移的现实时，它的回应是努力让智能手机工作起来，看起来像个人电脑。消费者两次明确无误地拒绝了它的努力。正如今年所展示的那样，VMware的战略带有微软以前的“拥抱和扩展”哲学的一些特征:欢迎容器化，但铺平了集成的道路，表明新旧可以而且必须共存。</p>
<p class="translated">作为虚拟化领域的市场领导者，VMware确实拥有决定该市场变革速度的资源和营销技能。现在，在新的母公司戴尔技术的支持下，该公司更容易地展示了其改变游戏的能力——正如上周其收购SDN平台制造商PLUMgrid的意图所示。但是，VMware能够决定其企业客户(Docker、Kubernetes、Mesosphere和容器化领域的其他公司尚未进入的市场)采用容器化、自动化部署和持续集成的条款和时间表吗？</p>
<p class="translated">在最近与VMware首席技术官就云原生应用<a href="https://twitter.com/kitcolbert?lang=en" class="ext-link" rel="external "> Kit Colbert </a>进行的一次广泛采访中，我们回避了这个问题。然后，当时机成熟时，我们就投入其中。</p>
<h2 class="translated">耶稣诞生场景</h2>
<p class="translated">我们从郊区开始，问Colbert他是否认为无服务器架构的理想体现了云原生应用程序的真实定义。</p>
<p class="translated">“当我想到一个云原生应用时，它的范围比这要广一点，”科尔伯特回应道。“部分原因在于消费模式。容器是其中的一部分；无服务器可以是其中的一部分。一部分是应用程序本身的架构，我们看到许多分布式的微服务架构。</p>
<blockquote><p class="translated">“如今，容器的最初用例是无状态工作负载。容器内的状态管理正在变得越来越好，但肯定还没有达到我认为很多人会感到舒适的成熟水平。”——基特·科尔伯特。</p></blockquote>
<p class="translated">“但我认为第三个是如何构建应用程序的概念，即持续集成和持续部署的概念。我认为，对我来说，这三点就是“云原生”的定义"</p>
<p class="translated">科尔伯特承认，在定义云原生空间时，消费模型和创造模型是分开的。他认为，虚拟机(第一代虚拟机管理程序驱动的虚拟机，由VMware支持)极大地简化了这些消费模式。他接着说，容器进一步简化了这些模型的某些方面，包括收紧典型的软件开发生命周期(SDL)，尽管他没有把类似的成就归功于容器和虚拟机。</p>
<p class="translated">【T2<img decoding="async" loading="lazy" class="aligncenter size-full wp-image-1715230" src="../Images/468cd1eeed9cdccfccb0f38c2e64e203.png" alt="160830-kit-colbert-03-day-2-keynotes" data-original-src="https://thenewstack.io/wp-content/uploads/2016/12/24cef5e1-160830-kit-colbert-03-day-2-keynotes.jpg"/></p>
<p class="translated">“无服务器是下一个合乎逻辑的步骤，”CTO继续说道。“说，‘你知道吗，我不想处理应用程序之外的任何二进制文件和组件。我真的只是想把我的应用程序设置成一个函数。”然后他承认，无服务器的理想可以继续将应用程序分解成独立的功能，开发者可以将这些功能组合成内聚的框架。</p>
<p class="translated">如果VMware本质上是一家基础架构公司，那么值得注意的是，其首席架构师之一已经承认，其核心产品属于其客户越来越不关心的组件类别。如果无服务器的理想成功了，那么基础设施就成功地隐藏在命令行的幕后。</p>
<p class="translated">在你认为VMware处于如此进退两难的独特境地之前，请认识到Docker Inc .和CoreOS面临着完全相同的问题。</p>
<p class="translated">然而，科尔伯特并没有把无服务器体系结构建立为容器化的具体产物。他有这个机会，尽管他认为无服务器性和虚拟机之间存在联系。因此，我们进一步探讨了这个问题:他认为有没有哪一类工作负载更适合在容器中运行，而不是在虚拟机中运行？换句话说，有没有哪一类工作负载在容器化后会变得更糟？</p>
<h2 class="translated">成熟度模型</h2>
<p class="translated">“今天容器的最初用例是无状态工作负载，”他回答道。“在容器中管理状态正在变得越来越好，但它肯定没有达到我认为很多人会感到舒适的成熟水平，在生产中运行这些东西。”</p>
<p class="translated">Colbert认为，有状态的、数据库驱动的工作负载在很大程度上仍然属于虚拟机。但他说，以容器为中心的存储管理系统的到来将改变这种情况，有状态工作负载将与无状态工作负载一起加入容器迁移。</p>
<p class="translated">“当然，从长远来看，我很难想象无法在容器内工作的工作负载，”他告诉新堆栈。“不过，我认为您将开始看到的是，不仅需要了解工作负载如何在容器内运行，还需要了解它如何利用底层硬件。”</p>
<p class="translated">这就是Colbert案例转向虚拟机管理程序将工作负载与托管它们的硬件安全链接的能力的地方。他将“硬件”的定义扩大到处理器和存储之外，包括越来越多的<a href="http://www.datacenterknowledge.com/archives/2016/11/17/intel-sets-fpga-goal-2-orders-magnitude-faster-gpgpu-2020/" class="ext-link" rel="external "> FPGA加速器</a>和<a href="http://www.datacenterknowledge.com/archives/2016/11/17/gpu-acceleration-makes-kineticas-brute-force-database-brute/" class="ext-link" rel="external "> GPU加速器</a>——承担许多常见、重复功能的辅助处理器，否则这些功能会对CPU造成压力。正如他解释的那样，开发人员今天面临的挑战是如何最好地操作这些更具确定性的工作负载。</p>
<p class="translated">更多的是由于环境而不是设计，基于虚拟机的应用程序今天可能确实在促进硬件加速应用程序所需的库方面具有优势——对于GPU来说，<a href="https://developer.nvidia.com/gpu-accelerated-libraries" class="ext-link" rel="external ">根据Nvidia的统计</a>这是一个令人印象深刻的数字。</p>
<p class="translated">但科尔伯特承认，这种情况是暂时的。“如果我想象的时间足够长，我看不出有任何理由不做集装箱，”他承认。</p>
<p class="translated">“那是假设你从一片绿地、一张白纸开始，你可以朝一个方向或另一个方向前进。但是有很多这样的现有应用程序，它们已经内置在虚拟机中，也许容器可以赶上并拥有所有这些强大的功能。但是还有一个次要问题:将应用程序迁移到容器的成本值得吗？”</p>
<p class="translated">Colbert没有说明基于VM的应用程序在设计上不一定是云本地的。然而，他的推理确实暗示，在云平台之前开发的旧应用程序，或者没有遵从云平台的旧应用程序，不一定会从迁移到基于容器的系统中受益，其受益程度大于执行迁移的实际成本。</p>
<p class="translated">相反，Colbert认为，由于云平台本质上是受虚拟机管理程序支持的，因此假设云原生应用程序必须是容器驱动的是错误的。正如许多机构继续在大型机平台上运行30年或更老的应用程序一样，他表示，企业将继续对每一次潜在的迁移进行成本/收益分析，并可能得出一些业务流程太脆弱而无法移动的结论，这是“企业it的现实”。</p>
<p class="translated">“我不教条的方式或其他方式；我真的希望顾客做对他们最有利的事情，”他说。“我们VMware的目标是在这一过程中为他们提供支持。”他说，有了他的公司的<a href="https://www.vmware.com/products/vsphere/integrated-containers.html" class="ext-link" rel="external ">VSP here Integrated Containers</a>平台，认为完全迁移是不可能的那类客户仍然可以获得他所说的“80/20优势”:“可能会改善他们的软件开发生命周期，简化一些开发/测试环境，同时仍然可以获得虚拟机的运营优势。”</p>
<p class="translated">这一论点表明，首席技术官认为VMware将有能力减缓体系结构变化的步伐，至少在其核心客户群中是如此:减缓体系结构的变化，并维持在特殊条件下必须维持的脆弱工作负载。</p>
<p class="translated">“我是一名技术专家，我喜欢酷的新技术，”他告诉我们。“但你也必须务实。”</p>
<h2 class="translated">种群控制</h2>
<p class="translated">我们问了Kit Colbert一个典型的年终问题:从现在起12个月的这个时候，他希望讨论的“it现实”是什么，而今天却没有讨论这么多？</p>
<p class="translated">“这是我认为历史会重演的事情之一，”他回答道。“如果你看看虚拟化发生了什么，当虚拟机占据主导地位。。。你遇到了<a href="http://readwrite.com/2011/11/01/roadblock-to-virtualization-vi/" class="ext-link" rel="external ">这个“虚拟机蔓延”的问题</a>当人们太容易创建它们时，他们会创建一堆，而人们并没有真正跟踪它们。</p>
<p class="translated">“我想知道类似的事情是否会发生在集装箱上。现在，人们正在创造它们，这很棒。但我想知道人们是否会开始关注“集装箱泛滥”的问题。到处都是容器，人们疯狂地创造它们，它们到处都是。你并不真正知道是谁创造了它们，或者是在哪里创造的。我觉得下一个成熟阶段将会到来，讨论将会开始。你到底是怎么做到的？你如何实现容器所能提供的速度，同时又有一些控制的概念？"</p>
<p class="translated">这种预测可能来自一个仍然认为集装箱化是客户害怕而不是拥抱的趋势的组织。</p>
<p class="attribution translated">CoreOS和Docker是新堆栈的赞助商。</p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
<title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>

</div>
</div>    
</body>
</html>