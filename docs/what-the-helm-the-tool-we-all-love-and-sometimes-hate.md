# 什么舵？！我们都喜欢(有时也讨厌)的工具

> 原文：<https://thenewstack.io/what-the-helm-the-tool-we-all-love-and-sometimes-hate/>

*这是 10 月 24-28 日 KubeCon + CloudNativeCon 系列文章的一部分。*

[Helm](https://helm.sh/) 是一个项目，在过去几年中获得了令人难以置信的采用，并已成为在 Kubernetes 中安装、配置、打包和管理应用程序的事实上的工具之一，特别是在大规模情况下，必须对集群进行更多控制。

然而，广泛的采用和使用往往伴随着恶名。不管你喜欢它还是讨厌它，大多数人对 Helm 都有一些坚定的看法，在这篇文章中，我们将从各个角度来探讨它:好的，好的和坏的。我们会让你决定。这篇文章将帮助你决定这是否是你想要使用的工具，如果你已经在使用它，我们将提供帮助你优化体验的方法。

但在我们进入之前，赫尔姆的历史值得一说。这一切都始于 Deis 的内部黑客马拉松，是为他们内部使用 Kubernetes 集群而创建的。一旦它变得成熟，他们决定开源这个项目，并将其贡献给云本地计算基金会(CNCF)。

几年后，在以一个成熟项目应有的用户和贡献者的形式获得了很大的知名度后，Helm 正式从孵化阶段毕业成为 CNCF 主持的项目，甚至被认为是今天 Kubernetes 堆栈不可或缺的一部分。

Helm 肯定有它的优点和缺点，有些是可以原谅的，有些会产生很多令人挠头的时刻。无论是开始使用 Helm，还是对其进行长期管理并驾驭其复杂的操作，都是如此。让我们解释一下为什么会发生这种情况，以及在开始之前和结束之后应该知道什么。

## 为什么，什么，怎么做？

Helm 因为在 Kubernetes 生态系统中扮演的角色而迅速被采用。当把 Kubernetes 看作一个项目时，毫无疑问，它的优势在于部署对象和编排容器。今天的应用程序不再是从前的那种铁板一块。相反，它们由许多模块化服务组成，几乎就像积木一样，这是一个游乐场，Kubernetes 使其非常容易创建。换句话说，可能性是无限的。

这对于单个应用程序来说很有趣，但是一旦你需要对许多应用程序都这样做，管理和维护就变得越来越困难。在 Helm 诞生之前，你需要创建巨大的单个文件，并将它们部署到 K8s 或整个目录之上的 do `kubectl apply`，这是极其混乱的。

Helm 就是在这样的环境中被构思和创造出来的，下面这段话准确地表达了该团队想要实现的目标:

“‘五分钟内从零到多巴胺’这是我们的掌舵咒语:我们看到了让 Kubernetes 对新来者更加平易近人的机会。如果我们做得对，用户可以安装 Helm，然后在几分钟内安装生产级的现成组件。"
(来自[庆祝赫尔姆 CNCF 毕业](https://helm.sh/blog/celebrating-helms-cncf-graduation/))

Helm 的成功基本上深化了 Kubernetes 的整体使用。它彻底改变了应用程序在 Kubernetes 中的部署和运行方式。通过创建一个开放的贡献模型，并允许供应商和开发人员创建他们自己的经过认证和维护的图表，然后分发给社区，部署甚至复杂的应用程序成为可能。像 Grafana，Elastic 和 Redis 这样的平台，都是在几分钟内用一个掌舵图建立起来的，根本不需要真正了解 Grafana 或 Kubernetes。

这更好地改变了行业和 Kubernetes 的采用，使开发人员无需具备深入的先决知识就能构建许多工具。

然而，这种简单性是一把双刃剑，因为部署总是容易的部分。你经常会发现维护是最难的部分。因为 Helm 使得在 Kubernetes 上部署应用程序变得“容易”,而且抽象层是如此的无缝，用户没有意识到后果。这就是为什么当事情开始变得混乱和失败时，就像这些点击式的简单部署通常会发生的那样，许多用户突然清楚地意识到，他们对集群内部发生的事情缺乏了解，无法正确地解决具体问题。

## 你赢得一些，你失去一些

毫无疑问，Helm 改变了 Kubernetes 的消费方式，使其成为当今运行微服务的关键部分。然而，它也不是没有挑战。

Helm 入门的一个主要问题是它的复杂性(作为 Kubernetes 生态系统中的一个产品，我们对此并不期待)。它本质上“隐藏”了它就像三个产品融合成一个工具。作为一名 Kubernetes 的高级用户，我花了大约一个月的时间才弄明白 Helm 实际上是做什么的，以及如何使用它。

这是因为，作为一个工具，类似于 Kustomize，它被认为是 Helm 最大的竞争对手，你希望它专注于一个单一的用例，并做得很好。例如，Kustomize 专注于提供真正伟大的 YAML 模板和注射。另一方面，赫尔姆在这方面是个专家。

在一个单一的工具中，它试图涵盖打包工件(如 Kubernetes 的 PyPI、Maven 或 NPM)，一种模板语言(他们在 Go 之上的专有模板语言)。这增加了它自身的复杂性，但我们会谈到这一点)，以及应用程序的实际部署和生产生命周期管理。底线:这是一个很大的处理。

由于找不到更好的词，模板语言可能给体验增加了最多的陌生感。它完全不属于 Kubernetes 生态系统，添加`if`和`else`命令来管理您的 YAML 文件是一种非常尴尬的模板化体验。

正如他们所说的，万事通，无所不能，虽然我不会对赫尔姆的情况如此苛刻，因为它肯定有许多事情做得很好。然而，这也适用于它的相当一部分功能，这些功能可能完全令人困惑和复杂，甚至在最坏的情况下也是平庸的。然而，对于 Kubernetes 来说，真的没有其他工具可以解决 Helm 的复杂程度。

有人会说，除了`helm install`或`helm upgrade`之外，任何时候你做任何事情都是在赌它会如何影响你的集群，比如回滚。即使可以在一个命令中完成数百种不同资源的 Helm 升级，也没有简单的方法知道您将更改什么，以及一旦部署后它将如何破坏您的系统。(头盔里没有`Terraform plan`、`Terraform apply`对等物。)

一个很好的例子是，如果我们回到社区贡献的图表，如果您选择部署 Redis 及其认证和维护的 Helm 图表，您可以在几分钟内实现 Redis 的启动和运行。除非发生故障，否则工程师们会突然意识到，有 40 种不同的服务在自动运行，他们不太理解，也不知道如何排除故障。这会变得很难看。这就是为什么专业运营人员越来越清楚`helm install`只是第一步；困难的部分是知道如何维护部署到集群的所有服务。

## 如何带领 Helm 更上一层楼

以上关于 Helm 的一切都是在爱中说的，当然不是恨。这确实是每个人都喜欢使用的工具。最终，像所有的头盔用户一样，我认为一个理想的世界将使我们所有人不再需要交叉手指，因为害怕点击`Helm upgrade`会在我们的集群中发生什么而向头盔神牺牲我们的孩子。

毫无疑问，在使用 Helm 时，对 Kubernetes 集群内部发生的事情有更好的观察和理解，甚至是强大的回滚功能和故障管理，将是一个良好的开端。

另一个需要改进的领域是将 Helm 错误代码(众所周知的深奥，有时甚至违反直觉)转化为常见问题。如果 Helm 出现故障，要了解其根本原因几乎是不可能的。

因此，优化 Helm 体验的一些良好实践可能包括拥有一个基础图表，该图表将作为组织中所有使用 Helm 的团队将代码部署到生产中的标准化方式。通过这种方式，基础图表将总是在每次更新时注入最新的值，以便基础图表的所有用户(定期更新他们的版本)将在下次部署时受益于您的最新版本更新。

另一个好的选择是在生态系统中使用其他维护良好的工具，比如 ArgoCD。虽然它也有自己的学习曲线，但它确实提供了对 Kubernetes 集群更好的可见性和控制的好处。

最后，另一个有用的解决方案是尝试开源项目， [Helm dashboard](https://github.com/komodorio/helm-dashboard) ，这将增强和优化 Helm 体验，并使其更易于不太老练的用户使用。有了这个 OSS 控制面板，您几乎可以在一个简单直观的控制面板中获得 CLI 的所有功能——部署到生产环境之前的失败原因、验证和检查，以及新版本何时可用和安全的升级(和回滚)路径——因此您可以安全地管理您的舵图的生命周期。

借助这些最佳实践或生态系统 OSS 工具，您可以在大规模使用 Helm 时获得更好的可管理性和可理解性。

*要了解更多关于云原生的话题，请参加 10 月 24 日至 28 日在底特律举行的 KubeCon + CloudNativeCon 北美 2022(和虚拟)上的云原生计算基金会和云原生社区。*
![](img/25bc05722c52e80806074bddd7e413fd.png)

<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 68 31" version="1.1"><title>Group</title> <desc>Created with Sketch.</desc></svg>