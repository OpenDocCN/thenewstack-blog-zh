<html>
<head>
<title>How Docker Containers Helps SQL Server 2017 Shift Deployment to the Developer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker容器如何帮助SQL Server 2017将部署转移到开发人员</h1>
<blockquote>原文：<a href="https://thenewstack.io/sql-server-linux-will-fit-devops-flow/#0001-01-01">https://thenewstack.io/sql-server-linux-will-fit-devops-flow/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">


<p class="translated">有了<a href="https://www.microsoft.com/en-us/sql-server/sql-server-2017" class="ext-link" rel="external "> SQL Server 2017 </a>，微软不仅仅是想把自己重量级的RDBMS带到Linux上；它想让开发者更容易访问它，这样它就可以通过容器利用DevOps和持续集成的趋势。</p>
<p class="translated">这是SQL Server过去不具备的功能；SQL程序经理<a href="https://twitter.com/tonypetrossian" class="ext-link" rel="external ">托尼·彼得罗相</a>告诉新的堆栈，不仅仅是因为它运行在Windows Server上，还因为它的部署和管理方式与开发人员使用的其他组件如此不同。</p>
<p class="translated">“一段时间以来，人们一直在使用CI/CD和DevOps来构建数据库应用程序，但SQL Server本身从未作为应用程序的一个组件参与到该生态系统中，因为SQL Server始终是在其他地方管理的服务器。作为一名开发人员，你得到的是一个连接到IT世界某处数据库的连接字符串；数据库二进制文件本身总是与应用程序开发过程无关。”</p>
<p class="translated">将SQL Server迁移到容器中不仅仅意味着更快的部署；这意味着您可以将它作为开发的一部分而不是操作的一部分来部署，并像测试任何其他代码一样测试您的数据库代码。您甚至可以将经过清理的数据子集放入devtest的容器中，并让管道在安全的环境中使用完整的数据集自动测试代码。</p>
<p class="translated">Petrossian解释说:“我们真正想做的是允许开发人员将SQL Server的实际二进制文件作为他们的CI/CD或他们使用的任何其他开发流程中的应用程序组件，与他们作为应用程序一部分的任何其他库没有什么不同。“因此，通过开发人员对应用程序进行的所有更改，应用程序和数据库同时接受测试，所有自动化测试包括数据库本身。”</p>
<p class="translated">这阻止了开发人员使用SQL Server新版本中的功能，这些功能不受为企业软件较慢版本设计的操作和IT流程的限制。“最终，我们希望这将简化升级，因为如果开发人员因为SQL Server具有特定功能而决定使用新版本的SQL Server，那么他们只需将其引入并更改他们的应用程序即可使用该功能。然后，他们的所有自动化和测试开始生效，他们验证数据库的新版本以及他们的应用程序，而不是开发人员编写新代码，并要求IT部门在某个地方升级某个服务器，这可能需要一些时间，或者根本不会发生。”</p>
<p class="translated">“距离总是很麻烦，能够在一个地方完成所有这些将简化每个人的过程，”他建议道。即使是帮助制造这一鸿沟的IT团队也对结果不满意，因为开发人员倾向于绕过它们。</p>
<p class="translated">“客户告诉我们的是‘如果我不能升级，我不能让开发人员做他们需要做的事情，他们就从网上拿一些其他产品扔进去，假装它只是他们应用程序中的一个库，现在我们必须支持这个其他东西’。他们想让我们把SQL Server放在那里，就像选择开发人员可能选择包含在他们的应用程序中的任何开源库一样简单。”</p>
<p class="translated">SQL Server容器化还改善了在不同平台上工作的开发人员的协作体验。“因为它运行在Docker容器中，你可以在它上面运行任何版本的Linux，任何发行版，”他指出。“如果我正在使用Ubuntu，而我的应用程序最终在Red Hat上运行，或者我将我的应用程序传递给我的同事以添加一些东西，而他们使用的是不同版本的Ubuntu，这都没有关系，因为它都是独立的。所有依赖项都是内置的，包括SQL Server的版本。让开发环境中的确切环境与您的转移路径和生产相匹配不再那么重要。”</p>
<p class="translated">当开发完成后，部署不再是一个不同的过程。"您只需发布生产版本，这些容器的生产版本就可以部署到生产中."</p>
<p class="translated">SQL Server团队中开发工具的开发人员发现，这提高了他们自己的工作效率，并以熟悉DevOps的人所熟悉的方式改变了他们的工作流程。Petrossian解释说:“他们不是让其他开发人员去找他们必须要安装的东西，而是说‘去找这个容器，里面有SQL Server的特定版本和完成工作所需的工具版本’。</p>
<p class="translated">“几乎没有人再安装任何东西了；他们倾向于保持机器的清洁和纯净。旋转一个容器，完成你的工作，然后扔掉它，比污染你的机器，在上面安装你可能永远也不能删除的东西要容易得多。这是另一种简化，现在SQL Server是其中的一部分。”</p>
<p class="translated">他特别指出，这给了开发者更多的开发环境选择。</p>
<p class="translated">“在SQL团队中，我们有一群喜欢在MAC上运行的人——使用跨平台工具的人倾向于在MAC上运行——还有一些人已经在Windows上运行了很长时间。这种容器化的环境意味着您可以让SQL Server以任何一种方式运行，并且现在传递东西很容易。即使在Windows中，您也可以在容器中运行Linux映像，因此，使用运行在不同平台上的相同版本来维护统一的代码库变得越来越容易。我们一直非常关注Windows和Linux之间的完全兼容性，因此客户可以随时在Windows和Linux之间移动数据库。您基本上复制文件，挂载它们，然后SQL Server就启动了。这不是一个迁移或端口或任何东西；这就像把一个数据库从机器A移到机器B，他们只是有不同的操作系统。现在Windows中有了所有的Linux工具，复制东西真的很容易。”</p>
<p class="translated">Petrossian说，如果所有这些听起来就像DevOps通常的优势，那么它就是。“这非常符合其他人在构建应用程序时所做的事情，但在这种情况下，它会包含一个数据库。”</p>
<p class="translated">来自<a href="https://www.microsoft.com/en-us/sql-server/sql-server-2017" class="ext-link" rel="external ">微软</a>的特征图片。</p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
 <title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>
</div>
</div>    
</body>
</html>