# 分布式系统很难

> 原文：<https://thenewstack.io/distributed-systems-hard/>

*本文摘自她即将出版的新书《云原生态度》，该书将于 2017 年 10 月在 [Container Solutions](http://container-solutions.com) 出版。*

 [安妮·柯里

安妮·柯里已经在科技行业工作了 20 多年。上个世纪，她开发了后端服务器产品。2000 年代，她从事早期电子商务平台的工作。在 20 世纪 10 年代，她专注于前沿操作技术以及企业使用它的原因。](https://twitter.com/anne_e_currie) 

如今，我花了很多时间赞美一个[云原生](https://thenewstack.io/category/cloud-native/)(容器化和微服务化)架构。然而，大多数公司仍然运行独石。为什么？这不是因为我们非常不流行，而是因为分发真的很难。尽管如此，这仍然是获得超大规模、真正有弹性和快速响应系统的唯一途径，所以我们必须解决这个问题。

在本帖中，我们将看看分布式系统会如何绊倒你，以及人们处理这些障碍的一些方法。

忘记康威定律吧，大规模的分布式系统遵循墨菲定律:“任何可能出错的东西都会出错。”

在规模上，统计数字不是你的朋友。任何东西的实例越多，其中一个或多个破裂的可能性就越大。可能是同时。

服务会在收到你的信息之前，在处理你的信息时，或者在处理完信息之后，但在通知你之前就失效。网络将丢失数据包，磁盘将出现故障，虚拟机将意外终止。

当我们已经分布我们的系统的时候，有些事情一个整体架构保证不再是真实的。组件(现在是服务)不再以可预测的顺序一起启动和停止。服务可能会意外重启，从而改变其状态或版本。结果是没有一个服务可以对另一个服务做出假设——系统不能依赖一对一的通信。

许多传统的故障恢复机制可能会使分布式环境中的情况变得更糟。强力重试可能会淹没您的网络，并且从备份中恢复并不简单。有一些设计模式可以解决所有这些问题，但是它们需要思考和测试。

如果没有错误，分布式系统将非常容易。这可能会让乐观主义者产生一种虚假的安全感。分布式系统必须被设计成具有弹性，接受所有可能的错误都是正常的。

## 我们现在面临的是沟通的失败

在不可靠(即分布式)系统中，传统上有两种高级应用程序消息传递方法:

*   可靠但缓慢:保存每条消息的副本，直到你确认链中的下一个过程已经完全负责它。
*   不可靠但快速:向潜在的多个收件人发送多个消息副本，并允许消息丢失和重复。

我们在这里讨论的可靠和不可靠的应用层通信与网络可靠性是不同的(例如 TCP 与 UDP)。想象两个无状态的服务直接通过 TCP 互相发送消息。尽管 TCP 是一种可靠的网络协议，但这对于应用程序级的通信来说并不可靠。任何一个服务都可能失败并丢失它正在处理的消息，因为无状态服务不能安全地保存它们正在处理的数据。

我们可以通过在每个服务之间放置有状态队列来保存每个消息，直到它被完全处理，从而使这个设置在应用程序级别上可靠。这样做的缺点是速度会慢一些，但我们可能会很乐意接受，因为如果它让生活变得更简单，特别是如果我们使用托管的有状态队列服务，那么我们就不必担心它的规模和弹性。

可靠的方法是可预测的，但是涉及延迟(等待时间)和复杂性:大量的确认消息和弹性地保存数据(有状态性)，直到您从链中的下一个服务那里得到他们已经对其负责的签字。

可靠的方法不能保证快速传递，但它可以保证所有消息最终都会被传递，至少传递一次。在每封邮件都很重要并且不能容忍任何损失的环境中(例如信用卡交易)，这是一个好方法。AWS 简单队列服务(Amazon 的托管队列服务)是可以可靠使用的有状态服务[的一个例子。](https://ndolgov.blogspot.co.uk/2016/03/aws-sqs-for-reactive-services.html)

第二种不可靠的方法是更快的端到端方法，但这意味着服务通常必须预料到重复和无序的消息，并且一些消息会丢失。当消息对时间敏感时(即，如果不迅速对其采取行动，则不值得对其采取行动)，或者稍后的数据会覆盖较早的数据时，可能会使用不可靠的通信。对于非常大规模的分布式系统，可能会使用不可靠的消息传递，因为它以更少的开销快得多。然而，[微服务](https://thenewstack.io/category/microservices/)必须被设计来应对消息丢失和复制。

在每种方法中，都有许多变体(例如，有保证的和无保证的顺序)，所有这些变体在速度、复杂性和故障率方面都有不同的折衷。

一些系统可能使用多种方法，这取决于正在传输的消息的类型，甚至取决于系统上的当前负载。如果你有许多行为不同的服务，这种事情就很难做好。服务的行为需要在其 API 中明确定义。为系统中的服务定义约束或推荐的通信行为以获得某种程度的一致性通常是有意义的。

## 现在几点了？

在分布式系统中，没有通用时间、全球时钟这样的东西。例如，在群聊中，我的评论和我在澳大利亚、哥伦比亚和日本的朋友发来的评论出现的顺序通常没有保证。甚至不能保证我们看到的都是相同的时间线——尽管如果我们坐得足够久而没有说任何新东西，一个订单通常会胜出。

从根本上说，在分布式系统中，每台机器都有自己的时钟，整个系统没有一个正确的时间。机器时钟可能会获得同步负载，但即使这样，同步消息的传输时间也会变化，并且物理时钟以不同的速率运行，因此一切都会立即再次失去同步。

在一台机器上，一个时钟可以为所有线程和进程提供公共时间。在分布式系统中，这在物理上是不可能的。

在我们的新世界里，时钟时间不再为秩序提供一个无可争议的定义。“现在几点了？”在微服务世界中不存在，设计不应该依赖它来获取服务间消息。

## 真相就在那里？

在分布式系统中，没有全局共享内存，因此没有单一版本的真相。数据将分散在物理机器上。此外，任何给定的数据片段都更有可能在相对较慢且不可访问的机器之间传输，而不是在一个整体中传输。因此，决策需要基于当前的本地信息。

这意味着在系统的不同部分，答案不会总是一致的。理论上，随着信息在整个系统中传播，它们最终应该变得一致，但如果数据不断变化，我们可能永远无法达到完全一致的状态，除非关闭所有新的输入并等待。因此，服务必须处理这样一个事实，即他们可能得到“旧的”或不一致的信息来响应他们的问题。

## 快说！

在单片应用程序中，最重要的通信发生在一个组件和另一个组件之间的单个进程中。流程内部的通信非常快，因此传递大量内部消息不成问题。然而，一旦你将你的整体组件分割成单独的服务，通常运行在不同的机器上，事情就变得更加棘手了。

给你一些背景:

这在分布式环境中的结果是:

*   你应该少发信息。您可能会选择在分布式微服务之间发送比在一个整体中的组件之间发送更少更大的消息，因为每个消息都会引入延迟(也称为等待时间)。
*   考虑更有效地发送邮件。对于您发送的内容，您可以通过使用 RPC 而不是 REST 来传输消息，从而帮助您的系统运行得更快。或者甚至直接使用 UDP 来处理不可靠性。

## 状态报告？

如果您的系统可以以亚秒级的速度变化，这是动态管理的分布式架构的目标，那么您需要意识到这种速度下的问题。许多传统的测井工具没有被设计成响应性地跟踪。你需要确保你使用的是。

## 破坏性测试

要知道您的分布式系统是否工作以及是否会从不可预测的错误中恢复，唯一的方法是不断地设计那些错误并不断地修复您的系统。网飞使用混沌猴子随机拉动电缆和崩溃实例。这需要测试您的系统的弹性和完整性，同样重要的是，测试您的日志记录，以确保如果出现错误，您可以追溯性地诊断并修复它——即在您的系统恢复在线后。

## 这一切听起来很难。我一定要吗？

创建一个分布式的、可伸缩的、有弹性的系统是很困难的，尤其是对于有状态的服务。现在是决定你是需要它还是立即需要它的时候了。您的客户能暂时忍受较慢的响应或较低的规模吗？这将使你的生活变得更容易，因为你可以先设计一个更小、更慢、更简单的系统，随着你积累专业知识，只会增加更多的复杂性。

像 AWS、Google 和 Azure 这样的云提供商也在开发和发布产品，可以为你做越来越多的硬东西，特别是弹性状态(托管队列和数据库)。这些服务看起来很昂贵，但是构建和维护复杂的分布式服务也很昂贵。

任何约束你但处理任何复杂性的框架(像 Linkerd 或 Istio 或 Azure 的 Service Fabric)都很值得考虑。

关键的一点是，不要低估构建一个具有适当弹性和高可伸缩性的服务有多难。决定你是否真的需要这一切，彻底教育每个人，引入有用的约束，循序渐进地做每件事，期待挫折和成功。

<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 68 31" version="1.1"><title>Group</title> <desc>Created with Sketch.</desc></svg>