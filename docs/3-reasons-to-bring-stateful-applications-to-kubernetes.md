# 将有状态应用程序引入 Kubernetes 的 3 个理由

> 原文：<https://thenewstack.io/3-reasons-to-bring-stateful-applications-to-kubernetes/>

[](https://www.linkedin.com/in/bkurk/)

[Boris Kurktchiev](https://www.linkedin.com/in/bkurk/)

[Boris 是 Diamanti 的现场 CTO。他就技术创新进行讨论和合作，并与客户和其他 CTO 密切合作，以便更好地了解和指导他们的集装箱之旅。](https://www.linkedin.com/in/bkurk/)

[](https://www.linkedin.com/in/bkurk/)[](https://www.linkedin.com/in/bkurk/)

有云原生纯粹主义者认为有状态应用不属于容器。有状态应用——从一个事务到另一个事务保留持久数据的应用——打破了 [12 因素应用](https://12factor.net/)的流程法则。该法律规定，应用程序应该作为“一个或多个无状态进程”来执行这导致许多应用程序被重构，将记住状态的责任转移到客户端。例如，电子商务购物车应用程序可以使用会话 cookies 来存储购物者的购物，直到交易时间。

然而，12 因素框架还指出，“任何需要持久化的数据都必须存储在有状态支持服务中，通常是数据库。”因此，当这个购物车应用程序需要在继续之前验证库存时，它必须从某个数据库中提取数据。

尽管容器最初不是为数据库、数据分析和数据处理应用程序设计的，但这些有状态的应用程序组件现在可以部署到 Kubernetes 环境中。尽管容器仍然更有可能容纳无状态应用，但我们看到容器中有状态应用的增长有三个主要原因。

## 1.每个人都受益于灵活性和可移植性

软件开发人员是第一批快速采用容器的群体，这是加速微服务应用程序开发的一种方式。能够在容器中打包微服务使得在本地环境中处理应用程序和快速迭代代码变得更加容易。与过去遗留的单一应用程序相比，开发人员有办法更频繁地推动代码更改并提供更多功能，而不会长时间延迟编译和构建应用程序。随着 Kubernetes 作为标准编排工具的加入，开发人员也可以将这些应用程序发布到不同的环境中，而不用担心兼容性问题和基础设施的差异。

今天，容器和 Kubernetes 项目都是由开发人员和 IT 运营团队发起的。除了开发人员的灵活性，运营和 SRE 团队也认识到了 Kubernetes 的优势，包括:

*   *   **更高的弹性**:容器化的应用程序可以快速重启以解决问题。如果有任何影响节点的软件或硬件故障，应用程序只需在不同的节点上重新启动。
    *   **缩短问题解决时间:**容器化应用程序的不变性使得修补和更新应用程序，或者将它们回滚到以前的工作版本变得非常简单。
    *   **改进的自动化:** Kubernetes 支持声明性模型，这使得它可以更有效地扩展，并产生可重复的结果。内置的自我修复和 API 驱动的接口允许更容易地实施蓝绿部署。
    *   **更好的可移植性:**随着 Kubernetes 成为被广泛采用的标准，应用程序真正可以跨不同的基础设施移植；跨云和内部环境提供一组通用的 API。

虽然无状态微服务构成了早期 Kubernetes 项目的大部分，但上面列出的所有好处对于所有应用类型都是有价值的。开发人员仍然需要迭代数据库设计，运营团队仍然需要简单的方法来更新和回滚数据处理应用程序，并从问题中快速恢复。因此，在过去的一年中，我们看到 Kubernetes 中支持有状态应用程序的工具和解决方案迅速增加，这也鼓励了更多的企业将其有状态应用程序容器化。事实上，[451 Research](https://diamanti.com/resources/451-research-paper-the-rising-wave-of-stateful-container-applications-in-the-enterprise/)最近的一项调查显示，大多数企业(55%)认为有状态应用程序占所有容器化应用程序的一半以上。随着越来越多的有状态应用程序被容器化，这一数字有望进一步增长。

## 2.库伯内特斯的存储正在改善

Kubernetes 的最初版本对复杂的有状态应用程序的支持是有限的，但是 Kubernetes 社区已经在这个领域进行了快速的创新。让我们来看看一些使有状态应用成为可能的关键创新，包括在 Kubernetes 框架内和通过对 Kubernetes 的扩展。

### 持久卷(PV)

从一开始，Kubernetes 就通过 *PersistentVolume* (PV)和*persistent volume claim*(PVC)API 支持持久卷。 *PersistentVolume* (PV)是一个存储卷，其生命周期独立于任何使用 PV 的 Pod。这些卷由系统管理员创建，可以由各种存储系统支持，包括 Amazon EBS 或 NFS 或 Ceph。

一个*PersistentVolumeClaim*(PVC)是来自用户的存储请求。该请求包括卷的大小和所需的访问模式—对单个已装载节点的读写、对多个节点的读写或多个节点的只读。

### 批量插件

每个光伏电池都有存储系统支持。在 Kubernetes 的早期，不同存储基础设施的接口是通过卷插件处理的。创建了不同的卷插件来支持不同的存储解决方案；包括每个主要的公共云，iSCSI 和 NFS。但是这些插件的原始架构需要将代码签回到核心的 Kubernetes 项目中——每个插件都有自己独特的需求。2015 年，Diamanti 贡献了 [FlexVolume](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-storage/flexvolume.md) 插件，使第三方存储提供商能够以一致的方式向 Kubernetes 呈现卷。这影响了近年来容器存储接口(CSI)的创建，允许来自不同供应商的新存储解决方案进入市场。

### 存储类

在大多数企业环境中，出于价格和性能原因，不同的应用程序需要不同的存储特征。2017 年，Kubernetes 增加了*存储类*对象*。*一个*存储类*为管理员提供了一种方式来描述他们提供的存储“类”并为开发人员提供不同的选项。伴随这一概念而来的是动态预配置的概念，其中系统等待特定持久卷类型的请求，并将 PVC 与可用的 PV 相匹配。这为用户提供了更大的灵活性，可以将应用程序与最适合的存储类型对应起来。

### 状态集

在早期，虽然卷可以独立于 pod 保持持久性，但当它们在集群中的不同节点上重新启动时，仍然很难将存储卷重新附加到 pod。2016 年，我们第一次看到了“宠物集”的 alpha 概念，当它在 2017 年发布时，它变成了 *StatefulSets* 。StatefulSets 是一个工作负载 API 对象，它维护每个 Pod 到持久卷的粘性标识，以便您可以将卷重新附加到可以在不同节点上重新启动的 Pod。这种发展对于维护集群中的状态非常重要，因为像数据库这样的应用程序现在可以在 Pod 关闭后继续存在。

### 集装箱存储接口

如前所述，卷插件无法适应不断增长的存储生态系统，因此创建了 CSI 来为 Kubernetes 提供一个公共接口。CSI 于 2018 年 12 月开始全面可用，使第三方存储提供商能够编写与 Kubernetes 互操作的插件，而不必触及核心代码。这引发了最新的创新浪潮，因为商业供应商能够将更高级的功能引入市场，以支持生产部署。

## 3.Kubernetes 中的有状态应用程序现在已经可以生产了

无状态应用程序和有状态应用程序对“生产就绪性”有非常不同的要求——最重要的是如何保护和保存状态和数据。

在无状态应用程序的情况下，出现的任何问题——无论是与节点、Pod、网络还是硬件故障有关——Kubernetes 都会简单地停止应用程序并在其他地方重新启动它。这解决了大量常见类型的问题。这是可能的，因为所有容器化的应用程序都由不可变的映像文件和声明性 YAML 文件支持，这些文件通常存储在 Docker Hub、Artifactory 或 Harbor 等工件存储库中。只要这些文件完好无损，同一个应用程序就可以在集群中的不同节点上重新启动。因为这个应用程序没有状态，所以同样的应用程序也可以在不同位置的完全不同的集群中启动，只要这个新的集群也可以访问这些文件。它不依赖于任何预先存在的数据。

这是 Kubernetes 的一个非常强大的优势，它允许无状态应用程序在不同的集群和不同的基础设施之间具有高度的弹性和可移植性。

然而，当您考虑像数据库或 AI/ML 应用程序这样的有状态应用程序时，这就变得更加复杂了。除了确保工件存储库完好无损之外，我们现在还必须确保数据本身的高可用性和弹性。这需要考虑可能发生的所有不同类型的故障模式，并拥有一套完整的数据服务来处理每种类型的故障模式。

与传统的数据中心环境一样，这些应用程序需要集成的备份和恢复功能，以及卷快照，以便在偶尔发生磁盘故障或节点故障时能够生存。然而，许多组织还希望防止机架故障，因此跨不同可用性区域扩展集群的能力非常重要。这可以通过同步镜像来实现，通过同步镜像，数据可以在单个扩展群集中的节点之间自动复制。最后，银行和医疗机构等企业也希望具有站点弹性，这意味着能够通过异步复制和灾难恢复服务将数据发送到另一个位置。

许多部署到 Kubernetes 的复杂的有状态应用程序也是 I/O 密集型的。Splunk 或 Elasticsearch 等数据处理应用程序，Kafka 等消息应用程序，以及前面提到的数据库和 AI/ML 工作负载，都给系统带来了巨大的压力。为了为这些应用程序提供生产级性能，企业还需要考虑所选存储系统的性能。具有服务质量保证的低延迟存储通常可以提高应用程序性能，甚至通过提高效率来降低成本。例如，Splunk 客户可以通过更高效的存储系统接收更多数据并收集更多实时见解。

CSI 和 Kubernetes 存储生态系统的其他发展在最近经历了一个复兴时期，因为引入了更高级的云本机存储解决方案来提供这些高级功能。无论是通过提供当今虚拟化环境中常见的可比数据保护和数据弹性解决方案，还是提供可在 Kubernetes 中本机利用的高性能、低延迟存储选项，当今企业可用的选择使得在 Kubernetes 中支持即使是最复杂的有状态应用程序成为可能—具有与传统环境中相同的性能和弹性，但具有灵活性和可移植性的额外优势。

## 有状态应用程序的下一个挑战

这是否意味着任务完成了？Kubernetes 中的有状态应用程序和无状态应用程序一样吗？还没有，但是差距正在缩小。

如前所述，无状态应用程序可以非常容易地在不同的集群中重启——只要工件可用，它甚至可以在不同的云中运行。对于有状态的应用程序来说，这仍然是一个挑战，因为卷中的数据也需要移植到不同的集群。Diamanti 正在通过 Diamanti Spektra 3.0 解决这一挑战，它允许将数据复制到其他 Kubernetes 集群，包括基于云的集群。

这是一个令人兴奋的时代，现在比以往任何时候都没有理由阻止容器化有状态应用程序。Kubernetes 不再是纯粹主义者的专利。

<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 68 31" version="1.1"><title>Group</title> <desc>Created with Sketch.</desc></svg>