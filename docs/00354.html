<html>
<head>
<title>The Case for Containerizing Middleware</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">容器化中间件的案例</h1>
<blockquote>原文：<a href="https://thenewstack.io/case-containerizing-middleware/#0001-01-01">https://thenewstack.io/case-containerizing-middleware/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">


<p class="translated">在应用程序正从“遗留的”、客户机/服务器、<em> n </em>层模式转移到完全分布式系统环境的情况下，接受中间件的存在是一回事。对于许多应用程序来说，它们的作者很久以前就已经从事高薪工作，容器化它们所依赖的中间件可能是它们在混合数据中心与现代应用程序共存的唯一方式。</p>
<p class="translated">这就是为什么Red Hat为OpenShift扩展其JBoss Fuse中间件服务是一件大事。这也是为什么Cloud Foundry去年12月在<a href="https://thenewstack.io/cloud-foundrys-vision-services-ecosystem-transcends-containers/" class="local-link">将其开放服务代理API作为开放标准的举动</a>可以被视为容器平台的必要事件。</p>
<p class="translated">但是等一下。我们认为我们在做什么？容器化的目的不就是隔离分布式功能并使它们无状态，以便我们可以自由地伸缩它们吗？即使从最广泛的意义上来说，中间件应该成为我们容器环境的永久部分吗？或者我们真的打算在<a href="https://thenewstack.io/12-factor-app-streamlines-application-development/" class="local-link"> 12因素应用方法论</a>的12个因素旁边都打上星号吗？</p>
<h2 class="translated">“第一件事”</h2>
<p class="translated">红帽副总裁兼中间件总经理迈克·皮赫在谈到新的堆栈时表示，从一个极端的整体服务转向另一个极端的细粒度微服务是有代价的。</p>
<p class="translated">“如果你在一个庞然大物里面，你写的是一大块代码，本质上是这个世界的外部边界，”皮赫说。“该边界内的一切都是本地的，您共享内存，而不是在网络上来回穿梭，这会带来延迟。如果你做了一大堆假设，走了一大堆捷径，有些事情会进展得很快。你可以看到你周围的一切。达到一定规模，那也行。这种构建功能块的方法为我们服务了几十年。但是很难改变应用程序的任何一个小部分。”</p>
<p class="translated">他指出，微服务架构确实给了开发人员改变更小的代码组件的奢侈，而不用担心陷入意大利面条中。他说，当网络的存在和与该网络共存的所有其他事物的共存引入延迟时，这些粒度元素往往无法充分应对，这种权衡就产生了。</p>
<p class="translated">这是他支持中间件方法的理由:具体来说，是Red Hat的Fuse、其企业服务总线及其Apache Camel的实现。在大规模上，服务需要一个沟通的仲裁者和一个请求的仲裁者——这些角色是编排者忙于在平台上准备组件而无法胜任的。</p>
<p class="translated">“这些天，当我在人群面前演讲时，我通常会谈到微服务方法的好处，”皮赫说。“通过将传统的单一应用程序分解为一组更细粒度的组件，每个组件都独立地具有生命周期、可伸缩性、可替换性和可交换性，您可以使您的整体业务更加强大。它能够以更快的速度进行小规模的增量更改，并且中断其他业务的风险更小。</p>
<p class="translated">“尽管如此……为了做微服务，我仍然必须对API有所约束。作为一名开发人员，我必须做一些不同的事情。每个微服务都必须有一个定义良好的API，开发人员必须尊重一致性和向后兼容性。事情#1，你必须进入API思维模式。像任何软件开发方法一样，做好它部分取决于你使用什么技术，部分取决于你如何使用它们。”</p>
<p class="translated">这导致了皮赫对Fuse的推介，从而导致了容器化中中间件(或类似的东西)的出现:拥有一个与应用程序共享相同范围的通信仲裁器——换句话说，在与编排器相对的抽象墙的另一边——让开发人员可以考虑<em>一个服务将通过API通信什么</em>,而不是<em>它将如何通信</em>或者当时<em>。因此，服务总线可以为分布式系统做服务总线为客户机/服务器应用程序和n层应用程序所做的事情:扮演更合适的代理的角色。</em></p>
<h2 class="translated">另一种类型的云开发</h2>
<p class="translated">这将我们引向一个重要的问题，不仅因为它的架构含义，还因为它的政治含义:引入一种在云之外创建的方法，并在云出现之前首次公之于众，引入了对一个可能是本地的组件的硬依赖，这真的构成了云原生开发吗？</p>
<p class="translated">IBM杰出的工程师Andre Tost(T16)说:“通常我们将世界分为我们所谓的<em>云使能的</em>种环境和应用，以及<em>原生云</em>或<em>以云为中心的</em>种环境和应用。</p>
<p class="translated">“我认为在中间件的背景下，更多的是在支持云的空间，”Tost告诉新的堆栈。“这意味着我的应用程序并没有考虑微服务架构，而是考虑了云因素，基于使用中间件的三层或n层架构。现在，我们希望开始受益于一些云计算原则。”</p>
<p class="translated">托斯特和为IBM混合云首席技术官办公室服务的凯尔·施洛瑟去年8月合作撰写了一份指南<a href="https://www.ibm.com/developerworks/library/mw-1608-tost-trs/index.html" class="ext-link" rel="external ">用内置中间件</a>构建Docker容器映像。它使用WebSphere开发人员可能更熟悉的语言向他们介绍Docker是什么以及它是如何工作的。它甚至暗示中间件包含并不完全是任何创建容器架构的人所想的。</p>
<p class="translated">所以指南提出了这样的建议:让中间件的Docker映像有效地不完整，像模板一样。通过构建过程，中间件提供商可以向该映像添加相关的包。那么应用程序提供商可以通过添加应用程序及其特定定制来完全定制图像。“最终，”托斯特和施洛瑟写道，“中间件的Docker镜像必须提供适当的扩展点，使添加应用程序变得容易。”</p>
<p class="translated">这就涉及到了Tost对云支持的定义:获取一个应用程序，无论它是完整的还是概念性的，并对其进行重构以用于云部署。在你认为这种想法只适用于改造旧的、单一的应用程序之前，请考虑这样一个事实，即世界上大多数软件开发人员都带着他们的技能。从头开始不是他们可能首先采取的行动。</p>
<p class="translated">托斯特说:“云支持的另一个方面是，我们只需将我们拥有的一切放入容器中。“这就是我们<em>在文章</em>中试图解决的问题。我不知道这篇文章是否说清楚了这一点，但我一开始就相当怀疑这样做。我这么说是因为，我已经和一些公司谈过了，他们说，‘嗯，我们将利用我们拥有的一切，除了我们将从虚拟机转向容器之外，我们不会改变任何东西。’我认为他们从[<em>到</em>都没有首先考虑预期收益是什么。"</p>
<p class="translated">托斯特说，在容器出现之前，IT自动化是这样工作的:你创建一个虚拟机，在其上安装一个操作系统，安装查看操作环境内部的代理，安装部署中间件和部署服务器集群的脚本，最后安装应用程序。</p>
<p class="translated">从Tost客户的角度来看，集装箱化所代表的变化首先体现在自动化方面。改变一切的是容器构建过程:事实上，映像是在应用程序开始运行之前构建的。堆叠被颠倒；应用程序放在第一位，其他部分放在最上面。这就是为什么托斯特和施洛瑟的文章从Dockerfile和构建过程开始。</p>
<p class="translated">在客户旅程的这一点上，如果你愿意，中间件是否发挥作用还没有成为一个问题。为什么会这样？</p>
<h2 class="translated">捍卫自由</h2>
<p class="translated">“过去，我们将应用服务器视为一种应用服务器工作负载的管理器，但它也是这些工作负载的运行时，”凯尔·施洛瑟在接受我们采访时说道。“我们已经看到，管理工作负载的责任落到了容器服务本身身上，比如Kubernetes。但是运行时间仍然是运行时间。作为微服务架构的一部分，它们可能被分解成更小的单元，我们不会在同一个进程空间中运行同样多的应用程序。</p>
<p class="translated">“当我们试图将传统的中间件引入像Kubernetes这样的容器平台时，在这种情况下，我们有两个软件试图执行相同的功能，”施洛瑟继续说道。“它们可以相互对立，但在其他情况下，它们可以很好地共存。不过，我们认识到，这种转变正在发生。”</p>
<p class="translated">出于这个原因，他告诉我们，IBM正在投资创建它所谓的Liberty <a href="https://developer.ibm.com/wasdev/docs/microprofile/" class="ext-link" rel="external "> MicroProfile </a>，这是一个架构的实例，它在一个专门设计用于微服务的组件中提供了一个小型的、高度封装的Java EE功能子集。</p>
<p class="translated">“我们需要一个Java外形，吸引那些已经过渡到微服务开发的Java开发人员，”施洛瑟说。“因此，在MicroProfile中，我们不仅要考虑如何使它更加轻量级，还要考虑如何提供开发人员感兴趣的功能。”</p>
<p class="translated">在IBM的世界里，有支持云的设计原则和云原生原则。这两者之间有明显的重叠。具有讽刺意味的是，可能正是这些被设计来使一些旧的方法在新环境中工作的组件最终促进了，甚至加速了对新环境的进化性改变。例如，施洛瑟指出，数据库中的<em>事务</em>的概念是在有限的多线程和顺序同步逻辑时代产生的。微服务设计的异步性可能会破坏这个概念，从而改变数据库事务的<em>原子性</em>。</p>
<p class="translated">想象一个更“全息范式”(向肯·威尔伯道歉)，其中一个分析例程可以同时探索一系列事件的多个独立的替代方案，你会明白我在说什么。想一想，如果一个例程可以窥视到某个特定事件的含义，而<em>没有</em>发生，欺诈检测会受到怎样的影响。忽略了任何顺序或同步概念的微服务架构可能无法完成这样的壮举。</p>
<p class="translated">IBM的Tost说:“架构中的一些现有的东西可能永远不会消失。“这完全不是由世界应该怎样来驱动的，而是这些环境似乎会永远存在的事实。CICS、COBOL，甚至RPG和AS/400仍然存在，并且可能会持续二十年。我认为，像J2EE式中间件或MQ式中间件这样的东西不会很快消失，即使会消失，也不会很快消失——同样，这不是因为技术需求或利益，而只是因为构建在它们之上的大量工作负载，这些工作负载将一直保持下去，可能永远不会被重写。”</p>
<p class="attribution translated">标题图片，标题为“21世纪的通信高峰”，作者鲍勃·弗兰克斯顿(没错，就是VisiCalc的联合创始人鲍勃·弗兰克斯顿)，来自他正在收集的成千上万个令人瞠目结舌、草率的通信线路维修工作，大部分在马萨诸塞州，<a href="https://www.flickr.com/photos/90163423@N04/with/9953578983/" class="ext-link" rel="external ">在他的个人Flickr feed </a>上。</p>
<p class="attribution translated">Cloud Foundry和Red Hat是新堆栈的赞助商。</p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
<title>Group</title>
 <desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>

</div>
</div>    
</body>
</html>