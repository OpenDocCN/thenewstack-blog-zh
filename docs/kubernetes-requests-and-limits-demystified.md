# Kubernetes 请求和限制去神秘化

> 原文：<https://thenewstack.io/kubernetes-requests-and-limits-demystified/>

*注意:这是包含 Kubernetes 资源管理和优化的五部分系列的第二部分。在本文中，我们解释 Kubernetes 的请求和限制。您可以在这里* *重温第 1 部分解释 Kubernetes 资源类型* [*。*](https://thenewstack.io/understanding-kubernetes-resource-types/)

 [欧文·达里娅

欧文是 StormForge 的首席销售工程师。在担任构建和领导基础架构团队的角色后，Erwin 已经过渡到供应商方面，在 Tintri 和 Juniper Networks 等公司的销售、营销和产品角色中服务并取得成功。](https://www.linkedin.com/in/erwindaria/) 

Kubernetes 提供了一个共享的资源池，它根据我们如何配置我们的容器化应用程序来分配资源。当调度程序将 pod 放置在节点上时，会发生分配过程。在检查了容器的资源配置之后，调度器选择一个能够保证容器配置所指定的资源的可用性的节点。然后，它将容器的 pod 放在合适的节点上。通常，这可以确保部署的微服务不会遇到资源短缺。

但是，有些工作负载可能需要比容器化应用程序配置使用的资源更多的资源。如果没有一种方法来限制应用程序可以请求使用的资源，我们的应用程序可能会导致成本过高、资源浪费、应用程序性能低下甚至应用程序失败。因此，实施边界系统以防止资源浪费和代价高昂的失败是至关重要的。

这就是为什么资源请求和限制是 Kubernetes 环境的重要组成部分。

## 资源请求

请求是指必须为容器保留的资源。包含资源请求确保了容器将至少接收所请求的内容。

当容器包括资源请求时，调度器可以确保它分配 pod 的节点将保证必要资源的可用性。

## 资源限制

限制是允许容器使用的最大资源量。当我们不配置限制时，Kubernetes 会自动选择一个。因此，当一个限制配置不当时——无论是开发者还是 Kubernetes——我们可能会经历许多不愉快和代价高昂的后果。

这些后果，我们将在后面更深入地探讨，包括由于 CPU 节流和内存不足(OOM)错误导致的不必要的高云成本和低性能。

虽然有几种类型的资源，但在本文中，我们将重点关注 CPU 和内存。我们将这些资源统称为“计算资源”

## CPU 和内存请求和限制

### **CPU**

在 Kubernetes 环境中，CPU 代表整体处理能力。我们在 Kubernetes CPUs 中测量它，其中一个 CPU 单元代表一个物理 CPU 或虚拟核心。

为了适应各种各样的应用类型，我们可以非常精确地表示 CPU 测量值，精确到 CPU 或内核的 1/1000。例如，如果我们想要请求 0.5 个 CPU，我们应该将其表示为 500m，其中 m 代表毫核心:

在创建容器时，我们可以使用清单中的资源:请求和资源:限制来指定 CPU 资源:

```
apiVersion:  v1
kind:  Pod
metadata:
 name:  example-pod
 namespace:  example-namespace
spec:
 containers:
 -  name:  example-name
 image:  repo/example-image
 resources:
 limits:
 cpu:  "500m"
 requests:
 cpu:  "250m"

```

在上面的例子中，我们已经指定容器请求的 CPU 为 250m，限制为 500m。这意味着将为容器预留的处理能力是 250 米。此外，如果一个进程需要超过 250m 的内存，它可以访问额外的 CPU 资源，调度程序将确保这些资源在节点上可用，最高可达 500m 的限制。

### **记忆**

内存资源以字节为单位，可以用定点数、整数或 2 的幂等来表示。我们将使用最常见的表达式——2 的幂等价式 Mi。这代表一兆字节，即 220 字节。

例如:

正如我们对 CPU 所做的那样，我们可以在清单中使用 resources:requests 和 resources:limits 来指定内存资源请求和限制。

让我们在下面的清单中添加一个内存请求和限制:

```
apiVersion:  v1
kind:  Pod
metadata:
 name:  example-pod
 namespace:  example-namespace
spec:
 containers:
 -  name:  example-name
 image:  repo/example-image
 resources:
 requests:
 memory:  "64Mi"
 cpu:  "250m"
 limits:
 memory:  "128Mi"
 cpu:  "500m"

```

使用此清单创建的容器将保证并保留 64Mi 的内存。如果一个进程需要更多的内存，并且它在节点上可用，那么只要它不超过 128Mi 的限制，它就可以访问更多的内存。

此外，如果一个容器指定了它的计算资源限制，但没有指定资源请求，那么 Kubernetes 会自动将请求配置为等于限制。

## 要求和限制的重要性

请求是 pod 调度的关键组成部分，pod 调度是由 Kube-scheduler 执行的任务。

调度是在 Kubelet 运行 pod 之前将它们与正确的节点相匹配的过程。该过程说明了 pod 的资源需求和可用节点上的可用资源。在我们的例子中——通常情况下——pod 的资源包括容器所需的资源和 pod 本身所需的资源。

在集群中，具有容纳新 pod 的资源容量的节点称为可行节点。调度程序评估这些节点，并为 pod 选择最佳节点。评估过程要求计划者考虑几个因素，包括:

*   所需资源
*   亲和性和反亲和性规范
*   工作负荷间
*   硬件和软件限制

然后，该单元被放置在选定的节点上。然后，Kubelet 通过将容器的内存和 CPU 限制以及请求传递给容器运行时来启动 pod 中的容器。

如果容器中的进程超出了请求的内存，并且它的节点用完了内存，那么托管该进程的 pod 可能会被逐出。

然而，重要的是要注意，驱逐吊舱时有一个序列要遵循。这完全取决于 pod 的服务质量。

## pod 的服务质量

创建 pod 时，它会收到一个根据其资源规格分配的服务质量(QoS)等级。有三类服务质量:

*   **BestEffort** :这个类被分配给一个包含没有指定内存和 CPU 请求和限制的容器的 Pod。
*   **Burstable** :如果一个 pod 的容器有一个指定的内存或 CPU 请求和限制，那么它就会接收这个分配的类。
*   **保证**:如果一个 pod 满足以下条件，则该 pod 被分配到该等级:

*   *   pod 中的所有容器都有内存和 CPU 请求和限制。
    *   所有容器的内存请求都等于限制。
    *   所有容器的 CPU 请求都等于限制。

QoS 对于确定 Kubelet 在计算资源耗尽的情况下可以从节点中驱逐哪些 pods 非常重要。当一个节点想要回收一些资源以确保剩余单元的继续操作时，就会发生驱逐。

库伯莱将在爆裂豆荚之前驱逐最佳努力豆荚。然后，它会在有保证的 pod 之前驱逐可爆发的 pod。

## 不设置限制和要求的后果

如果我们未能设置资源限制和请求，Kubernetes 会自动为我们设置。这听起来可能很方便，但是 Kubernetes 的目标是确保应用程序不会失败。因此，它将分配不合理的慷慨限制。

例如，如果我们不为只需要 250 万 CPU 资源的集群指定请求或限制，Kubernetes 可能会将 CPU 请求设置为 900 万。这将增加我们集群的资源需求，使其运行起来过于昂贵。

此外，如果 Kubernetes 不必要地保留大量资源，我们可能会经常遇到 OOM 错误。

此外，当被驱逐的豆荚累积时，我们的星团会变得杂乱无章。即使被驱逐的 pod 不再消耗节点的资源，它们也需要 Kubernetes 环境中的额外资源。

CPU 节流是未能设置或未正确设置 CPU 限制的另一个后果。当我们指定一个 CPU 限制时，Kubernetes 会附加一个允许 CPU 容量的时间框架。如果容器在循环结束前超出限制，它必须暂停并等待下一个循环开始，然后才能继续执行。这可能会导致响应时间显著增加。

在确定请求和限额时，准确性是最重要的。将限制设置得太高会导致资源浪费，而设置得太低则会大大增加 CPU 节流的可能性。

## 获得配置良好的请求和限制的好处

正确执行时，设置计算资源请求和限制可以以较低的成本实现平稳快速的性能。但是做好这件事是很棘手的。

因此，在提供建议时，采用能够考虑应用程序性能的资源优化解决方案是非常有益的。StormForge 就是这样一个解决方案。

StormForge 使用机器学习来自动确定最佳配置。从其推荐的选项中，我们可以选择 CPU 限制来优化我们的集群的性能或成本，确保我们可以将我们的 Kubernetes 环境与我们的业务目标保持一致。根据我们的选择，StormForge 会采取以下方式之一:

*   如果性能比成本更重要，它建议使用更高的 CPU 限制来防止节流。
*   如果成本的优先级高于性能，它将确定一个较低的 CPU 限制，这将导致在必要时进行调节。

## 结论

Kubernetes 集群消耗的资源越多，运行成本就越高。如果我们分配最少的资源来节省成本，我们将面临糟糕的性能和频繁的代价高昂的 OOM 错误。

通过正确指定我们的计算资源请求和限制，我们可以最大限度地减少超支，优化性能，并确保最有效地利用我们的 Kubernetes 资源。然而，试图确定最佳平衡可能是艰巨的。

StormForge 通过一个自动化的人工智能驱动的解决方案来减少人工，该解决方案可以根据您的业务需求调整您的配置。您可以免费试用，体验以最高的成本效益产生最佳性能是多么容易。

*请继续关注本系列的后续文章，在这些文章中，我们将解释如何设定优化目标，以及如何应对一些最困难的优化挑战。*

<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 68 31" version="1.1"><title>Group</title> <desc>Created with Sketch.</desc></svg>