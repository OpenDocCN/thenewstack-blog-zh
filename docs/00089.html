<html>
<head>
<title>ClusterHQ: The Importance of Container Plugins for Extending Docker's Functionality</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ClusterHQ:容器插件对扩展Docker功能的重要性</h1>
<blockquote>原文：<a href="https://thenewstack.io/clusterhq-the-importance-of-container-plugins-for-extending-dockers-functionality/#0001-01-01">https://thenewstack.io/clusterhq-the-importance-of-container-plugins-for-extending-dockers-functionality/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">


<p class="translated">容器不是计算机。它可以像一个过程一样简单，只需要让该过程运行所需的资源代码和本地操作系统服务，由底层操作系统支持。但是还有一些事情人们仍然难以想象:因为容器可以联网，流程也可以。函数第一次可以拥有自己的IP地址。</p>
<p class="translated">更重要的是，容器是可扩展的。即使是Docker公司也很难完全预见到这最后一个优点。在几周前的最后一次DockerCon上，开发人员第一次看到了一个更全面实现的容器插件愿景——能够以标准化、可靠的方式扩展容器有用性的功能。这一次，愿景考虑到了插件需要相互利用的事实。</p>
<p class="translated">Glider Labs负责人Jeff Lindsay是这样向DockerCon与会者解释新愿景的:“作为一名系统集成商，我们知道几乎每个定制应用程序都有不同的需求。某些领域，如存储和网络，非常复杂；有很多选项…插件为用户提供了选择、自由和底层存储驱动程序的实现，以及Docker中的其他东西。”</p>
<p class="translated">几周前，开放容器项目(OCP)的形成给许多人留下了这样的印象:未来，不仅容器图像，而且围绕它们的新兴生态系统都将有一个单一的标准。鉴于市场现实，这种印象已经有所淡化。尽管如此，还是有关于容器化插件的单一标准规范的讨论，就像Lindsay描述的那样。</p>
<p class="translated"><a href="https://thenewstack.io/clusterhq-lets-move-docker-like-cattle-but-make-the-data-special/" class="local-link"> ClusterHQ开发了一个名为Flocker </a>的插件，当容器在网络中移动时，该插件使运行在容器内的应用程序能够保留它们与外部数据库卷的绑定。为了使Flocker有效，它需要能够与处理这些容器网络的任何东西进行交互，这在越来越多的情况下是<a href="http://weave.works/" class="ext-link" rel="external ">编织网</a>。</p>
<p class="translated">为了让快速增长的容器生态系统有效地工作，OCP应该致力于标准化容器和插件之间的接口，包括Docker、rkt和其他格式吗？新堆栈与ClusterHQ首席执行官马克·戴维斯和首席技术官卢克·马斯登坐下来，听取他们的意见。</p>
<hr/>
<p class="translated"><strong>cluster HQ首席技术官Luke Marsden:</strong>在Solomon [Hykes，Docker首席技术官]陈述我们在可互操作格式和围绕这些新工具的每个人方面的目标，以及我们目前的目标之间，将会有很大的时间差距。插件现在存在于Docker 1.7实验版中，我认为我们在实现批量插件方面所做的投资将会非常非常广泛地适用于Docker的所有消费者。</p>
<blockquote><p class="translated">我还认为，从战略的角度来看，每个人都和好如初的事实是很棒的，因为这意味着我们可以继续为其他任何东西构建插件，而不用担心遭到报复。</p></blockquote>
<p class="translated"><strong>cluster HQ首席执行官马克·戴维斯:</strong>过去容器格式分歧的部分原因是，人们看到了现有格式的缺点，然后说，“嘿，有更好的方法可以做到这一点。”我认为这同样适用于插件。如果结果是我们这次没有得到正确的插件，我们没有让它去社区希望它去的地方，那么可能会有其他人选择以不同的方式做插件。我可以想象。我认为我们的工作就是确保这不会发生。</p>
<p class="translated">思想的竞争是一件非常壮观的事情。重复工作是浪费时间。因此，如果我们有一个想法竞赛，有人回来说，“这是一个不同的，更好的方法来做插件架构，”我们可以同意这一点，这是一件好事。我个人会感到震惊，如果我们不学习一些关于插件的东西，让我们认为，“你知道，我们在[Docker] 1.7实验中做的那件事并不完美；我们可能希望改善这一点。”我认为，只要我们能够做到这一点，而不出现分裂组织，那将是一件大事，对吗？</p>
<p class="translated"><strong>卢克·马斯登:</strong>从集群总部的角度来看，我们并不关心插件到底是如何工作的。我们不是容器插件的人。我们不关心，“哦，我们真的对这种特殊的插件交流方式很感兴趣。”我们只是关心这样一个事实，即有一种方法可以扩展Docker的功能，以便我们在生态系统中有一个合理的位置。因此，如果插件格式改变，我们将适应它。坦率地说，我们在插件上所做的工作是达到目的的一种手段，不仅仅是因为我们认为Docker应该是可插拔的。</p>
<p class="translated">Scott Fulton，The New Stack: 嗯，我记得几年前，在90年代，在网络发展的早期，Netscape想为浏览器的插件开发一个标准<a href="https://en.wikipedia.org/wiki/NPAPI" class="ext-link" rel="external "/>，因为它看到了开发生态系统的未来是扩展浏览器的方法，用浏览器做更多的事情。微软紧随其后，整个ActiveX标准就这样产生了。我们就如何在Web上处理可扩展性进行了激烈的争论。很多这样的争斗最终导致了我们所看到的W3C的休战，这是一个保持开放思想和大量讨论的协议。</p>
<p class="translated">但我所知道的关于网络的一件事是，讨论多于行动。这就是我在这里担心的。如果有什么比复制工作更糟糕的话，那就是复制历史。</p>
<p class="translated"><strong>马克·戴维斯:</strong>像这样的团体中的标准团体可以非常非常擅长放慢速度。我见过一些公司把它作为他们的战略:“我加入这个团队，因为我的目标是让它慢下来。”</p>
<p class="translated">如果有人说，“我们将为插件的容器格式创建一个开放标准”，我们可能会想要参与。我们当然不会等待。我们必须开发软件并发布，解决客户的问题。最终，无论如何，那都是有分量的——被采纳的。</p>
<p class="translated"><strong> Scott Fulton: </strong>既然OCP已经完成，它将成为世界的一个固定部分，一些主要供应商之间将会进行交流，这些供应商都与他们将在该平台上构建的监控和管理系统有利害关系，你能确切地说Docker生态系统将继续由Docker开发者领导吗？</p>
<p class="translated">卢克·马斯登:我认为码头工人有很强的领导地位，我认为OCP的形成实际上加强了他们的领导地位。在过去的几个月里，我在生态系统中感觉到了紧张。</p>
<blockquote><p class="translated">所以在某种意义上，如果Docker没有挺身而出，那么也许其他一些供应商也会这样做。事实上，他们确实挺身而出，这意味着他们为此变得更加强大。</p></blockquote>
<p class="translated">因此，我认为Docker将继续在定义这些标准方面发挥重要作用，但这是以合作的方式进行的——坦率地说，这就是他们对我们的volumes插件所做的。我认为他们对此很成熟。</p>
<p class="attribution translated">CoreOS(rkt的制造商)和Docker是新堆栈的赞助商。</p>
<p class="attribution translated">专题图片[从左至右]: ClusterHQ首席执行官马克·戴维斯和首席技术官卢克·马斯登。</p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
<title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>

</div>
</div>    
</body>
</html>