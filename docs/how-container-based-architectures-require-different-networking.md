# 基于容器的架构如何需要不同的网络

> 原文：<https://thenewstack.io/how-container-based-architectures-require-different-networking/>

[](https://www.citrix.com/)

随着所谓的模式二应用的兴起，我们看到了软件架构的显著不同的方法。Gartner 将模式二应用程序定义为探索性的、非线性的，侧重于敏捷性和速度。为了实现这种级别的敏捷性，底层架构需要显著不同。

这些架构的基本原则开始向部署在(Docker)容器中的微服务集合靠拢。容器很小，敏捷团队一直在更新它们，这就需要围绕持续部署、管理和网络基础设施的不同动态架构。

基于容器的软件世界中的扩展导致了新的需求。过去，企业解决方案在少数虚拟机上运行，而在容器世界中，微服务实例的数量会急剧增长。

今天，我们才刚刚开始这场革命。微服务架构不会在一夜之间出现，因为它需要对企业解决方案进行大量重写。毫无疑问，新的解决方案将基于微服务。

大型企业有大量的遗留应用程序，随着时间的推移，这些应用程序将基于这些技术在云中重生，基于容器的架构的好处实在太诱人了，让人无法抗拒。它不仅降低了软件开发的风险，而且新功能的价值实现时间也将为最终用户带来大量的商业价值。

典型的大型企业有 500 到 10，000 个应用程序(我甚至见过接近 100，000 个的极端情况)。想象一下，随着时间的推移，所有这些应用程序都将使用运行在容器中的微服务来编写。这些应用程序中的每一个都可能有 10-100 不同的微服务，其中每个微服务都有许多实例在容器中运行。随着时间的推移，这将导致企业环境运行 100，000 多个容器！同样，这不会在一夜之间发生，但 10 年后这可能会成为现实。

微服务往往是高度动态的，根据系统上的负载进行伸缩，并且更新如此频繁，以至于每个实例都是短暂的。微服务之间的网络流量(东西向流量)往往比南北向流量(从请求者到着陆服务)大得多。大多数请求在响应被发送回请求者之前会跳过多个微服务。

容器也非常适合在公共云中部署基于微服务的应用程序。容器通过对应用程序隐藏物理基础设施和操作系统需求来提供极大的灵活性，这使它们非常适合在本地和公共云中运行工作负载。

容器的短生命周期和容器内托管的应用程序的频繁更新使得大规模供应微服务成为一项挑战。这就是 Kubernetes 的用武之地。Kubernetes 有一个蓬勃发展的开源社区，有 1000 多名贡献者，并且是云本地计算基金会(CNCF)的一个主要项目。Kubernetes 提供了与云无关的解决方案，可跨内部和公共云自动部署、扩展和管理容器化应用程序，同时，Kubernetes 还解决了有关云供应商锁定的问题。

将传统的三层应用程序迁移到微服务并不是一件容易的事情，最好分阶段完成以简化迁移。

## 应用部署之旅–从三层到微服务

传统的应用程序部署为三层结构，分为应用层、业务逻辑层和数据层，这些层通过负载平衡器相互通信。三层架构易于部署，但在支持新功能的持续交付方面设计僵化。微服务架构增加了操作的复杂性，但其设计非常灵活，能够持续集成和交付新功能。在三层架构中，网络和安全策略从一个中心位置进行管理，通常是负载平衡器或防火墙。另一方面，微服务架构的分布式特性使得管理网络和安全策略比整体架构困难得多。另一个值得注意的区别是，三层架构遵循传统的或服务器端的负载平衡，其中客户端只知道一个目的地。另一方面，微服务架构遵循客户端负载平衡，客户端知道多个目的地，负载平衡发生在离客户端更近的地方。

在您计划过渡时，考虑这些差异非常重要。以下是一个分步指南，可确保在您将 3 层应用程序重新部署为微服务时将中断降至最低:

### 阶段 I)迁移到发夹结构

在典型的三层架构中，负载平衡器是应用程序的入口点。让所有流量都通过一个入口点，可以更容易地从一个中心位置管理网络和安全策略。在迁移的第一阶段，最好保持这种简单性，而不是专注于将应用程序分解为模块化微服务的更困难的任务。一旦应用程序被分解成模块化服务，你应该通过中央负载均衡器对它们进行细分。在这种情况下，中央负载平衡器可以是已经充当所有应用程序的 N-S 入口点的同一硬件或软件设备。这种方法的主要优点是，它保留了南北(N-S)和东西(E-W)通信的三层交通流的简单性；从安全的角度来看，这大大简化了事情。这种方法的一个缺点是，它在网络中引入了额外的一跳，从而增加了东-西业务的延迟。

作为过渡的下一步，您应该考虑将东西向流量转移到专用的东西向负载平衡器，从而将南北向流量与东西向流量分开。此外，您可以进一步简化 E-W 负载平衡，方法是将它分解为每个应用程序一个 E-W 负载平衡器，如下图中紫色和绿色应用程序所示。这使得开发团队可以灵活地将负载平衡器打包和部署为他们的应用程序包的一部分。

对于处于开发运维之旅早期的组织来说，这种部署架构可以在传统 IT 和开发团队之间清晰地划分角色和职责。它允许 It 部门保留对中央负载平衡器的控制，这样，他们就可以负责管理进入数据中心的 N-S 流量的安全性和合规性，同时，它还为开发人员提供了更多的自由和对其服务的更多控制。这种模式还有其他优势——它最大限度地减少了开发团队之间的协调开销，因为每个应用程序都捆绑了自己的小型负载平衡器，它限制了单个应用程序发生故障时的爆炸半径，它通过分散故障域来帮助更快地进行故障排除，并且它支持各个应用程序的日志、配置和安全策略的清晰分离。

### 阶段 II)使用发夹和网状物组合

接下来，将具有简单负载平衡需求的流量从中央负载平衡器中移出，但将具有应用感知路由和安全需求的流量保留在中央负载平衡器中。在这种模式下，所有具有简单负载平衡需求的流量都通过 Kubernetes 自带的默认代理进行负载平衡。例如，需要通过 Web 应用程序防火墙或富内容路由策略进行 SSL 或内容检查的应用程序可以继续通过中央负载均衡器，而所有其他流量则直接到达目标服务。这一变化值得注意的另一点是，所有具有简单负载平衡需求的 E-W 流量现在开始从服务器端负载平衡转移到客户端负载平衡。这一步骤的主要优点是它减少了由阶段 1 的发夹模型引起的延迟和吞吐量开销。这种方法的一个缺点是管理安全性不像三层那么简单。安全性在应用程序堆栈中处于较低的位置，更靠近每个服务，微服务架构的分布式特性使管理安全性成为一项挑战。

### 阶段-III)全网状或服务网状的最终目的地

旅程的最后一步是全网状架构。这个阶段有一个智能的内容感知代理，具有丰富的 API 管理、API 安全和流量管理功能，运行在每个 Kuberenetes 节点上，管理所有的 E-W 流量。在第三阶段结束时，以传统的服务器端负载平衡模式开始的 E-W 流量完全转移到客户端负载平衡模式。进入数据中心的 N-S 流量仍然遵循传统的服务器端负载平衡模式。这种架构的最大优势在于，它通过消除第一阶段和第二阶段的繁琐开销，提高了整个网络的效率。

全网状架构的一种稍微高级的形式是服务网状。它提供了一个基础设施层，从服务中抽象出常见的网络和安全需求，并将其吸收到网格基础设施中。这种常见网络和安全需求的几个例子是身份验证、跟踪、断路器和可见性。

在第三阶段结束时，您将成功地将一个 monolith 应用程序重新部署到部署在容器上并由 Kubernetes 管理的分布式云原生微服务架构。运行大量容器的企业环境需要不同的方法来实现微服务的负载平衡、安全性、可见性、监控和管理。

## 大规模管理微服务和容器的挑战

微服务架构由许多小型的、模块化的、松散耦合的分布式服务组成。在微服务架构中，网络运营商必须与大量容器竞争，相互通信形成复杂的模式。因此，根据定义，与传统的 3 层架构相比，微服务架构中的服务数量、容器实例数量、部署规模和变化率都要高得多。

关于操作复杂性，需要考虑以下几个方面:

*   有更多的服务实例需要负载平衡，
*   服务实例的短生命周期使得检查这些短暂容器的健康状况成为一个挑战，
*   数量庞大的服务实例需要高度自动化来管理大规模滚动升级；当大规模处理集装箱时，人工或半人工过程不起作用，
*   微服务架构中自治团队的频繁应用程序更新需要新的工具来进行金丝雀测试、蓝绿色部署以最小化停机时间，
*   与整体相比，微服务应用需要通过应用级超时、重试和回退对故障具有更高的容忍度。这种设计模式在网络中引入了一种新的行为，需要在规划中加以考虑，例如，当服务变慢时，重试次数会迅速增加，等等。
*   服务之间交叉连接的增加显著增加了日志/指标的数量，
*   与单个映像中的模块通过进程内调用或 IPC 相互通信的整体架构不同，微服务的这些调用是通过网络进行的。更多的服务和服务实例可能意味着更多的故障点，更多的操作复杂性。

## 可见性和分析

可见性和故障排除在任何分布式系统中都是困难的，微服务也不例外。本节探讨微服务架构特有的操作、故障排除和可见性挑战。

微服务的分布式特性增加了系统中所有级别(网络、硬件和应用)的故障点。更多的移动部件并不一定意味着更多的故障，但肯定会增加操作的复杂性。为了帮助为故障事件做好准备，您需要一个良好的可见性和分析解决方案。

在微服务架构中，一个用户请求通常会分散成对其他服务的多个 API 调用，而这些 API 调用又可能会调用更多的嵌套服务。这种扇出模型带来了一些有趣的问题:

*   理解 API 调用通过基础设施的过程变得很困难。例如，收集信息变得很困难，例如，一个服务有多少依赖关系，依赖关系服务是否热运行，API 调用链的可视化描述，请求有多深，它在什么级别失败，等等。
*   一个只有 1%的延迟时间的服务在孤立的情况下可能看起来不错，但是从整体来看这仍然是一个问题。例如，一个调用许多下游服务的面向用户的顶级 API 在大多数时候可能会遇到某些人的缓慢路径(1%的情况)，从而导致糟糕的用户体验。
*   微服务环境中的大量 API 日志使得很难发现低效的 API 调用。例如，一个实现很差的列表遍历逻辑会分散到对同一个服务的许多 API 调用中，它可以很容易地从批处理这样的调用和缓存响应中获益。
*   由于下游 API 中不相关的变化，如添加/删除与顶级 API 不相关的字段，导致失败的顶级 API 开始表现不同，深入了解这一点变得非常困难

微服务架构中的团队结构和动态也会导致微妙的问题。在微服务架构中，服务团队独立工作，很少或没有协调，因此导致团队孤立。这可能会导致整体式架构中通常看不到的微妙问题:

*   从事微服务的团队需要通过请求超时、重试和回退来优雅地处理故障。服务团队经常会无意中为超时和重试选择相似的值，这在失败的情况下会导致致命的副作用。这种设计模式暴露出的一个潜在问题是，已经关闭的服务可能会在运行过程中受到大量请求的轰炸，导致它再次关闭，这种周期性的关闭-重启会重复发生。如果调用者服务中的超时和重试是可预测的而不是随机选择的，或者如果调用者服务不能区分合法的和暂时的失败，就会发生这种情况。
*   团队按照自己的节奏独立行动，很少甚至没有协调。这意味着调用者对目标服务没有控制权——一个团队可能正在产品中测试一个新特性，或者一个团队可能由于某种回归而恢复到一个旧版本，或者 Kubernetes 本身可能正在自动伸缩容器实例以满足变化的负载条件。在这种环境下，确保所有团队一致的 SLA 会变得很有挑战性，尤其是如果您没有一个一致的仪表板来衡量和比较所有服务的指标。
*   需要对服务团队生成的日志进行良好的统计和跟踪。如果没有适当的指导和审核，失控的服务可能会无意中生成详细的日志，这可能会导致在日志聚合层存储、搜索和索引数据方面的一系列新的扩展挑战。

此外，在微服务架构中遵循设计模式也会引发一些有趣的问题:

*   出于规划和可靠性的原因，微服务架构中的服务被鼓励快速失败，因为这样做比承担更多负载和降低每个人的体验要好。然而，问题是对于这种情况没有一个放之四海而皆准的答案。每个服务都是不同的，一个好的解决方案应该基于历史、当前负载、资源类型和呼叫服务来动态地使用断路器和服务限制。
*   微服务应用程序所遵循的最终一致的范例(其中服务开始时有不同的视图，但最终收敛于一致的视图)使得应用程序行为在稳定期间不一致。
*   Canary 是微服务中一种常用的技术，用于在向更广泛的用户群开放之前，向一部分用户介绍新的更新。通过将新版本与旧版本进行对比，金丝雀方法很快发现了新版本中的问题。然而，挑战在于，如果没有一个良好的分析框架，很难进行前后对比，以评估金丝雀释放的风险。

显然，在处理许多微服务时，可见性是一个挑战。获得更多洞察的一种方法是在面向用户的请求中嵌入唯一的请求 id，并让下游服务在整个调用链中携带它们，然后挖掘日志数据以获得有价值的洞察。鉴于这些挑战，我们需要一种数据驱动的解决方案，它能够理解微服务的设计模式，不仅能够在问题出现之前主动发现问题并在出现问题时减少分类时间，还能够建议纠正措施，将服务恢复到稳定状态。

## 安全性

在这种动态环境中管理安全性也非常具有挑战性。在整体架构中，应用程序模块在单个映像中捆绑在一起。这些模块通常通过进程内调用、回送、本地套接字和共享内存相互通信。monolith 方法的一个主要缺点是，如果其中一个模块被破坏，整个系统就会变得脆弱。同样，确保微服务架构的安全性和合规性也同样困难——微服务架构包含大量可使用 API 通过网络访问的服务，这大大增加了攻击面，因为攻击者现在可以设计基于网络端口或 API 的攻击。服务实例的短暂性也使得监控容器、应用安全性和对安全漏洞进行取证变得困难。考虑到通过整合不同来源的基础映像来打包和部署容器是多么容易，容器和微服务架构中的安全性需要端到端地考虑:

*   从构建、扫描、数字签名容器映像到部署它，
*   必须将它放入 CI/CD 管道中，
*   它应该考虑到操作系统的强化，
*   它应该包括网络和应用层分段，
*   它应该包括身份验证和授权机制，以确保调用者是他们所声称人，
*   服务应该通过安全的通信信道相互对话。

一般来说，因为服务是独立的——由不同的团队、编程语言、技术构建块等开发——确保微服务架构中所有服务的一致安全状态是一个具有挑战性的问题。

## 结论

随着企业押注于容器和微服务来提高应用交付的速度和敏捷性，需要一种真正理解微服务设计模式的企业级解决方案来帮助基础设施运营商实现安全性和合规性，并提供数据驱动的见解和行动。

<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 68 31" version="1.1"><title>Group</title> <desc>Created with Sketch.</desc></svg>