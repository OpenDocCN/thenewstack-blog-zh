# Typesafe 的 Jonas Bonér:反应式编程如何解决向外扩展的问题

> 原文：<https://thenewstack.io/typesafes-jonas-boner-how-reactive-programming-addresses-the-scale-out-problem/>

曾经有人告诉我们，随着计算机系统变得越来越大，软件也随着变得越来越大，在形式和功能上取得了优雅的平衡。

不，不是的。在多个处理器内核下运行的软件在确定如何将自己划分为并发线程时需要大量的帮助。如果开发人员没有在程序中嵌入如何实现这一点的指令，处理器自己会寻找它能找到的细分机会。这远不是一个完美的过程，尽管它最终会产生性能收益，但也不是没有代价的。

## 一致性的成本

当虚拟化使作业能够跨多个处理器扩展，汇集在一个动态云中(如果你不介意来自生态系统两个不同部分的混合隐喻)，围绕着一个更模糊的概念*节点*出现了全新的系统，这些节点与其他节点交换数据和工作功能。一种“元设备”成形了，在这种设备中，整个服务器都是晶体管和逻辑电路的放大版。但是就像在电子设备上一样，为了让这些交换产生没有瓶颈的结果，它们需要某种程度的同步性。

这是因为互联网被设计成一个异步系统。第一个互联网规模的系统开始表现出不可预测性、怪异性和随机行为。一位脸书的工程师将这种现象称为[亚稳态](https://thenewstack.io/the-strange-behaviors-of-facebooks-metastable-failures/)，这是在 20 世纪 60 年代逻辑电路中目睹的奇怪行为之后——由部件在 0 和 1 之间转换引起的行为，但不完全是这两种状态。

Jonas Bonér 认为，对于纵向扩展和横向扩展的问题，有一个很好的解决方案。这是一个建筑解决方案，许多人会同意 Bonér 的美学价值。但是这需要对程序如何工作有一个根本不同的理解——特别是模块化的作用和功能的划分。

Bonér 的公司是 [Typesafe](https://typesafe.com/) ，他个人对它的贡献是 Akka，一个中间件层，它在用 Java 或 Typesafe 自己的 Scala 编写的组件之间添加了抽象层。他也是一个简短但有影响力的文档的作者，该文档名为[反应宣言](http://www.reactivemanifesto.org/):呼吁对一种编程类型采取行动，对许多人来说，这是面向对象原则的对立面。

这种思维方式违背了一个普遍的、在某些方面无可争议的信念，即硬件本身就能够扩展软件，无论是纵向还是横向，直到这样做是可行的。

Bonér 在接受 New Stack 采访时表示:“横向扩展面临的最大挑战是消除争用。加上增加的一致性成本，争用是可伸缩性的大杀手。”

他继续说，在试图协调对共享数据或资源(如套接字或文件处理程序)的访问时，争用可能发生在许多层面上。

“协调对可变数据的访问需要某种排队或互斥，”他继续说道，“这会带来等待时间和排队效应。如果您能够以一种在数据方面没有耦合的方式来建模您的问题，那么您就消除了可伸缩性的最大障碍之一。”

简而言之，在任何一个时间点交换的数据的完整性被称为*状态*。Bonér 解释说，硬件维护这种状态的成本是*一致性* —例如，当 CPU 维护 L3 缓存的最新状态时，或者当 QPI 等互连用于跨处理器交换状态时。当开发人员能够隔离任务时——或者更确切地说，当像 Akka 这样的框架帮助开发人员跨进程共享*更少的*状态数据(最好一个都没有)时，一致性成本就接近于零。

Bonér 说:“这意味着你可以将软件分散到多个 CPU、内核、插槽或机器上。

## 更加注重断言

去年 1 月，在 Dice company 博客的一篇文章中，Espresso Logic 的 CTO Val Huber 展示了使用传统过程模型的数据库驱动程序与使用 Bonér 和 Typesafe 支持的反应模型的数据库驱动程序之间的概念差异。在拼凑一个简单的客户采购订单应用程序时，基本变量(product_price、qty_ordered 等)之间的关系。)都写在“鸡尾酒餐巾”上。在过程模型中，这些关系是通过一系列调用条件(if/then)逻辑的步骤来实现的。

但是在反应式模型中，需要的指令和餐巾纸上的说明性关系一样多——在 Huber 的例子中是 5 个——只是语法不同。底层框架使这些指令能够在它们引用的值发生变化时强制执行这些关系。这些变化是触发器，而框架使反应成为可能。

然而，关于反应式模型是否只是隐藏了一组底层过程的额外抽象层，本质上与条件逻辑相同，只是被隐藏了起来，仍然存在争议。Huber 和他的同事声称，由于这种模型极大地提高了可伸缩性，这种争论变得没有实际意义。通过将变量之间的关系表述为“不变”状态，即“事物的本来面目”，反应式模型避免了 Bonér 所说的“耦合”。

当你将它应用于互联网规模的系统时，这个理由是有道理的:当程序向外扩展时，程序中变量之间的耦合或相互关系越多，确保数据完整性所需的依赖项就越多——以确保每个组件的数据视图是最新的和正确的。这种依赖性只能通过一系列按顺序执行的步骤来维持，而瓶颈就是通过这些顺序出现的。

Bonér 要求“从孤立的单元和不共享的角度考虑问题，这意味着每个孤立的单元只处理自己的数据，不会不必要地共享数据。相反，它处理自己的数据，当有了结果，它就向全世界公布。如果它发布的东西是*不可变的*，不能被改变，那么就可以安全地共享而不会发生冲突。但是它在完全隔离的情况下对*可变*数据、处理中的数据、运行中的数据做所有的工作。然后，您可以随心所欲地独立扩展这些单元。”

如果除此之外，还会有一个物联网，那么就需要一个比我们现在拥有的纯顺序模式更具可扩展性的模式来解决这些问题。一个完美的同步模型，就像你在一个袖珍计算器中的电路一样，是行不通的。无论我们是否采用像反应式这样的绝对孤立主义模型，我们采用的模型可能会比我们今天对物联网的预测更像反应式。

Jonas Bonér 说:“在未来，所有这些设备都需要采用完全基于消息的方法，因为这是我们能够以合理的硬件数量为所有设备提供服务的唯一方法，并且具有成本效益。现在可能没问题，但如果像他们预测的那样，我们在短短几年内拥有 500 亿台设备，我们就无法用同步协议跟上这一速度。”

<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 68 31" version="1.1"><title>Group</title> <desc>Created with Sketch.</desc></svg>