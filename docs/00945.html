<html>
<head>
<title>Microsoft and Red Hat's KEDA Brings Event-Driven Autoscaling to Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微软和红帽公司的KEDA为Kubernetes带来了事件驱动的自动缩放</h1>
<blockquote>原文：<a href="https://thenewstack.io/microsoft-and-red-hats-keda-brings-event-driven-autoscaling-to-kubernetes/#0001-01-01">https://thenewstack.io/microsoft-and-red-hats-keda-brings-event-driven-autoscaling-to-kubernetes/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">


<p class="translated">随着事件驱动架构变得越来越普遍，出现了许多旨在将无服务器引入Kubernetes的项目。Azure Functions已经在Kubernetes上运行，但像其他函数运行时一样，它一直在使用容器的标准水平伸缩，基于容器的CPU和内存消耗。这不符合无服务器的事件驱动特性。</p>
<p class="translated">“当Kubernetes试图决定每台机器上运行多少pods时，它只是查看消耗了多少CPU和内存，”Azure Functions的高级项目经理Jeff Hollan 解释道。“很无功；它试图猜测需要多少个实例。”</p>
<p class="translated">这对于扩展无服务器功能来说太慢了，因为无服务器功能需要对来自事件源的信号做出反应，而不是等到系统资源耗尽时才做出反应，而且它也没有反映出您可能选择如何进行负载平衡。例如，Azure Functions通过观察事件队列来扩展，如果一个队列有100条消息在等待，那么不管CPU负载看起来如何，它都会旋转4或10个实例，而不是一个。</p>
<p class="translated"><a href="https://github.com/kedacore/keda" target="_blank" rel="noopener noreferrer external " class="ext-link">KEDA</a>——基于Kubernetes的事件驱动自动伸缩——是微软和Red Hat的一个新的开源项目，旨在将这种伸缩引入Kubernetes，使容器能够根据事件指标(如流延迟或队列长度)从零扩展到一千个实例。</p>
<p class="translated">KEDA充当激活和停用部署的代理，并且充当Kubernetes度量服务器，向水平Pod自动缩放器公开事件数据。“这是一个额外的组件，用于监控您的活动源并将数据反馈给Kubernetes系统，以便Kubernetes了解您的队列和活动中心，”Hollan解释道。“您只需在集群上一次性安装KEDA，KEDA就会监控支持KEDA的新容器，并像功能一样扩展它们。”</p>
<p class="translated">您可以设置KEDA轮询新消息的频率以及它应该如何扩展和冷却，然后部署直接处理事件，这样事件就不必转换为HTTP请求，HTTP请求会丢失内容并阻止与事件源的直接通信。类似地，使用KEDA不需要对已部署的代码进行任何更改(尽管代码需要包装在Docker容器中)。</p>
<p class="translated">KEDA已经与Kafka、Azure Queues、Azure Service Bus、RabbitMQ、Azure Event Grid和其他云事件合作(这将它连接到更多的服务)。微软将为Azure事件中心、存储、Cosmos DB和持久功能添加触发器，事件源也可由社区扩展。</p>
<p class="translated">KEDA可以扩展任何容器或部署，其他无服务器项目也可以利用它，但开源的Azure Functions runtime已经与它集成了。</p>
<p class="translated">红帽和微软都在为上游的KEDA项目做贡献，红帽也在使用KEDA来扩展OpenShift容器平台上的Azure功能作为开发者预览版。这种集成是用Red Hat的Operator Framework toolkit构建的，将于今年晚些时候在OperatorHub.io gallery中提供。Red Hat的<a href="https://www.linkedin.com/in/markito/" target="_blank" rel="noopener noreferrer external " class="ext-link"> William Markito Oliveira </a>解释说:“它的设计目的是以托管服务的方式在Azure上运行，但现在可以在OpenShift运行的任何地方运行，这意味着在混合云和本地运行。“Azure服务和其他云提供商的用户可以通过他们的服务发送事件，并以可移植的方式使用Azure功能处理这些事件，从而减少锁定问题。”</p>
<p class="translated">“实际上，KEDA通过轮询来自云上事件源(如Azure Queues)或本地事件源(如Kafka)的队列或主题，使应用程序能够根据需求进行扩展，”奥利维拉在一封后续电子邮件中指出。“举个例子，当用户向购物车添加一件物品时，KEDA会主动监控购物车并触发一个容器。这是一个非常简单的例子，但是对于具有突发和不可预测特征的系统来说，它变得非常有趣。当一个购物车系统的需求增加，1000人向其中添加多项商品时，KEDA将自动扩展您的应用程序，以满足这样的需求。当处理完这些事件后空闲时，它会缩小规模，甚至回到零个容器，这是无服务器解决方案的一个主要优势。”</p>
<p class="translated">“我们知道很多人对锁定感到焦虑，并考虑如何在不同的环境中运行，”Hollan指出。“KEDA是关于采用函数编程模型和它带来的所有生产力，你可以在任何最有意义的地方运行它——这可能是Kubernetes。如果你想带着你的玩具在不同的云中运行，你可以这样做，我们会为你提供工具。”</p>
<h2 class="translated">超越HTTP</h2>
<p class="translated">微软云计算团队负责人<a href="https://github.com/gabrtv" target="_blank" rel="noopener noreferrer external " class="ext-link"> Gabe Monroy </a>告诉the New Stack，“很多时候我们认为自动扩展和扩展到零的功能是以HTTP为中心的。“事实证明，在Azure函数中，60%到70%的执行是事件驱动的，而不是HTTP驱动的。像事件网格、服务总线和那些提供事件的不同排队系统；这是一种非常常见的模式。”</p>
<p class="translated">对于像HTTP这样被推到容器中的事件——这构成了其他30%的工作负载函数——你可以使用<a href="https://github.com/knative/serving" target="_blank" rel="noopener noreferrer external " class="ext-link"> Knative serving </a>或者微软去年在Kubecon、<a href="https://github.com/deislabs/Osiris" target="_blank" rel="noopener noreferrer external " class="ext-link"> Osiris </a>和<a href="https://github.com/kedacore/keda/wiki/Using-Azure-Functions-with-Keda-and-Osiris" target="_blank" rel="noopener noreferrer external " class="ext-link"> KEDA </a>宣布的开源项目。“KEDA是函数的事件驱动伸缩，Osiris是函数的HTTP驱动伸缩。Osiris是HTTP版本的scale-to-zero，KEDA是事件驱动、队列驱动、自定义指标驱动的版本，”Monroy解释道。</p>
<p class="translated">这是一个精心设计的策略，构建“小、有范围、做好一件事”的开源组件，为Kubernetes社区提供混合和匹配的选项，以获得他们需要的东西；他建议的一种方法可以追溯到Docker的“包含电池但可拆卸”的承诺。</p>
<p class="translated">“允许这些东西分别组装和组合是确保我们让开源生态系统最大限度地利用这一机会的关键，因为如果你构建的东西太大，最终就很难将其视为一个库，”他指出。</p>
<h2 class="translated">无服务器Kubernetes:一个跨行业项目</h2>
<p class="translated">Monroy告诉我们，Red Hat希望将Azure Functions的体验带到OpenShift上。“RedHat正在关注押注于Kubernetes的所有客户，这些客户希望构建功能型应用。Knative和其他一些技术在这方面有一定的优势，但这些东西都没有功能带来的完善程度和生产使用水平。几乎从第一天起，函数就已经是容器原生的了。”<br/>KEDA、Open Shift和功能的组合为您提供了在云中运行无服务器托管服务的选择，作为Open Shift中的一个集成选项，或者在任何Kubernetes集群上DIY，无论它在哪里。</p>
<p class="translated">去年，Kubernetes联合创始人<a href="https://www.linkedin.com/in/brendan-burns-487aa590/" target="_blank" rel="noopener noreferrer external " class="ext-link">布伦丹·伯恩斯</a>说<a href="https://thenewstack.io/the-future-of-kubernetes-is-serverless/" target="_blank" class="local-link">Kubernetes的未来是无服务器的</a>。蒙罗伊说，企业客户已经在要求这样做了。“他们想要没有虚拟机开销、按秒付费、具有快速扩展能力的Kubernetes服务。”</p>
<p class="translated">微软开发部门主管John Montgomery建议，如果这是大多数Kubernetes采用者想要的，那么基于一个涉及多个组织的项目是很重要的。“不可能只有一家供应商在做这件事。”</p>
<p class="translated">“无服务器在很深很深的方面改变了游戏规则，”Montgomery告诉New Stack。“无服务器能够在一个容器中运行，我们在过去5年中一直致力于开发人员体验，通过无服务器的强大功能为您提供开发人员生产力。然后你在Kubernetes上运行，突然间你就获得了这种云规模的能力来旋转和摧毁容器。KEDA还可以利用我们用AKS做的所有其他事情，比如无服务器容器工作。你得到了可移植性，你得到了容器的加速-减速，加上函数的加速-减速，再加上开发人员的生产力。将所有这些放在一起，该技术将改变一类应用程序的游戏规则，但我认为我们才刚刚开始弄清楚这类应用程序是什么。”</p>
<p class="attribution translated">红帽是新堆栈的赞助商。</p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
<title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>
</div>
</div>    
</body>
</html>