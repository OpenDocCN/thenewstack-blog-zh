<html>
<head>
<title>New JFrog Workload Inspection Tool Points to a Post-Container World</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">新的JFrog工作负载检查工具指向后容器时代</h1>
<blockquote>原文：<a href="https://thenewstack.io/new-jfrog-workload-inspection-tool-points-post-container-world/#0001-01-01">https://thenewstack.io/new-jfrog-workload-inspection-tool-points-post-container-world/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">


<p class="translated">在容器化时代的开端，高端的方法论讨论是关于容器如何改变开发人员对工作负载本质的看法。然后是来自<a href="https://thenewstack.io/new-stack-mitchell-hashimoto-containers-no-containers-one-question-2015/" class="local-link"> HashiCorp创始人Mitchell Hashimoto </a>和其他人的一些警告，警告说可以想到的控制工作负载的方法都是朝着一个共同目标的不同方法——在这种程度上，我们应该停止将容器视为架构，并着眼于与实现无关的工作负载。</p>
<p class="translated">显然，工作负载协调行业已经注意到了这一点。周一，<a href="https://www.jfrog.com/" class="ext-link" rel="external "> JFrog </a>，其<a href="https://thenewstack.io/jfrog-announces-artifactory-4-0/" class="local-link"> Artifactory </a>知识库已经被设计成集成各种开发工具的代码产品，朝着将工作负载与包含它们的格式分离的方向又迈进了一大步。为了回应Docker Inc .上周发布的容器漏洞扫描器，以及Twistlock发布的新改编的容器行为分析系统。这是一个检查系统，它揭示了应用程序与支持它们的操作系统内核和代码库之间的深度依赖关系——无论以何种形式。</p>
<p class="translated">“每个人都需要在二进制层面上保护他们的软件，”JFrog的首席执行官什洛米·本哈姆在接受新堆栈的采访时说，“否则就没有办法实现自动化，没有它就没有DevOps。而且应该是通用的。”</p>
<h2 class="translated">正在扫描什么，为什么</h2>
<p class="translated">许多早期关于容器的批评——或者在OCI形成之前被称为“Docker容器”——集中在这种格式的可利用性似乎是一个公开的问题。Docker Inc .已经在多个场合解决了这些问题，包括其自己的Docker可信注册中心，以及最近的Docker安全扫描。</p>
<p class="translated">但是开源生态系统的范围更广，包括诸如Maven用于Java项目的JAR和Node.js  使用的<strong> <a href="https://www.sitepoint.com/beginners-guide-node-package-manager/" class="ext-link" rel="external "> npm包管理器等格式的包。无论什么样的安全问题会影响OCI容器的可利用性，从这个角度来看，都同样会影响包含依赖(甚至非依赖)代码组件的其他包格式的相同特征，这些组件可能包含漏洞。</a></strong></p>
<p class="translated">在某种程度上，通过Xray的发布，JFrog使得这个问题不再是Docker要解决的问题，而是每个人的问题。本哈姆告诉新的堆栈，它将对软件包进行深度扫描，收集其内容的大量日志，并以开发人员更容易理解的格式制作一个依赖图，直观地描述代码组件之间的依赖关系。然后，它将生成一个影响分析报告，根据JFrog之前积累的信息，为开发人员提供这些包(OCI容器或其他容器)可利用性的最坏情况。</p>
<p class="translated">“今天最重要的事情是，当你运送一个集装箱或分发一个包裹时，你基本上不知道里面有什么，”本哈姆说。“有各种各样的安全漏洞、许可证和合规性数据库。虽然您拥有所有这些信息，但是它们并没有为您提供这些图像中包含的内容的依赖关系图。最重要的是，他们无法为您提供开发运维及自动化最重要的东西之一:影响分析。”</p>
<p class="translated">本哈姆继续说道，JFrog此次发布的目标不是克隆那些在中小企业IT界如此常见的<a href="http://www.notebookreview.com/softwarereview/system-mechanic-pro-review/" class="ext-link" rel="external ">绿灯/红灯安全扫描器</a>，而是给开发者一份真实的报告，说明他们的代码如何与依赖它的软件交互。通过这种方式，开发人员可以借此机会简化他们的代码，并尽可能减少依赖性。</p>
<h2 class="translated">单核的可信度更高</h2>
<p class="translated">本哈姆表示，x射线将写入常见的日志数据库，如<a href="https://thenewstack.io/red-hat-enlists-black-duck-fortify-container-security/" class="local-link">黑鸭</a>、<a href="http://www.whitesourcesoftware.com/how-it-works-setting-up/" class="ext-link" rel="external ">白源</a>和<a href="https://www.versioneye.com/" class="ext-link" rel="external ">版本眼</a>——后者将包含在x射线中。当然，新工具将与JFrog的Artifactory集成，以实时收集构建信息，在将构建提交到生产环境之前呈现依赖图<em>。首席执行官表示，该图将包括生产环境中的具体影响点，当潜在易受攻击的代码被推向生产时，这些点将受到影响。</em></p>
<p class="translated">“DevOps工程师现在正遭受的一件事是，虽然容器是分发你的软件包的一种很好的方式，”他告诉我们，“你仍然需要知道，你仍然需要报告，这个容器映像包括什么……这不仅仅是容器的问题，[<em>这是人们现在指出的事情之一。它也适用于各种包装。一旦你推出了某样东西，你就想知道它包括什么，它有哪些依赖关系，并确切地知道你过去把它推到了哪里，以及你将来要把它推到哪里。”</em></p>
<p class="translated">JFrog Xray将生成的潜在复杂图形可能也适用于单内核的情况，这是一种工作负载打包方式，其中完整的操作系统内核被小型化，替换为只包含软件包可能需要的依赖代码的库。依赖图可以提供直观的证据，表明当应用程序被部署在数据中心时，修整其未使用或无用代码的软件分发可以简化应用程序的组织。包包含的依赖越少，它们被利用的机会就越少，包括在未来。</p>
<p class="attribution translated">Docker是新堆栈的赞助商。</p>
<p class="attribution translated">专题图片:<a href="https://commons.wikimedia.org/wiki/File:Josef_Maria_Eder,_frog_x-ray.jpg" class="ext-image" rel="external ">约瑟夫·玛丽亚·埃德尔和爱德华·瓦伦塔在公共领域拍摄的两只青蛙的x光照片</a>，大约在1896年。</p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
<title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>

</div>
</div>    
</body>
</html>