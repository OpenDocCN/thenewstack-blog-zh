<html>
<head>
<title>Ancestry.com's Docker Story and How It Eventually Led to Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ancestry.com的Docker故事以及它如何最终导致Kubernetes</h1>
<blockquote>原文：<a href="https://thenewstack.io/ancestry-coms-docker-story-eventually-lead-kubernetes/#0001-01-01">https://thenewstack.io/ancestry-coms-docker-story-eventually-lead-kubernetes/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">


<p class="translated">Ancestry.com<a href="https://www.ancestry.com/?s_kwcid=ancestry.com&amp;gclid=CjwKCAjwzYDMBRA1EiwAwCv6JpZB-s5foim0ADMfPNABcQkX60l1PYjXxJE-qSePr9uio99DzxLTXBoC5oIQAvD_BwE&amp;o_xid=57465&amp;o_lid=57465&amp;o_sch=Paid+Search+Brand" target="_blank" class="ext-link" rel="external ">的软件工程师架构师Paul MacKay </a>最近在微服务虚拟峰会上发言，阐述了采用容器的问题以及它在如何运行他们的技术堆栈方面带来的巨大变化。</p>
<p class="translated">Ancestry是一个拥有200亿历史记录、9000万个独立的家谱和超过100亿个档案的网站。它的400万会员有1.75亿张可分享的照片、文档、书面故事和收藏。这总计超过9pb的数据。</p>
<p class="translated">他们目前有九个集群，包括内部部署和AWS。在生产集群中，有成百上千个节点和成百上千个单独的服务，然后成千上万个pod通过Docker和Kubernetes运行。</p>
<p class="translated">他们于1996年上线，团队成员一直稳定在三到四人。从使用C#和Microsoft Windows开始。NET框架来提供服务，随着时间的推移，它们扩展到包括。然后，NET、SQL Server和IIS转向开源技术，包括运行在Linux上的Java、Node.js和Python。</p>
<div id="attachment_2799831" class="wp-caption alignleft"><img aria-describedby="caption-attachment-2799831" decoding="async" loading="lazy" class="size-medium wp-image-2799831" src="../Images/631d08f8b2cd8f7ca6d4896f0f2fd2f7.png" alt="" data-original-src="https://cdn.thenewstack.io/media/2017/08/fa268694-ancestry-production-env-300x167.png"/><p id="caption-attachment-2799831" class="wp-caption-text translated">Ancestry.com生产环境</p></div>
<p class="translated">但是在三年前的一次会议上看到Docker的演示后，他们将容器添加到组合中，这就需要改变他们运行堆栈的方式。</p>
<p class="translated">“我们能够向管理层证明，部署和扩展这些服务很容易，并且部署时间会缩短，”他说。迁移到Docker还使他们能够更有效地利用我们的计算资源。</p>
<h2 class="translated">预计道路会崎岖不平</h2>
<p class="translated">首先，他说，采用新技术很难。他说，Ancestry的开发人员不是为了创建基础设施，而是为客户开发新功能。“你必须一开始就认识到，采用新技术会减少开发向客户提供的功能，”他说。</p>
<p class="translated">他解释说，因为新技术可能非常具有破坏性，所以上层管理人员必须确信，为什么新技术值得从新功能上转移注意力、资源和努力。</p>
<p class="translated">他说，关键是要有一个赞助人，他不仅能给你你需要的时间和资源，还能给你实验和做新事情的真正能力。一个明白路上可能会有失败并允许失败的人。</p>
<p class="translated">麦凯解释说，与此同时，你需要工作人员的认同。在Ancestry，他们创建了试点团队来推广新的微服务技术。这些团队不仅仅创建POC(概念验证)，他们还有各种各样的实际问题要解决。</p>
<h2 class="translated">这就是支持的样子</h2>
<p class="translated">“如果(这些团队)不成功，他们就不会成功，”他说。“我们是这一过程变化的一部分。”他们给予这些团队全力支持，从大量训练开始。</p>
<p class="translated">McKay说，当他们开始走上微服务之路时，他们有许多没有Linux、容器或编排经验的Windows开发人员，他们需要接受如何让它们工作的培训。他说，不仅仅是工具，还有如何将服务分解成更小块的概念和范例。目标是让他们感到舒适，并有能力采用新技术。</p>
<p class="translated">McKay说，然后他们提供工具来帮助快速部署任何规模的服务。这些工具适用于所有集群，并为新的和有经验的开发人员提供了惯例和最佳实践。</p>
<div id="attachment_2799832" class="wp-caption alignleft"><img aria-describedby="caption-attachment-2799832" decoding="async" loading="lazy" class="size-medium wp-image-2799832" src="../Images/f97da593358b63d425555676be2eee9f.png" alt="" data-original-src="https://cdn.thenewstack.io/media/2017/08/f0ad7ce2-ancestry-quick-start-tools-300x167.png"/><p id="caption-attachment-2799832" class="wp-caption-text translated">Ancestry快速入门工具</p></div>
<p class="translated">当你采用新技术时，他说，你真的是在飞行中学习。这就产生了非常敏捷的需求。会犯错误，这没关系。他们确保团队知道他们需要一起工作，并且他们都将使彼此成功。</p>
<p> </p>
<h2 class="translated">回到技术</h2>
<p class="translated">他们开始了决定拆分哪些服务的过程。McKay解释说，需要考虑许多方面，例如网络延迟、监控和协调所有这些服务的部署。“东西不是免费的，”他指出。“管理服务是有成本的。”</p>
<p class="translated">他说，你需要了解如何扩大规模。“您是扩展这些微服务的一部分还是子集？您是否会一次扩展所有内容？这些服务独立存在真的有意义吗？是对生态系统有用的东西吗？”他问。</p>
<p class="translated">他们让开发者决定服务的规模。他解释说:“我们真的觉得，对于容器化来说，最简单的方法是让开发者决定服务的规模以及如何去耦合。”</p>
<h2 class="translated">推出微服务</h2>
<p class="translated">所以他们推出了Docker，构建了自己的Linux发行版和CoreOS。当他们看到Kubernetes的测试版演示时，McKay避开了其他编排工具，转而支持新技术。</p>
<p class="translated">他为他们忠诚的试验团队创建了一个小型的Kubernetes沙盒，这些试验团队致力于将他们的服务分开，并尝试将Kubernetes用于容器部署。</p>
<p class="translated">他们建立了每日站立，以确保问题得到快速解决。“有一些难题需要解决，”他说。"可解决的问题…但是困难、独特和不同的问题."</p>
<p class="translated">McKay解释说，除了培训之外，他们还创造了最佳实践，构建了模板和脚本，以帮助开发人员快速入门如何分解服务，然后使用容器部署服务，并使用Kubernetes编排服务。</p>
<h2 class="translated">从REPL搬到CDEL</h2>
<p class="translated">McKay说，程序员熟悉REPL环境(读取、评估、打印和循环)。与Kubernetes这种变化，以编译，部署，执行，然后循环(CDEL)。“这意味着，”他说，“不再有协调部署、试验各种规模和分离的障碍。现在你可以真正编译，你可以部署它，你可以弄清楚它在环境中是什么样子，然后你可以重申并弄清楚什么是合适的，什么是不合适的。”</p>
<h2 class="translated">制定标准</h2>
<p class="translated">在将微服务投入生产的一年半时间里，他们开发了一些部署标准。</p>
<ul>
<li class="translated">遵循Kubernetes约定，他们为每个服务创建一个名称空间，而不管其大小，并使用一个命名约定(functionalgroup-servicename)</li>
<li class="translated">他们限制每个箱子只能放一个集装箱。</li>
<li class="translated">在他们的生产环境中，每个服务都有自己的存储库，无论大小。</li>
<li class="translated">他们使用Prometheus来监控服务，确保符合SOA。</li>
<li class="translated">开发人员可以一直部署到生产。他们从非常宽的特权开始，根据需要缩小它们。</li>
<li class="translated">他们为每个开发、试运行和生产环境创建单独的集群。</li>
<li class="translated">他们运行自己定制的集群范围的记录器，并创建了一个名称空间门户。</li>
<li class="translated">Kubernetes在cube DNS中使用集群内DNS服务器，并且在部署微服务时有一个服务发现，这大大减少了网络延迟。</li>
<li class="translated">无论大小如何，每个服务都需要CPU和内存配额。开发人员可以申请更多的资源，他们可以得到他们需要的东西。</li>
</ul>
<p class="translated">欲了解更多信息和更深入的探讨，请点击此处查看他的演讲。</p>
<p class="attribution translated">CoreOS是新堆栈的赞助商。</p>
<p class="attribution translated">通过Ancestry.com的<a href="http://ancestry.com" class="ext-link" rel="external ">拍摄特写照片和插页照片。</a></p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
<title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>

</div>
</div>    
</body>
</html>