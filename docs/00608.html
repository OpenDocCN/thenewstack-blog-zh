<html>
<head>
<title>Containers for High Performance Computing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高性能计算的容器</h1>
<blockquote>原文：<a href="https://thenewstack.io/roadmap-containers-for-high-performance-computing/#0001-01-01">https://thenewstack.io/roadmap-containers-for-high-performance-computing/#0001-01-01</a></blockquote><div><div id="tns-post-body-content">

 
<p class="translated">Docker技术客户经理Christian Kniep在最近于汉堡<a href="https://containerdays.io/" class="ext-link" rel="external ">集装箱日</a>和其他地方举行的一系列会谈中预测，通过对技术进行一些调整，Docker集装箱可以为超级计算机和高性能计算(HPC)带来前所未有的效率。</p>
<p class="translated">迄今为止，超级计算世界很少注意容器，尽管它们可以为痴迷于性能的生态系统带来更高的效率。在某种程度上，这是由于体系结构的差异——超级计算的紧密耦合模型与容器化也适用的松散耦合的“微服务”体系结构不一致。安全问题也起了作用，因为对在工作节点上运行<a href="https://thenewstack.io/red-hat-buildah-provides-a-way-to-build-containers-without-the-docker-daemon/" class="local-link"> Docker守护进程</a>的担忧吓坏了一些人。</p>
<p class="translated">但Kniep指出，一些工作自然适合HPC模式，例如人工智能工作，这可以利用超级计算机通过其丰富的GPU提供的强大向量处理能力。本周，<a href="https://www.top500.org" class="ext-link" rel="external "> SC500 </a>，每年两次运行世界上最快的超级计算机，<a href="https://www.top500.org/news/us-regains-top500-crown-with-summit-supercomputer-sierra-grabs-number-three-spot/" class="ext-link" rel="external ">宣布</a>名单上所有计算机的收集能力都超过了exaflop，达到1.22 exaflops。一个exaflop是每秒一千个petaflops或五千万亿次浮点运算。这些系统中有110个使用了GPU，其中98个是Nvidia的。</p>
<p class="translated">超级计算机旨在运行大型工作负载，如天气预报或分子建模，作为跨越数百甚至数千台服务器的单个应用程序。Kniep指出，尽管最初与云计算有相似之处，但这两种架构之间确实存在一些根本差异。如果Docker或其他云原生厂商希望服务于这一市场，就必须考虑这些差异。</p>
<p class="translated">例如，为了利用特定的加速硬件，如GPU或高速互连，HPC应用程序通常是特定于主机的，它们是为一个平台而设计的。从这个意义上说，它们是特定于硬件的，而不是Docker坚持的与硬件无关的方法。其次，HPC程序往往是紧密耦合的。它们可能有多个组件，但是它们都需要访问共享的内存空间。</p>
<p class="translated">“HPC需要在共享资源上运行，”正如Kniep在<a href="http://www.hpcadvisorycouncil.com/events/2018/swiss-workshop/index.php" class="ext-link" rel="external "> 2018 HPC顾问委员会瑞士会议</a>的一次演讲中所说<a href="https://www.youtube.com/watch?v=r9bPHKiagco&amp;list=WL&amp;index=2&amp;t=1773s" class="ext-link" rel="external ">(他上周在ContainerDays EU上做了类似的演讲)。与当今大多数Docker设置不同，在HPC设置中，多个节点将读写单个共享文件系统。每个节点还必须安全地维护自己的数据集，不受其他节点的入侵。</a></p>
<p class="translated">通常，Docker赋予容器与容器本身相同的特权集。然而，这种做法是不安全的，因为有人可以用其他人的ID创建一个容器，授予他们该用户的全部权限。因此，出于安全目的，不应信任容器设置的用户和组权限。</p>
<p class="translated">作为解决这个问题的概念验证，Kniep为Docker引擎开发了一个迷你代理，用启动容器的用户的权限覆盖容器的权限。在这种情况下，用户的权限被重新附加到容器上，而不是依赖于容器本身声明的内容。</p>
<p class="translated">HPC的另一个重要方面是应用程序完全绕过操作系统内核的能力，这是HPC中的一种常见方法，通过允许应用程序直接与专用硬件(如GPU或互连)通信来提高性能，而无需通过操作系统。</p>
<p class="translated">这个问题的最初解决方案可能是将特定于主机的驱动程序移动到容器上，这将增加容器的大小(仅Nvidia Cuda驱动程序就可能高达1GB)。更好的选择是将驱动程序放在主机上，然后将它们映射到容器本身。然后，每个主机可以使用预定义的“装载点”将其自身的特征映射到容器上</p>
<p class="translated">Kniep的Docker引擎代理也处理这项任务，只需要用户输入关于硬件要求(即GPU或Infiniband连接)以及共享库在主机上的位置。</p>
<h2 class="translated">工作需要完成</h2>
<p class="translated">有了这些变化，您可以使用Docker在HPC系统上暂存所有容器化的工作负载，包括那些需要共享空间和不需要共享空间的工作负载。这种方法将提供虚拟机的所有灵活性，但具有HPOC爱好者喜欢的线速性能。</p>
<p class="translated">一些开源倡议已经解决了将容器引入HPC空间的问题，最著名的是<a href="https://github.com/NERSC/shifter" class="ext-link" rel="external ">移位器</a>和<a href="http://singularity.lbl.gov/" class="ext-link" rel="external ">奇点</a>。Kniep警告说，这些努力没有遵循<a href="https://www.opencontainers.org/" class="ext-link" rel="external ">开放容器倡议</a>的规范，并且可能与可以构建在OCI<a href="https://github.com/opencontainers/runc" class="ext-link" rel="external ">runc</a>和<a href="https://containerd.io/" class="ext-link" rel="external "> containerd </a>之上的云原生工具在架构上不一致。</p>
<p class="translated">Kniep补充说，除了适应共享内存和内核旁路，还需要更多的后续工作。需要做的工作是将容器化的工作负载放入HPC工作负载调度器，最值得注意的是<a href="https://www.hpc.cam.ac.uk/using-clusters/running-jobs" class="ext-link" rel="external "> Slurm </a>，这将为其他HPC调度器铺平道路。这些工作负载调度器处理<a href="http://mpitutorial.com/tutorials/mpi-introduction/" class="ext-link" rel="external "> MPI </a>，这是一个复杂的消息传递接口，提供运行相同作业的不同节点之间的通信。</p>
<p class="translated">另一个不错的特性是支持无盘节点，以节省部署时间。作业的容器映像在共享文件系统上复制一次，因此每个节点上的容器引擎可以启动自己的实例。这比让数千个容器引擎同时从同一个存储库中下载同一个映像，然后一个接一个地提取完全相同的文件系统要有效得多。</p>
<p class="translated"><iframe loading="lazy" src="https://www.youtube.com/embed/r9bPHKiagco?start=1773&amp;feature=oembed" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen="">视频</iframe></p>


<div class="tns-logo-slug">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 68 31" version="1.1">
<title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"/>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"/>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"/>
</g>
</g>
</svg> </div>

</div>
</div>    
</body>
</html>