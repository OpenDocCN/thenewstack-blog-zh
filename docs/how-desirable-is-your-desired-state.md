# 你想要的状态有多理想？

> 原文：<https://thenewstack.io/how-desirable-is-your-desired-state/>

把你的脚趾伸进 Kubernetes，你会很快发现“理想状态”的概念。不，这与你的理想工作，或者完美的云原生工具套件，或者你希望如何设计你的 Kubernetes 集群没有任何关系，只要你的意见重要。

这个概念要简单得多:期望的状态表示您希望您的应用程序和集群如何运行，Kubernetes“控制器”创建一个反馈循环来实现这个目标。尽管如此，云原生生态系统已经创造了文化和技术壁垒，使得你想要的状态比以往任何时候都更难实现。障碍包括:

*   只有一些人对 Kubernetes 有足够的了解，能够在概念上或清单级别上定义期望的状态。
*   期望的状态随着市场和客户(你有多少和他们的期望)而变化。
*   理想的状态取决于您正在使用的云原生工具。一些公司使用裸 YAML，其他公司为他们的部署生成掌舵图，或者使用 Kustomize 来区分不同的环境。
*   它还取决于应用程序源代码、打包方式以及应用程序存储的数据。
*   随着您的组织的发展，您希望拥有对您所期望的状态的每一次变更的历史，就像您对版本控制所做的那样——您是如何以及为什么对您所期望的状态做出那些变更的。

所有这些都让我们想知道，理想状态到底有多理想。

## Kubernetes 的‘理想状态’是什么？

有一个关于控制循环的常见类比，有助于区分当前状态和期望状态。当你把恒温器调到特定的温度时，你就建立了你想要的状态。在 HVAC 设备的帮助下，恒温器的工作是将房间从当前状态(当前温度)带到期望的状态(设定温度)。恒温器通过这个检查-改变循环反复循环，以保持状态一致。

在 Kubernetes 中，理想的状态是您的基础设施或应用程序在运行时应该如何运行。[控制器](https://kubernetes.io/docs/concepts/architecture/controller/)是 HVAC 设备——所有让你从 0 到理想状态的神秘机械。你设置的温度就是你的配置。

在云原生世界中，所有这一切都通过一种[声明式](https://ubuntu.com/blog/declarative-vs-imperative-devops-done-right)方法来实现。不是通过列出步骤来配置基础设施，也就是所谓的命令式配置，而是定义集群的每一部分应该如何操作，让 Kubernetes 去操心那些脏活累活。这也非常适合基础设施即代码(IaC ),在 IaC 中，管理和配置基础设施是一个自动化而非手动的过程。

> 在 Kubernetes 中，理想的状态是您的基础设施或应用程序在运行时应该如何运行。

Kubernetes 控制器持续运行并跟踪相关对象(pod、服务等)。)，寻找 YAML 配置中提供的`spec`字段(期望状态)和存储当前状态的`status`字段之间的差异。如果有变化，它会通过调用 API 服务器自动采取行动，进行必要的更改以缩小差距。

这个循环系统就是 Kubernetes 如何处理不断变化的大量移动部件和不断变化的变量，就像有人试图平衡一个太多的盘子。例如，您的实际应用程序状态是应用程序映像、Kubernetes 的期望状态和应用程序状态的混合，存储在通常位于集群本身外部的数据库中。

这种复杂性意味着您的集群经常不可能达到期望的状态，这使它更像是一个白日梦，一个总是在移动的目标。

那么，你想要的状态取决于四件事:

*   代码及其运行的操作系统(作为映像存储在容器注册表中)。
*   将映像部署到 Kubernetes 所需的配置。
*   使用配置部署映像的 CD 进程的输出，如果需要，可以对其进行修改。
*   存储在应用程序中的数据(通常存储在数据库中)。

## 容器注册表和您的清单

Kubernetes 控制器总是试图同步期望状态和实际状态，但是您的应用程序状态还取决于其他事情。您正在处理的一个板块是您的容器注册表，它负责存储为您的容器和 pod(您的整个基础设施)提供基础的所有图像。您的映像将保存正在部署的代码版本。

随着应用程序的发展或底层操作系统的变化，您的应用程序必须更新。这些更改通过您的 CI/CD 管道转移到不同的环境中，从而生成新的映像。在容器中，图像被设计成“分层”的，几层构建在另一层之上，以提供最终的容器用途。例如，您可以有一个基础层，即操作系统，而您的应用程序运行在第二层，或者您可以有更多的层用于更复杂的应用程序。

> 所有这些编辑、调整和可能性对您的容器注册表都有现实意义，因为它试图提供将您的集群恢复到所需状态所需的图像。

因为 Kubernetes(和现代软件开发风格)鼓励持续的应用程序部署，您很可能会及时改变这两个层:

*   您将为应用程序所依赖的新版本的库/服务更新基础操作系统层。
*   您将更新您的应用程序层，以获得应用程序本身中更新的依赖项或新特性/错误修复。

有时，这些变化也是由更大的架构变化驱动的。例如，您需要更改您的数据库，因为您的客户数据太大，不再能充分发挥作用，因此您需要更改您想要的状态，这实际上可能意味着对图像的每一层进行额外的调整。或者，如果您正在处理多区域部署，您的映像需要可配置，以便在您的全球基础架构中均匀部署单元。

为了管理所有这些映像级别的更改，您应该使用特定的标签来安装操作系统和应用程序级别的验证版本，而不是简单地使用`latest`并期待最好的结果。然后，更新映像版本不再由控制器在更新后自动完成，因此您需要在准备就绪时触发更新。

所有这些编辑、调整和可能性对您的容器注册表都有现实意义，因为它试图提供将您的集群恢复到所需状态所需的图像。

## 您的 CD 流程:需要部署

Kubernetes 控制器确保您的应用程序状态是您所定义的，但是您需要从配置的本地定义转移到集群中定义的期望状态，确保中间没有任何中断。

从我们的角度来看， [Argo CD](https://argo-cd.readthedocs.io/en/stable/) 和 [Flux](https://fluxcd.io/) 是云原生连续交付(CD)的领导者。它们都遵循 [GitOps](https://monokle.io/blog/advanced-git) 模式，使用 git 存储库作为定义基础设施/应用程序所需状态的单一来源，并作为应用程序部署在集群内部。

CD 工具监视您的 git 仓库中清单的变化(无论是普通的基于 YAML 的清单、舵图还是 Kustomize 应用程序),并自动将它们与您的集群同步。为了避免问题，执行不同种类的自动测试。如果测试发现了问题，开发人员会被要求更改配置并重试。即使这在大多数情况下是可行的，让一些人来检查这些变化以确保你不会引入一个你的测试没有覆盖的问题也是一个很好的实践。

在自动化测试和开发人员向同行提出的批准或拒绝他们的更改的拉/合并请求之间，这些过程旨在通过允许频繁的发布来改善最终用户体验。这有时看起来很麻烦，但是通过减少部署所需的时间，您可以交付更高质量的代码，并通过控制谁将代码投入生产来提高安全性。

CD 管道可以用于基于拉或基于推的部署。在基于推送的部署中，您使用某种动作来触发 CD 进程，比如 GitHub 动作或 Webhook。在基于拉的部署中，代理识别何时进行了更改，并自动触发该过程。在任何情况下，构建都可能包含许多步骤，包括确认和验证。

一些高级工具，比如这里提出的工具，支持两种类型的 [GitOps](https://thenewstack.io/does-the-gitops-emperor-have-no-clothes/) 。IaC 的一些高级工具通过提供一些幂等性减轻了命令性策略(您可以多次执行它们，结果不会改变)，但是您需要编写所需的步骤。两者都有利弊，但最终，最重要的是以最好的方式定义你想要的状态。

## 吉托普斯时代的和解与漂移

当您使用 GitOps 和 IaC 时，您的 CD 触发器通常是实际状态和期望状态之间的差异。但是，如果实际状态的变化超出了您的直接干预，或者控制器无法达到期望的状态，会发生什么呢？Kubernetes 喜欢声明式配置，但它使用`kubectl`来响应命令性命令，这些命令会改变状态，并且不依赖于 YAML 清单。这就是[我们所说的漂移](https://thenewstack.io/how-drift-detection-and-iac-help-maintain-a-secure-infrastructure/)，它可能因多种原因而发生，如应用程序配置、运行时环境、自动缩放的变化或图像一层或多层的变化。

您甚至可能需要在特定的 pod 中快速进行手动配置更改，例如为它提供更高的内存`request`以防止它崩溃并影响最终用户体验。您现在有一个带外更改，它与您之前定义的期望状态不一致，但是您也实现了您的弹性和可靠性目标。

> 每次您进行手动更改时，您的 CD 管道将尝试恢复它，因此您需要禁用您的 CD 或在配置中修改您想要的状态以使其永久化。

每次您进行手动更改时，您的 CD 管道将尝试恢复它，因此您需要禁用您的 CD 或在配置中修改您想要的状态以使其永久化。如果你为你的生产问题找到了完美的短期解决方案，但 CD 管道通过进入一个不工作的定义状态来不断“修复它”,那就没有意思了。

另外，你想要的状态也取决于政策。你如何确定当前的政策已经到位？您是否在使用经过验证的图像，避免使用“最新”版本，而是使用经过批准的特定版本？有一些最佳实践和策略可以帮助您提高部署的安全性和可维护性，您可以自动应用这些实践和策略。

[开放策略代理](https://www.openpolicyagent.org/)和 [Kyverno](https://kyverno.io/) 是为云原生基础设施/应用应用策略的最常用项目。每次您的[策略发生变化](https://thenewstack.io/cloud-engineers-try-policy-as-code-to-cure-misconfiguration-woes/)——例如，有人定义了成本管理所需的标签——您想要的状态也会发生变化，这通常意味着额外的配置变化。

哪一个赢了？理想状态的白日梦或者你的终端用户想要什么，一个实际工作的应用程序？现在，您或您的 CI/CD 渠道需要开始采取具体行动，通过协调减少偏差。

## 从容器到生产，你如何控制你想要的状态？

当你看到理想状态、容器复杂性和调和/漂移的现实时，“你构建它，你部署它”的梦想看起来就像是一个梦。尽管在 DevOps、GitOps、应用站点可靠性工程等职位的工作描述中讲述了这个故事，但是对于开发人员来说，在生产中维护他们自己的应用程序有太多的移动部分。

无论您的组织在开发运维、平台工程或 GitOps 上投入了多少资金，现实情况是您永远无法确保达到您所配置的理想状态。您需要适应这种情况，及时更新所需状态的配置，并随时将其与集群中部署的实际状态进行比较。

许多组织正在通过内部开发人员平台解决有关理想状态的问题，这些平台将 Kubernetes 配置的复杂性抽象为服务、工具和服务的精选目录，但这些平台在带来好处的同时也带来了新的挑战。当出现问题时，平台工程师会浪费时间深入到自动生成的配置中寻找答案，在满足开发人员的要求(许多库和应用程序的最新版本)和通过遵循其他策略确保其正确安全地工作之间，总会有一个平衡。

根据最佳实践变化的速度，我们还远远没有看到云原生社区在任何一个策略上达成一致。有一些项目旨在简化这一过程:如果开发人员使用新的 X 部署语言，将概念抽象为更高级别的语言，他们就不需要知道 Kubernetes 的细节。这个想法很棒，过去已经在基础设施(Puppet、Ansible、Salt 等)中付诸实践。但是复杂的问题通常不会在抽象层得到唯一的解决。

最后，您需要一个工具，将使用 Kubernetes 配置的任何人，从开发人员到开发人员到平台工程师，都带到同一个高效的平台上，在这个平台上，他们可以通过以下方式更好地了解所需的状态:

*   了解正在使用哪些图像。
*   可视化创建的每个资源及其依赖关系。
*   根据模式和策略验证配置。
*   协调具有视觉差异的跨分支和环境的配置版本。
*   与其他团队合作防止漂移。

对这个工作台的迫切需求是我们构建 [Monokle Cloud](http://app.monokle.com/) 和 Monokle Desktop 的原因，Monokle Desktop 是一套用于探索和分析 Kubernetes 配置以及优化 GitOps 工作流的免费工具。

需要更多的证据吗？用你的 GitHub 档案登录 Monokle Cloud，看看 Argo CD 库中[两个发布分支的视觉差异。或者看看我们的首席工程师 Wito Delnat 的这个](https://app.monokle.com/explore/github/argoproj/argo-cd?c=type%3Agit%2Cbranch%3Arelease-2.5%2Ccommit%3A872e1f2%3Btype%3Agit%2Cbranch%3Arelease-2.4%2Ccommit%3A2ccc17a))[快速演示视频](https://www.youtube.com/watch?v=ds4OLjlI620)。

加入我们实现理想状态的梦想吧！

<svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 68 31" version="1.1"><title>Group</title> <desc>Created with Sketch.</desc></svg>